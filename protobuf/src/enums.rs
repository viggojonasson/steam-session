// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by protoc --rust_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `enums.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_1;

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileQueryType)
pub enum EPublishedFileQueryType {
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByVote)
    k_PublishedFileQueryType_RankedByVote = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByPublicationDate)
    k_PublishedFileQueryType_RankedByPublicationDate = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate)
    k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate = 2,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTrend)
    k_PublishedFileQueryType_RankedByTrend = 3,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate)
    k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate = 4,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate)
    k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate = 5,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByNumTimesReported)
    k_PublishedFileQueryType_RankedByNumTimesReported = 6,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate)
    k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate = 7,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_NotYetRated)
    k_PublishedFileQueryType_NotYetRated = 8,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions)
    k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions = 9,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTotalVotesAsc)
    k_PublishedFileQueryType_RankedByTotalVotesAsc = 10,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByVotesUp)
    k_PublishedFileQueryType_RankedByVotesUp = 11,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTextSearch)
    k_PublishedFileQueryType_RankedByTextSearch = 12,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByPlaytimeTrend)
    k_PublishedFileQueryType_RankedByPlaytimeTrend = 13,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTotalPlaytime)
    k_PublishedFileQueryType_RankedByTotalPlaytime = 14,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByAveragePlaytimeTrend)
    k_PublishedFileQueryType_RankedByAveragePlaytimeTrend = 15,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime)
    k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime = 16,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend)
    k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend = 17,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions)
    k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions = 18,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByInappropriateContentRating)
    k_PublishedFileQueryType_RankedByInappropriateContentRating = 19,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByBanContentCheck)
    k_PublishedFileQueryType_RankedByBanContentCheck = 20,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByLastUpdatedDate)
    k_PublishedFileQueryType_RankedByLastUpdatedDate = 21,
}

impl ::protobuf::Enum for EPublishedFileQueryType {
    const NAME: &'static str = "EPublishedFileQueryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileQueryType> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote),
            1 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate),
            2 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate),
            3 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend),
            4 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate),
            5 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate),
            6 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported),
            7 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate),
            8 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated),
            9 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions),
            10 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc),
            11 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp),
            12 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch),
            13 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend),
            14 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime),
            15 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend),
            16 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime),
            17 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend),
            18 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions),
            19 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating),
            20 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByBanContentCheck),
            21 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLastUpdatedDate),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileQueryType> {
        match str {
            "k_PublishedFileQueryType_RankedByVote" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote),
            "k_PublishedFileQueryType_RankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate),
            "k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate),
            "k_PublishedFileQueryType_RankedByTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend),
            "k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate),
            "k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate),
            "k_PublishedFileQueryType_RankedByNumTimesReported" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported),
            "k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate),
            "k_PublishedFileQueryType_NotYetRated" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated),
            "k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions),
            "k_PublishedFileQueryType_RankedByTotalVotesAsc" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc),
            "k_PublishedFileQueryType_RankedByVotesUp" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp),
            "k_PublishedFileQueryType_RankedByTextSearch" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch),
            "k_PublishedFileQueryType_RankedByPlaytimeTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend),
            "k_PublishedFileQueryType_RankedByTotalPlaytime" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime),
            "k_PublishedFileQueryType_RankedByAveragePlaytimeTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend),
            "k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime),
            "k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend),
            "k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions),
            "k_PublishedFileQueryType_RankedByInappropriateContentRating" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating),
            "k_PublishedFileQueryType_RankedByBanContentCheck" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByBanContentCheck),
            "k_PublishedFileQueryType_RankedByLastUpdatedDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLastUpdatedDate),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileQueryType] = &[
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported,
        EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByBanContentCheck,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLastUpdatedDate,
    ];
}

impl ::protobuf::EnumFull for EPublishedFileQueryType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPublishedFileQueryType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPublishedFileQueryType {
    fn default() -> Self {
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote
    }
}

impl EPublishedFileQueryType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPublishedFileQueryType>("EPublishedFileQueryType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileInappropriateProvider)
pub enum EPublishedFileInappropriateProvider {
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateProvider.k_EPublishedFileInappropriateProvider_Invalid)
    k_EPublishedFileInappropriateProvider_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateProvider.k_EPublishedFileInappropriateProvider_Google)
    k_EPublishedFileInappropriateProvider_Google = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateProvider.k_EPublishedFileInappropriateProvider_Amazon)
    k_EPublishedFileInappropriateProvider_Amazon = 2,
}

impl ::protobuf::Enum for EPublishedFileInappropriateProvider {
    const NAME: &'static str = "EPublishedFileInappropriateProvider";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileInappropriateProvider> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid),
            1 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google),
            2 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileInappropriateProvider> {
        match str {
            "k_EPublishedFileInappropriateProvider_Invalid" => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid),
            "k_EPublishedFileInappropriateProvider_Google" => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google),
            "k_EPublishedFileInappropriateProvider_Amazon" => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileInappropriateProvider] = &[
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid,
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google,
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon,
    ];
}

impl ::protobuf::EnumFull for EPublishedFileInappropriateProvider {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPublishedFileInappropriateProvider").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPublishedFileInappropriateProvider {
    fn default() -> Self {
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid
    }
}

impl EPublishedFileInappropriateProvider {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPublishedFileInappropriateProvider>("EPublishedFileInappropriateProvider")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileInappropriateResult)
pub enum EPublishedFileInappropriateResult {
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_NotScanned)
    k_EPublishedFileInappropriateResult_NotScanned = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_VeryUnlikely)
    k_EPublishedFileInappropriateResult_VeryUnlikely = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_Unlikely)
    k_EPublishedFileInappropriateResult_Unlikely = 30,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_Possible)
    k_EPublishedFileInappropriateResult_Possible = 50,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_Likely)
    k_EPublishedFileInappropriateResult_Likely = 75,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_VeryLikely)
    k_EPublishedFileInappropriateResult_VeryLikely = 100,
}

impl ::protobuf::Enum for EPublishedFileInappropriateResult {
    const NAME: &'static str = "EPublishedFileInappropriateResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileInappropriateResult> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned),
            1 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely),
            30 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely),
            50 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible),
            75 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely),
            100 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileInappropriateResult> {
        match str {
            "k_EPublishedFileInappropriateResult_NotScanned" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned),
            "k_EPublishedFileInappropriateResult_VeryUnlikely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely),
            "k_EPublishedFileInappropriateResult_Unlikely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely),
            "k_EPublishedFileInappropriateResult_Possible" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible),
            "k_EPublishedFileInappropriateResult_Likely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely),
            "k_EPublishedFileInappropriateResult_VeryLikely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileInappropriateResult] = &[
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely,
    ];
}

impl ::protobuf::EnumFull for EPublishedFileInappropriateResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPublishedFileInappropriateResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned => 0,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely => 1,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely => 2,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible => 3,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely => 4,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPublishedFileInappropriateResult {
    fn default() -> Self {
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned
    }
}

impl EPublishedFileInappropriateResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPublishedFileInappropriateResult>("EPublishedFileInappropriateResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPersonaStateFlag)
pub enum EPersonaStateFlag {
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_HasRichPresence)
    k_EPersonaStateFlag_HasRichPresence = 1,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_InJoinableGame)
    k_EPersonaStateFlag_InJoinableGame = 2,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_Golden)
    k_EPersonaStateFlag_Golden = 4,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_RemotePlayTogether)
    k_EPersonaStateFlag_RemotePlayTogether = 8,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeWeb)
    k_EPersonaStateFlag_ClientTypeWeb = 256,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeMobile)
    k_EPersonaStateFlag_ClientTypeMobile = 512,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeTenfoot)
    k_EPersonaStateFlag_ClientTypeTenfoot = 1024,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeVR)
    k_EPersonaStateFlag_ClientTypeVR = 2048,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_LaunchTypeGamepad)
    k_EPersonaStateFlag_LaunchTypeGamepad = 4096,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_LaunchTypeCompatTool)
    k_EPersonaStateFlag_LaunchTypeCompatTool = 8192,
}

impl ::protobuf::Enum for EPersonaStateFlag {
    const NAME: &'static str = "EPersonaStateFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPersonaStateFlag> {
        match value {
            1 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence),
            2 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame),
            4 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_Golden),
            8 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether),
            256 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb),
            512 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile),
            1024 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot),
            2048 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR),
            4096 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad),
            8192 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPersonaStateFlag> {
        match str {
            "k_EPersonaStateFlag_HasRichPresence" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence),
            "k_EPersonaStateFlag_InJoinableGame" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame),
            "k_EPersonaStateFlag_Golden" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_Golden),
            "k_EPersonaStateFlag_RemotePlayTogether" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether),
            "k_EPersonaStateFlag_ClientTypeWeb" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb),
            "k_EPersonaStateFlag_ClientTypeMobile" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile),
            "k_EPersonaStateFlag_ClientTypeTenfoot" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot),
            "k_EPersonaStateFlag_ClientTypeVR" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR),
            "k_EPersonaStateFlag_LaunchTypeGamepad" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad),
            "k_EPersonaStateFlag_LaunchTypeCompatTool" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPersonaStateFlag] = &[
        EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence,
        EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame,
        EPersonaStateFlag::k_EPersonaStateFlag_Golden,
        EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR,
        EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad,
        EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool,
    ];
}

impl ::protobuf::EnumFull for EPersonaStateFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPersonaStateFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence => 0,
            EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame => 1,
            EPersonaStateFlag::k_EPersonaStateFlag_Golden => 2,
            EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether => 3,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb => 4,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile => 5,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot => 6,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR => 7,
            EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad => 8,
            EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EPersonaStateFlag {
    fn default() -> Self {
        EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence
    }
}

impl EPersonaStateFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPersonaStateFlag>("EPersonaStateFlag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EContentCheckProvider)
pub enum EContentCheckProvider {
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Invalid)
    k_EContentCheckProvider_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Google)
    k_EContentCheckProvider_Google = 1,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Amazon)
    k_EContentCheckProvider_Amazon = 2,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Local)
    k_EContentCheckProvider_Local = 3,
}

impl ::protobuf::Enum for EContentCheckProvider {
    const NAME: &'static str = "EContentCheckProvider";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EContentCheckProvider> {
        match value {
            0 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Invalid),
            1 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Google),
            2 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Amazon),
            3 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Local),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EContentCheckProvider> {
        match str {
            "k_EContentCheckProvider_Invalid" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Invalid),
            "k_EContentCheckProvider_Google" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Google),
            "k_EContentCheckProvider_Amazon" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Amazon),
            "k_EContentCheckProvider_Local" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Local),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EContentCheckProvider] = &[
        EContentCheckProvider::k_EContentCheckProvider_Invalid,
        EContentCheckProvider::k_EContentCheckProvider_Google,
        EContentCheckProvider::k_EContentCheckProvider_Amazon,
        EContentCheckProvider::k_EContentCheckProvider_Local,
    ];
}

impl ::protobuf::EnumFull for EContentCheckProvider {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EContentCheckProvider").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EContentCheckProvider {
    fn default() -> Self {
        EContentCheckProvider::k_EContentCheckProvider_Invalid
    }
}

impl EContentCheckProvider {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EContentCheckProvider>("EContentCheckProvider")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProfileCustomizationType)
pub enum EProfileCustomizationType {
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeInvalid)
    k_EProfileCustomizationTypeInvalid = 0,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeRareAchievementShowcase)
    k_EProfileCustomizationTypeRareAchievementShowcase = 1,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeGameCollector)
    k_EProfileCustomizationTypeGameCollector = 2,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeItemShowcase)
    k_EProfileCustomizationTypeItemShowcase = 3,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeTradeShowcase)
    k_EProfileCustomizationTypeTradeShowcase = 4,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeBadges)
    k_EProfileCustomizationTypeBadges = 5,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeFavoriteGame)
    k_EProfileCustomizationTypeFavoriteGame = 6,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeScreenshotShowcase)
    k_EProfileCustomizationTypeScreenshotShowcase = 7,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeCustomText)
    k_EProfileCustomizationTypeCustomText = 8,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeFavoriteGroup)
    k_EProfileCustomizationTypeFavoriteGroup = 9,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeRecommendation)
    k_EProfileCustomizationTypeRecommendation = 10,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeWorkshopItem)
    k_EProfileCustomizationTypeWorkshopItem = 11,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeMyWorkshop)
    k_EProfileCustomizationTypeMyWorkshop = 12,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeArtworkShowcase)
    k_EProfileCustomizationTypeArtworkShowcase = 13,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeVideoShowcase)
    k_EProfileCustomizationTypeVideoShowcase = 14,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeGuides)
    k_EProfileCustomizationTypeGuides = 15,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeMyGuides)
    k_EProfileCustomizationTypeMyGuides = 16,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeAchievements)
    k_EProfileCustomizationTypeAchievements = 17,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeGreenlight)
    k_EProfileCustomizationTypeGreenlight = 18,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeMyGreenlight)
    k_EProfileCustomizationTypeMyGreenlight = 19,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeSalien)
    k_EProfileCustomizationTypeSalien = 20,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeLoyaltyRewardReactions)
    k_EProfileCustomizationTypeLoyaltyRewardReactions = 21,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeSingleArtworkShowcase)
    k_EProfileCustomizationTypeSingleArtworkShowcase = 22,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeAchievementsCompletionist)
    k_EProfileCustomizationTypeAchievementsCompletionist = 23,
}

impl ::protobuf::Enum for EProfileCustomizationType {
    const NAME: &'static str = "EProfileCustomizationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProfileCustomizationType> {
        match value {
            0 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeInvalid),
            1 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase),
            2 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector),
            3 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase),
            4 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase),
            5 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeBadges),
            6 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame),
            7 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase),
            8 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeCustomText),
            9 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup),
            10 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation),
            11 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem),
            12 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop),
            13 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase),
            14 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase),
            15 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGuides),
            16 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides),
            17 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievements),
            18 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight),
            19 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight),
            20 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSalien),
            21 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeLoyaltyRewardReactions),
            22 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSingleArtworkShowcase),
            23 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievementsCompletionist),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProfileCustomizationType> {
        match str {
            "k_EProfileCustomizationTypeInvalid" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeInvalid),
            "k_EProfileCustomizationTypeRareAchievementShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase),
            "k_EProfileCustomizationTypeGameCollector" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector),
            "k_EProfileCustomizationTypeItemShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase),
            "k_EProfileCustomizationTypeTradeShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase),
            "k_EProfileCustomizationTypeBadges" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeBadges),
            "k_EProfileCustomizationTypeFavoriteGame" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame),
            "k_EProfileCustomizationTypeScreenshotShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase),
            "k_EProfileCustomizationTypeCustomText" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeCustomText),
            "k_EProfileCustomizationTypeFavoriteGroup" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup),
            "k_EProfileCustomizationTypeRecommendation" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation),
            "k_EProfileCustomizationTypeWorkshopItem" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem),
            "k_EProfileCustomizationTypeMyWorkshop" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop),
            "k_EProfileCustomizationTypeArtworkShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase),
            "k_EProfileCustomizationTypeVideoShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase),
            "k_EProfileCustomizationTypeGuides" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGuides),
            "k_EProfileCustomizationTypeMyGuides" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides),
            "k_EProfileCustomizationTypeAchievements" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievements),
            "k_EProfileCustomizationTypeGreenlight" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight),
            "k_EProfileCustomizationTypeMyGreenlight" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight),
            "k_EProfileCustomizationTypeSalien" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSalien),
            "k_EProfileCustomizationTypeLoyaltyRewardReactions" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeLoyaltyRewardReactions),
            "k_EProfileCustomizationTypeSingleArtworkShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSingleArtworkShowcase),
            "k_EProfileCustomizationTypeAchievementsCompletionist" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievementsCompletionist),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProfileCustomizationType] = &[
        EProfileCustomizationType::k_EProfileCustomizationTypeInvalid,
        EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector,
        EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeBadges,
        EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame,
        EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeCustomText,
        EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup,
        EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation,
        EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem,
        EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop,
        EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeGuides,
        EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides,
        EProfileCustomizationType::k_EProfileCustomizationTypeAchievements,
        EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight,
        EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight,
        EProfileCustomizationType::k_EProfileCustomizationTypeSalien,
        EProfileCustomizationType::k_EProfileCustomizationTypeLoyaltyRewardReactions,
        EProfileCustomizationType::k_EProfileCustomizationTypeSingleArtworkShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeAchievementsCompletionist,
    ];
}

impl ::protobuf::EnumFull for EProfileCustomizationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EProfileCustomizationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EProfileCustomizationType {
    fn default() -> Self {
        EProfileCustomizationType::k_EProfileCustomizationTypeInvalid
    }
}

impl EProfileCustomizationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EProfileCustomizationType>("EProfileCustomizationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileStorageSystem)
pub enum EPublishedFileStorageSystem {
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemInvalid)
    k_EPublishedFileStorageSystemInvalid = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemLegacyCloud)
    k_EPublishedFileStorageSystemLegacyCloud = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemDepot)
    k_EPublishedFileStorageSystemDepot = 2,
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemUGCCloud)
    k_EPublishedFileStorageSystemUGCCloud = 3,
}

impl ::protobuf::Enum for EPublishedFileStorageSystem {
    const NAME: &'static str = "EPublishedFileStorageSystem";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileStorageSystem> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid),
            1 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemLegacyCloud),
            2 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemDepot),
            3 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemUGCCloud),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileStorageSystem> {
        match str {
            "k_EPublishedFileStorageSystemInvalid" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid),
            "k_EPublishedFileStorageSystemLegacyCloud" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemLegacyCloud),
            "k_EPublishedFileStorageSystemDepot" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemDepot),
            "k_EPublishedFileStorageSystemUGCCloud" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemUGCCloud),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileStorageSystem] = &[
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid,
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemLegacyCloud,
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemDepot,
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemUGCCloud,
    ];
}

impl ::protobuf::EnumFull for EPublishedFileStorageSystem {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPublishedFileStorageSystem").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPublishedFileStorageSystem {
    fn default() -> Self {
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid
    }
}

impl EPublishedFileStorageSystem {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EPublishedFileStorageSystem>("EPublishedFileStorageSystem")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECloudStoragePersistState)
pub enum ECloudStoragePersistState {
    // @@protoc_insertion_point(enum_value:ECloudStoragePersistState.k_ECloudStoragePersistStatePersisted)
    k_ECloudStoragePersistStatePersisted = 0,
    // @@protoc_insertion_point(enum_value:ECloudStoragePersistState.k_ECloudStoragePersistStateForgotten)
    k_ECloudStoragePersistStateForgotten = 1,
    // @@protoc_insertion_point(enum_value:ECloudStoragePersistState.k_ECloudStoragePersistStateDeleted)
    k_ECloudStoragePersistStateDeleted = 2,
}

impl ::protobuf::Enum for ECloudStoragePersistState {
    const NAME: &'static str = "ECloudStoragePersistState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECloudStoragePersistState> {
        match value {
            0 => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted),
            1 => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateForgotten),
            2 => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateDeleted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECloudStoragePersistState> {
        match str {
            "k_ECloudStoragePersistStatePersisted" => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted),
            "k_ECloudStoragePersistStateForgotten" => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateForgotten),
            "k_ECloudStoragePersistStateDeleted" => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateDeleted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECloudStoragePersistState] = &[
        ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted,
        ECloudStoragePersistState::k_ECloudStoragePersistStateForgotten,
        ECloudStoragePersistState::k_ECloudStoragePersistStateDeleted,
    ];
}

impl ::protobuf::EnumFull for ECloudStoragePersistState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECloudStoragePersistState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECloudStoragePersistState {
    fn default() -> Self {
        ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted
    }
}

impl ECloudStoragePersistState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECloudStoragePersistState>("ECloudStoragePersistState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESDCardFormatStage)
pub enum ESDCardFormatStage {
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Invalid)
    k_ESDCardFormatStage_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Starting)
    k_ESDCardFormatStage_Starting = 1,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Testing)
    k_ESDCardFormatStage_Testing = 2,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Rescuing)
    k_ESDCardFormatStage_Rescuing = 3,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Formatting)
    k_ESDCardFormatStage_Formatting = 4,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Finalizing)
    k_ESDCardFormatStage_Finalizing = 5,
}

impl ::protobuf::Enum for ESDCardFormatStage {
    const NAME: &'static str = "ESDCardFormatStage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESDCardFormatStage> {
        match value {
            0 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Invalid),
            1 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Starting),
            2 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Testing),
            3 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Rescuing),
            4 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Formatting),
            5 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESDCardFormatStage> {
        match str {
            "k_ESDCardFormatStage_Invalid" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Invalid),
            "k_ESDCardFormatStage_Starting" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Starting),
            "k_ESDCardFormatStage_Testing" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Testing),
            "k_ESDCardFormatStage_Rescuing" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Rescuing),
            "k_ESDCardFormatStage_Formatting" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Formatting),
            "k_ESDCardFormatStage_Finalizing" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESDCardFormatStage] = &[
        ESDCardFormatStage::k_ESDCardFormatStage_Invalid,
        ESDCardFormatStage::k_ESDCardFormatStage_Starting,
        ESDCardFormatStage::k_ESDCardFormatStage_Testing,
        ESDCardFormatStage::k_ESDCardFormatStage_Rescuing,
        ESDCardFormatStage::k_ESDCardFormatStage_Formatting,
        ESDCardFormatStage::k_ESDCardFormatStage_Finalizing,
    ];
}

impl ::protobuf::EnumFull for ESDCardFormatStage {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESDCardFormatStage").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESDCardFormatStage {
    fn default() -> Self {
        ESDCardFormatStage::k_ESDCardFormatStage_Invalid
    }
}

impl ESDCardFormatStage {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESDCardFormatStage>("ESDCardFormatStage")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemFanControlMode)
pub enum ESystemFanControlMode {
    // @@protoc_insertion_point(enum_value:ESystemFanControlMode.k_SystemFanControlMode_Invalid)
    k_SystemFanControlMode_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemFanControlMode.k_SystemFanControlMode_Disabled)
    k_SystemFanControlMode_Disabled = 1,
    // @@protoc_insertion_point(enum_value:ESystemFanControlMode.k_SystemFanControlMode_Default)
    k_SystemFanControlMode_Default = 2,
}

impl ::protobuf::Enum for ESystemFanControlMode {
    const NAME: &'static str = "ESystemFanControlMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemFanControlMode> {
        match value {
            0 => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Invalid),
            1 => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Disabled),
            2 => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Default),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemFanControlMode> {
        match str {
            "k_SystemFanControlMode_Invalid" => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Invalid),
            "k_SystemFanControlMode_Disabled" => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Disabled),
            "k_SystemFanControlMode_Default" => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Default),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemFanControlMode] = &[
        ESystemFanControlMode::k_SystemFanControlMode_Invalid,
        ESystemFanControlMode::k_SystemFanControlMode_Disabled,
        ESystemFanControlMode::k_SystemFanControlMode_Default,
    ];
}

impl ::protobuf::EnumFull for ESystemFanControlMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemFanControlMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemFanControlMode {
    fn default() -> Self {
        ESystemFanControlMode::k_SystemFanControlMode_Invalid
    }
}

impl ESystemFanControlMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESystemFanControlMode>("ESystemFanControlMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EColorProfile)
pub enum EColorProfile {
    // @@protoc_insertion_point(enum_value:EColorProfile.k_EColorProfile_Invalid)
    k_EColorProfile_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EColorProfile.k_EColorProfile_Native)
    k_EColorProfile_Native = 1,
    // @@protoc_insertion_point(enum_value:EColorProfile.k_EColorProfile_Standard)
    k_EColorProfile_Standard = 2,
    // @@protoc_insertion_point(enum_value:EColorProfile.k_EColorProfile_Vivid)
    k_EColorProfile_Vivid = 3,
}

impl ::protobuf::Enum for EColorProfile {
    const NAME: &'static str = "EColorProfile";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EColorProfile> {
        match value {
            0 => ::std::option::Option::Some(EColorProfile::k_EColorProfile_Invalid),
            1 => ::std::option::Option::Some(EColorProfile::k_EColorProfile_Native),
            2 => ::std::option::Option::Some(EColorProfile::k_EColorProfile_Standard),
            3 => ::std::option::Option::Some(EColorProfile::k_EColorProfile_Vivid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EColorProfile> {
        match str {
            "k_EColorProfile_Invalid" => ::std::option::Option::Some(EColorProfile::k_EColorProfile_Invalid),
            "k_EColorProfile_Native" => ::std::option::Option::Some(EColorProfile::k_EColorProfile_Native),
            "k_EColorProfile_Standard" => ::std::option::Option::Some(EColorProfile::k_EColorProfile_Standard),
            "k_EColorProfile_Vivid" => ::std::option::Option::Some(EColorProfile::k_EColorProfile_Vivid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EColorProfile] = &[
        EColorProfile::k_EColorProfile_Invalid,
        EColorProfile::k_EColorProfile_Native,
        EColorProfile::k_EColorProfile_Standard,
        EColorProfile::k_EColorProfile_Vivid,
    ];
}

impl ::protobuf::EnumFull for EColorProfile {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EColorProfile").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EColorProfile {
    fn default() -> Self {
        EColorProfile::k_EColorProfile_Invalid
    }
}

impl EColorProfile {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EColorProfile>("EColorProfile")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBluetoothDeviceType)
pub enum EBluetoothDeviceType {
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Invalid)
    k_BluetoothDeviceType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Unknown)
    k_BluetoothDeviceType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Phone)
    k_BluetoothDeviceType_Phone = 2,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Computer)
    k_BluetoothDeviceType_Computer = 3,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Headset)
    k_BluetoothDeviceType_Headset = 4,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Headphones)
    k_BluetoothDeviceType_Headphones = 5,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Speakers)
    k_BluetoothDeviceType_Speakers = 6,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_OtherAudio)
    k_BluetoothDeviceType_OtherAudio = 7,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Mouse)
    k_BluetoothDeviceType_Mouse = 8,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Joystick)
    k_BluetoothDeviceType_Joystick = 9,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Gamepad)
    k_BluetoothDeviceType_Gamepad = 10,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Keyboard)
    k_BluetoothDeviceType_Keyboard = 11,
}

impl ::protobuf::Enum for EBluetoothDeviceType {
    const NAME: &'static str = "EBluetoothDeviceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBluetoothDeviceType> {
        match value {
            0 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
            1 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Unknown),
            2 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Phone),
            3 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Computer),
            4 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headset),
            5 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headphones),
            6 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Speakers),
            7 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_OtherAudio),
            8 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Mouse),
            9 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Joystick),
            10 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Gamepad),
            11 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Keyboard),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBluetoothDeviceType> {
        match str {
            "k_BluetoothDeviceType_Invalid" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
            "k_BluetoothDeviceType_Unknown" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Unknown),
            "k_BluetoothDeviceType_Phone" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Phone),
            "k_BluetoothDeviceType_Computer" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Computer),
            "k_BluetoothDeviceType_Headset" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headset),
            "k_BluetoothDeviceType_Headphones" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headphones),
            "k_BluetoothDeviceType_Speakers" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Speakers),
            "k_BluetoothDeviceType_OtherAudio" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_OtherAudio),
            "k_BluetoothDeviceType_Mouse" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Mouse),
            "k_BluetoothDeviceType_Joystick" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Joystick),
            "k_BluetoothDeviceType_Gamepad" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Gamepad),
            "k_BluetoothDeviceType_Keyboard" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Keyboard),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBluetoothDeviceType] = &[
        EBluetoothDeviceType::k_BluetoothDeviceType_Invalid,
        EBluetoothDeviceType::k_BluetoothDeviceType_Unknown,
        EBluetoothDeviceType::k_BluetoothDeviceType_Phone,
        EBluetoothDeviceType::k_BluetoothDeviceType_Computer,
        EBluetoothDeviceType::k_BluetoothDeviceType_Headset,
        EBluetoothDeviceType::k_BluetoothDeviceType_Headphones,
        EBluetoothDeviceType::k_BluetoothDeviceType_Speakers,
        EBluetoothDeviceType::k_BluetoothDeviceType_OtherAudio,
        EBluetoothDeviceType::k_BluetoothDeviceType_Mouse,
        EBluetoothDeviceType::k_BluetoothDeviceType_Joystick,
        EBluetoothDeviceType::k_BluetoothDeviceType_Gamepad,
        EBluetoothDeviceType::k_BluetoothDeviceType_Keyboard,
    ];
}

impl ::protobuf::EnumFull for EBluetoothDeviceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBluetoothDeviceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EBluetoothDeviceType {
    fn default() -> Self {
        EBluetoothDeviceType::k_BluetoothDeviceType_Invalid
    }
}

impl EBluetoothDeviceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EBluetoothDeviceType>("EBluetoothDeviceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioDirection)
pub enum ESystemAudioDirection {
    // @@protoc_insertion_point(enum_value:ESystemAudioDirection.k_SystemAudioDirection_Invalid)
    k_SystemAudioDirection_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioDirection.k_SystemAudioDirection_Input)
    k_SystemAudioDirection_Input = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioDirection.k_SystemAudioDirection_Output)
    k_SystemAudioDirection_Output = 2,
}

impl ::protobuf::Enum for ESystemAudioDirection {
    const NAME: &'static str = "ESystemAudioDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioDirection> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Input),
            2 => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioDirection> {
        match str {
            "k_SystemAudioDirection_Invalid" => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Invalid),
            "k_SystemAudioDirection_Input" => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Input),
            "k_SystemAudioDirection_Output" => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioDirection] = &[
        ESystemAudioDirection::k_SystemAudioDirection_Invalid,
        ESystemAudioDirection::k_SystemAudioDirection_Input,
        ESystemAudioDirection::k_SystemAudioDirection_Output,
    ];
}

impl ::protobuf::EnumFull for ESystemAudioDirection {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemAudioDirection").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemAudioDirection {
    fn default() -> Self {
        ESystemAudioDirection::k_SystemAudioDirection_Invalid
    }
}

impl ESystemAudioDirection {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESystemAudioDirection>("ESystemAudioDirection")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioChannel)
pub enum ESystemAudioChannel {
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Invalid)
    k_SystemAudioChannel_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Aggregated)
    k_SystemAudioChannel_Aggregated = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_FrontLeft)
    k_SystemAudioChannel_FrontLeft = 2,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_FrontRight)
    k_SystemAudioChannel_FrontRight = 3,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_LFE)
    k_SystemAudioChannel_LFE = 4,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_BackLeft)
    k_SystemAudioChannel_BackLeft = 5,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_BackRight)
    k_SystemAudioChannel_BackRight = 6,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_FrontCenter)
    k_SystemAudioChannel_FrontCenter = 7,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Unknown)
    k_SystemAudioChannel_Unknown = 8,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Mono)
    k_SystemAudioChannel_Mono = 9,
}

impl ::protobuf::Enum for ESystemAudioChannel {
    const NAME: &'static str = "ESystemAudioChannel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioChannel> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Aggregated),
            2 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontLeft),
            3 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontRight),
            4 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_LFE),
            5 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackLeft),
            6 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackRight),
            7 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontCenter),
            8 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Unknown),
            9 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Mono),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioChannel> {
        match str {
            "k_SystemAudioChannel_Invalid" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Invalid),
            "k_SystemAudioChannel_Aggregated" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Aggregated),
            "k_SystemAudioChannel_FrontLeft" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontLeft),
            "k_SystemAudioChannel_FrontRight" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontRight),
            "k_SystemAudioChannel_LFE" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_LFE),
            "k_SystemAudioChannel_BackLeft" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackLeft),
            "k_SystemAudioChannel_BackRight" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackRight),
            "k_SystemAudioChannel_FrontCenter" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontCenter),
            "k_SystemAudioChannel_Unknown" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Unknown),
            "k_SystemAudioChannel_Mono" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Mono),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioChannel] = &[
        ESystemAudioChannel::k_SystemAudioChannel_Invalid,
        ESystemAudioChannel::k_SystemAudioChannel_Aggregated,
        ESystemAudioChannel::k_SystemAudioChannel_FrontLeft,
        ESystemAudioChannel::k_SystemAudioChannel_FrontRight,
        ESystemAudioChannel::k_SystemAudioChannel_LFE,
        ESystemAudioChannel::k_SystemAudioChannel_BackLeft,
        ESystemAudioChannel::k_SystemAudioChannel_BackRight,
        ESystemAudioChannel::k_SystemAudioChannel_FrontCenter,
        ESystemAudioChannel::k_SystemAudioChannel_Unknown,
        ESystemAudioChannel::k_SystemAudioChannel_Mono,
    ];
}

impl ::protobuf::EnumFull for ESystemAudioChannel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemAudioChannel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemAudioChannel {
    fn default() -> Self {
        ESystemAudioChannel::k_SystemAudioChannel_Invalid
    }
}

impl ESystemAudioChannel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESystemAudioChannel>("ESystemAudioChannel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioPortType)
pub enum ESystemAudioPortType {
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Invalid)
    k_SystemAudioPortType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Unknown)
    k_SystemAudioPortType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Audio32f)
    k_SystemAudioPortType_Audio32f = 2,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Midi8b)
    k_SystemAudioPortType_Midi8b = 3,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Video32RGBA)
    k_SystemAudioPortType_Video32RGBA = 4,
}

impl ::protobuf::Enum for ESystemAudioPortType {
    const NAME: &'static str = "ESystemAudioPortType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioPortType> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Unknown),
            2 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Audio32f),
            3 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Midi8b),
            4 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Video32RGBA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioPortType> {
        match str {
            "k_SystemAudioPortType_Invalid" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Invalid),
            "k_SystemAudioPortType_Unknown" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Unknown),
            "k_SystemAudioPortType_Audio32f" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Audio32f),
            "k_SystemAudioPortType_Midi8b" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Midi8b),
            "k_SystemAudioPortType_Video32RGBA" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Video32RGBA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioPortType] = &[
        ESystemAudioPortType::k_SystemAudioPortType_Invalid,
        ESystemAudioPortType::k_SystemAudioPortType_Unknown,
        ESystemAudioPortType::k_SystemAudioPortType_Audio32f,
        ESystemAudioPortType::k_SystemAudioPortType_Midi8b,
        ESystemAudioPortType::k_SystemAudioPortType_Video32RGBA,
    ];
}

impl ::protobuf::EnumFull for ESystemAudioPortType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemAudioPortType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemAudioPortType {
    fn default() -> Self {
        ESystemAudioPortType::k_SystemAudioPortType_Invalid
    }
}

impl ESystemAudioPortType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESystemAudioPortType>("ESystemAudioPortType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioPortDirection)
pub enum ESystemAudioPortDirection {
    // @@protoc_insertion_point(enum_value:ESystemAudioPortDirection.k_SystemAudioPortDirection_Invalid)
    k_SystemAudioPortDirection_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortDirection.k_SystemAudioPortDirection_Input)
    k_SystemAudioPortDirection_Input = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortDirection.k_SystemAudioPortDirection_Output)
    k_SystemAudioPortDirection_Output = 2,
}

impl ::protobuf::Enum for ESystemAudioPortDirection {
    const NAME: &'static str = "ESystemAudioPortDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioPortDirection> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Input),
            2 => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioPortDirection> {
        match str {
            "k_SystemAudioPortDirection_Invalid" => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid),
            "k_SystemAudioPortDirection_Input" => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Input),
            "k_SystemAudioPortDirection_Output" => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioPortDirection] = &[
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid,
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Input,
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Output,
    ];
}

impl ::protobuf::EnumFull for ESystemAudioPortDirection {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemAudioPortDirection").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemAudioPortDirection {
    fn default() -> Self {
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid
    }
}

impl ESystemAudioPortDirection {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESystemAudioPortDirection>("ESystemAudioPortDirection")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemServiceState)
pub enum ESystemServiceState {
    // @@protoc_insertion_point(enum_value:ESystemServiceState.k_ESystemServiceState_Unavailable)
    k_ESystemServiceState_Unavailable = 0,
    // @@protoc_insertion_point(enum_value:ESystemServiceState.k_ESystemServiceState_Disabled)
    k_ESystemServiceState_Disabled = 1,
    // @@protoc_insertion_point(enum_value:ESystemServiceState.k_ESystemServiceState_Enabled)
    k_ESystemServiceState_Enabled = 2,
}

impl ::protobuf::Enum for ESystemServiceState {
    const NAME: &'static str = "ESystemServiceState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemServiceState> {
        match value {
            0 => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Unavailable),
            1 => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Disabled),
            2 => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Enabled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemServiceState> {
        match str {
            "k_ESystemServiceState_Unavailable" => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Unavailable),
            "k_ESystemServiceState_Disabled" => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Disabled),
            "k_ESystemServiceState_Enabled" => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Enabled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemServiceState] = &[
        ESystemServiceState::k_ESystemServiceState_Unavailable,
        ESystemServiceState::k_ESystemServiceState_Disabled,
        ESystemServiceState::k_ESystemServiceState_Enabled,
    ];
}

impl ::protobuf::EnumFull for ESystemServiceState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemServiceState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemServiceState {
    fn default() -> Self {
        ESystemServiceState::k_ESystemServiceState_Unavailable
    }
}

impl ESystemServiceState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESystemServiceState>("ESystemServiceState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGraphicsPerfOverlayLevel)
pub enum EGraphicsPerfOverlayLevel {
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Hidden)
    k_EGraphicsPerfOverlayLevel_Hidden = 0,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Basic)
    k_EGraphicsPerfOverlayLevel_Basic = 1,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Medium)
    k_EGraphicsPerfOverlayLevel_Medium = 2,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Full)
    k_EGraphicsPerfOverlayLevel_Full = 3,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Minimal)
    k_EGraphicsPerfOverlayLevel_Minimal = 4,
}

impl ::protobuf::Enum for EGraphicsPerfOverlayLevel {
    const NAME: &'static str = "EGraphicsPerfOverlayLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGraphicsPerfOverlayLevel> {
        match value {
            0 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            1 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Basic),
            2 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Medium),
            3 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Full),
            4 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Minimal),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGraphicsPerfOverlayLevel> {
        match str {
            "k_EGraphicsPerfOverlayLevel_Hidden" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            "k_EGraphicsPerfOverlayLevel_Basic" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Basic),
            "k_EGraphicsPerfOverlayLevel_Medium" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Medium),
            "k_EGraphicsPerfOverlayLevel_Full" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Full),
            "k_EGraphicsPerfOverlayLevel_Minimal" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Minimal),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGraphicsPerfOverlayLevel] = &[
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Basic,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Medium,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Full,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Minimal,
    ];
}

impl ::protobuf::EnumFull for EGraphicsPerfOverlayLevel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGraphicsPerfOverlayLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGraphicsPerfOverlayLevel {
    fn default() -> Self {
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden
    }
}

impl EGraphicsPerfOverlayLevel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGraphicsPerfOverlayLevel>("EGraphicsPerfOverlayLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGPUPerformanceLevel)
pub enum EGPUPerformanceLevel {
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Invalid)
    k_EGPUPerformanceLevel_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Auto)
    k_EGPUPerformanceLevel_Auto = 1,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Manual)
    k_EGPUPerformanceLevel_Manual = 2,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Low)
    k_EGPUPerformanceLevel_Low = 3,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_High)
    k_EGPUPerformanceLevel_High = 4,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Profiling)
    k_EGPUPerformanceLevel_Profiling = 5,
}

impl ::protobuf::Enum for EGPUPerformanceLevel {
    const NAME: &'static str = "EGPUPerformanceLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGPUPerformanceLevel> {
        match value {
            0 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            1 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Auto),
            2 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Manual),
            3 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Low),
            4 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_High),
            5 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Profiling),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGPUPerformanceLevel> {
        match str {
            "k_EGPUPerformanceLevel_Invalid" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            "k_EGPUPerformanceLevel_Auto" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Auto),
            "k_EGPUPerformanceLevel_Manual" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Manual),
            "k_EGPUPerformanceLevel_Low" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Low),
            "k_EGPUPerformanceLevel_High" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_High),
            "k_EGPUPerformanceLevel_Profiling" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Profiling),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGPUPerformanceLevel] = &[
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Auto,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Manual,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Low,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_High,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Profiling,
    ];
}

impl ::protobuf::EnumFull for EGPUPerformanceLevel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGPUPerformanceLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGPUPerformanceLevel {
    fn default() -> Self {
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid
    }
}

impl EGPUPerformanceLevel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EGPUPerformanceLevel>("EGPUPerformanceLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EScalingFilter)
pub enum EScalingFilter {
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Invalid)
    k_EScalingFilter_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_FSR)
    k_EScalingFilter_FSR = 1,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Nearest)
    k_EScalingFilter_Nearest = 2,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Integer)
    k_EScalingFilter_Integer = 3,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Linear)
    k_EScalingFilter_Linear = 4,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_NIS)
    k_EScalingFilter_NIS = 5,
}

impl ::protobuf::Enum for EScalingFilter {
    const NAME: &'static str = "EScalingFilter";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EScalingFilter> {
        match value {
            0 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Invalid),
            1 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_FSR),
            2 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Nearest),
            3 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Integer),
            4 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Linear),
            5 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EScalingFilter> {
        match str {
            "k_EScalingFilter_Invalid" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Invalid),
            "k_EScalingFilter_FSR" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_FSR),
            "k_EScalingFilter_Nearest" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Nearest),
            "k_EScalingFilter_Integer" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Integer),
            "k_EScalingFilter_Linear" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Linear),
            "k_EScalingFilter_NIS" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EScalingFilter] = &[
        EScalingFilter::k_EScalingFilter_Invalid,
        EScalingFilter::k_EScalingFilter_FSR,
        EScalingFilter::k_EScalingFilter_Nearest,
        EScalingFilter::k_EScalingFilter_Integer,
        EScalingFilter::k_EScalingFilter_Linear,
        EScalingFilter::k_EScalingFilter_NIS,
    ];
}

impl ::protobuf::EnumFull for EScalingFilter {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EScalingFilter").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EScalingFilter {
    fn default() -> Self {
        EScalingFilter::k_EScalingFilter_Invalid
    }
}

impl EScalingFilter {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EScalingFilter>("EScalingFilter")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECPUGovernor)
pub enum ECPUGovernor {
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Invalid)
    k_ECPUGovernor_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Perf)
    k_ECPUGovernor_Perf = 1,
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Powersave)
    k_ECPUGovernor_Powersave = 2,
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Manual)
    k_ECPUGovernor_Manual = 3,
}

impl ::protobuf::Enum for ECPUGovernor {
    const NAME: &'static str = "ECPUGovernor";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECPUGovernor> {
        match value {
            0 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Invalid),
            1 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Perf),
            2 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Powersave),
            3 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Manual),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECPUGovernor> {
        match str {
            "k_ECPUGovernor_Invalid" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Invalid),
            "k_ECPUGovernor_Perf" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Perf),
            "k_ECPUGovernor_Powersave" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Powersave),
            "k_ECPUGovernor_Manual" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Manual),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECPUGovernor] = &[
        ECPUGovernor::k_ECPUGovernor_Invalid,
        ECPUGovernor::k_ECPUGovernor_Perf,
        ECPUGovernor::k_ECPUGovernor_Powersave,
        ECPUGovernor::k_ECPUGovernor_Manual,
    ];
}

impl ::protobuf::EnumFull for ECPUGovernor {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECPUGovernor").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECPUGovernor {
    fn default() -> Self {
        ECPUGovernor::k_ECPUGovernor_Invalid
    }
}

impl ECPUGovernor {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECPUGovernor>("ECPUGovernor")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUpdaterType)
pub enum EUpdaterType {
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Invalid)
    k_EUpdaterType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Client)
    k_EUpdaterType_Client = 1,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_OS)
    k_EUpdaterType_OS = 2,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_BIOS)
    k_EUpdaterType_BIOS = 3,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Aggregated)
    k_EUpdaterType_Aggregated = 4,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Test1)
    k_EUpdaterType_Test1 = 5,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Test2)
    k_EUpdaterType_Test2 = 6,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Dummy)
    k_EUpdaterType_Dummy = 7,
}

impl ::protobuf::Enum for EUpdaterType {
    const NAME: &'static str = "EUpdaterType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUpdaterType> {
        match value {
            0 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Invalid),
            1 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Client),
            2 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_OS),
            3 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_BIOS),
            4 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Aggregated),
            5 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test1),
            6 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test2),
            7 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Dummy),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUpdaterType> {
        match str {
            "k_EUpdaterType_Invalid" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Invalid),
            "k_EUpdaterType_Client" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Client),
            "k_EUpdaterType_OS" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_OS),
            "k_EUpdaterType_BIOS" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_BIOS),
            "k_EUpdaterType_Aggregated" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Aggregated),
            "k_EUpdaterType_Test1" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test1),
            "k_EUpdaterType_Test2" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test2),
            "k_EUpdaterType_Dummy" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Dummy),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUpdaterType] = &[
        EUpdaterType::k_EUpdaterType_Invalid,
        EUpdaterType::k_EUpdaterType_Client,
        EUpdaterType::k_EUpdaterType_OS,
        EUpdaterType::k_EUpdaterType_BIOS,
        EUpdaterType::k_EUpdaterType_Aggregated,
        EUpdaterType::k_EUpdaterType_Test1,
        EUpdaterType::k_EUpdaterType_Test2,
        EUpdaterType::k_EUpdaterType_Dummy,
    ];
}

impl ::protobuf::EnumFull for EUpdaterType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EUpdaterType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EUpdaterType {
    fn default() -> Self {
        EUpdaterType::k_EUpdaterType_Invalid
    }
}

impl EUpdaterType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EUpdaterType>("EUpdaterType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUpdaterState)
pub enum EUpdaterState {
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Invalid)
    k_EUpdaterState_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_UpToDate)
    k_EUpdaterState_UpToDate = 2,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Checking)
    k_EUpdaterState_Checking = 3,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Available)
    k_EUpdaterState_Available = 4,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Applying)
    k_EUpdaterState_Applying = 5,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_ClientRestartPending)
    k_EUpdaterState_ClientRestartPending = 6,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_SystemRestartPending)
    k_EUpdaterState_SystemRestartPending = 7,
}

impl ::protobuf::Enum for EUpdaterState {
    const NAME: &'static str = "EUpdaterState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUpdaterState> {
        match value {
            0 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Invalid),
            2 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_UpToDate),
            3 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Checking),
            4 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Available),
            5 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Applying),
            6 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_ClientRestartPending),
            7 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_SystemRestartPending),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUpdaterState> {
        match str {
            "k_EUpdaterState_Invalid" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Invalid),
            "k_EUpdaterState_UpToDate" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_UpToDate),
            "k_EUpdaterState_Checking" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Checking),
            "k_EUpdaterState_Available" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Available),
            "k_EUpdaterState_Applying" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Applying),
            "k_EUpdaterState_ClientRestartPending" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_ClientRestartPending),
            "k_EUpdaterState_SystemRestartPending" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_SystemRestartPending),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUpdaterState] = &[
        EUpdaterState::k_EUpdaterState_Invalid,
        EUpdaterState::k_EUpdaterState_UpToDate,
        EUpdaterState::k_EUpdaterState_Checking,
        EUpdaterState::k_EUpdaterState_Available,
        EUpdaterState::k_EUpdaterState_Applying,
        EUpdaterState::k_EUpdaterState_ClientRestartPending,
        EUpdaterState::k_EUpdaterState_SystemRestartPending,
    ];
}

impl ::protobuf::EnumFull for EUpdaterState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EUpdaterState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EUpdaterState::k_EUpdaterState_Invalid => 0,
            EUpdaterState::k_EUpdaterState_UpToDate => 1,
            EUpdaterState::k_EUpdaterState_Checking => 2,
            EUpdaterState::k_EUpdaterState_Available => 3,
            EUpdaterState::k_EUpdaterState_Applying => 4,
            EUpdaterState::k_EUpdaterState_ClientRestartPending => 5,
            EUpdaterState::k_EUpdaterState_SystemRestartPending => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EUpdaterState {
    fn default() -> Self {
        EUpdaterState::k_EUpdaterState_Invalid
    }
}

impl EUpdaterState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EUpdaterState>("EUpdaterState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageBlockContentType)
pub enum EStorageBlockContentType {
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Invalid)
    k_EStorageBlockContentType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Unknown)
    k_EStorageBlockContentType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_FileSystem)
    k_EStorageBlockContentType_FileSystem = 2,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Crypto)
    k_EStorageBlockContentType_Crypto = 3,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Raid)
    k_EStorageBlockContentType_Raid = 4,
}

impl ::protobuf::Enum for EStorageBlockContentType {
    const NAME: &'static str = "EStorageBlockContentType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageBlockContentType> {
        match value {
            0 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
            1 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Unknown),
            2 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_FileSystem),
            3 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Crypto),
            4 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Raid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageBlockContentType> {
        match str {
            "k_EStorageBlockContentType_Invalid" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
            "k_EStorageBlockContentType_Unknown" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Unknown),
            "k_EStorageBlockContentType_FileSystem" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_FileSystem),
            "k_EStorageBlockContentType_Crypto" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Crypto),
            "k_EStorageBlockContentType_Raid" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Raid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageBlockContentType] = &[
        EStorageBlockContentType::k_EStorageBlockContentType_Invalid,
        EStorageBlockContentType::k_EStorageBlockContentType_Unknown,
        EStorageBlockContentType::k_EStorageBlockContentType_FileSystem,
        EStorageBlockContentType::k_EStorageBlockContentType_Crypto,
        EStorageBlockContentType::k_EStorageBlockContentType_Raid,
    ];
}

impl ::protobuf::EnumFull for EStorageBlockContentType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStorageBlockContentType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStorageBlockContentType {
    fn default() -> Self {
        EStorageBlockContentType::k_EStorageBlockContentType_Invalid
    }
}

impl EStorageBlockContentType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStorageBlockContentType>("EStorageBlockContentType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageBlockFileSystemType)
pub enum EStorageBlockFileSystemType {
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_Invalid)
    k_EStorageBlockFileSystemType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_Unknown)
    k_EStorageBlockFileSystemType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_VFat)
    k_EStorageBlockFileSystemType_VFat = 2,
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_Ext4)
    k_EStorageBlockFileSystemType_Ext4 = 3,
}

impl ::protobuf::Enum for EStorageBlockFileSystemType {
    const NAME: &'static str = "EStorageBlockFileSystemType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageBlockFileSystemType> {
        match value {
            0 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
            1 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Unknown),
            2 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_VFat),
            3 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Ext4),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageBlockFileSystemType> {
        match str {
            "k_EStorageBlockFileSystemType_Invalid" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
            "k_EStorageBlockFileSystemType_Unknown" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Unknown),
            "k_EStorageBlockFileSystemType_VFat" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_VFat),
            "k_EStorageBlockFileSystemType_Ext4" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Ext4),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageBlockFileSystemType] = &[
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid,
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Unknown,
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_VFat,
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Ext4,
    ];
}

impl ::protobuf::EnumFull for EStorageBlockFileSystemType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStorageBlockFileSystemType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStorageBlockFileSystemType {
    fn default() -> Self {
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid
    }
}

impl EStorageBlockFileSystemType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EStorageBlockFileSystemType>("EStorageBlockFileSystemType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityCategory)
pub enum ESteamDeckCompatibilityCategory {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Unknown)
    k_ESteamDeckCompatibilityCategory_Unknown = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Unsupported)
    k_ESteamDeckCompatibilityCategory_Unsupported = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Playable)
    k_ESteamDeckCompatibilityCategory_Playable = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Verified)
    k_ESteamDeckCompatibilityCategory_Verified = 3,
}

impl ::protobuf::Enum for ESteamDeckCompatibilityCategory {
    const NAME: &'static str = "ESteamDeckCompatibilityCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityCategory> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unsupported),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Playable),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Verified),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityCategory> {
        match str {
            "k_ESteamDeckCompatibilityCategory_Unknown" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown),
            "k_ESteamDeckCompatibilityCategory_Unsupported" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unsupported),
            "k_ESteamDeckCompatibilityCategory_Playable" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Playable),
            "k_ESteamDeckCompatibilityCategory_Verified" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Verified),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityCategory] = &[
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown,
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unsupported,
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Playable,
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Verified,
    ];
}

impl ::protobuf::EnumFull for ESteamDeckCompatibilityCategory {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamDeckCompatibilityCategory").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamDeckCompatibilityCategory {
    fn default() -> Self {
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown
    }
}

impl ESteamDeckCompatibilityCategory {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamDeckCompatibilityCategory>("ESteamDeckCompatibilityCategory")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityResultDisplayType)
pub enum ESteamDeckCompatibilityResultDisplayType {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Invisible)
    k_ESteamDeckCompatibilityResultDisplayType_Invisible = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Informational)
    k_ESteamDeckCompatibilityResultDisplayType_Informational = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Unsupported)
    k_ESteamDeckCompatibilityResultDisplayType_Unsupported = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Playable)
    k_ESteamDeckCompatibilityResultDisplayType_Playable = 3,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Verified)
    k_ESteamDeckCompatibilityResultDisplayType_Verified = 4,
}

impl ::protobuf::Enum for ESteamDeckCompatibilityResultDisplayType {
    const NAME: &'static str = "ESteamDeckCompatibilityResultDisplayType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityResultDisplayType> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Informational),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Unsupported),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Playable),
            4 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Verified),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityResultDisplayType> {
        match str {
            "k_ESteamDeckCompatibilityResultDisplayType_Invisible" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible),
            "k_ESteamDeckCompatibilityResultDisplayType_Informational" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Informational),
            "k_ESteamDeckCompatibilityResultDisplayType_Unsupported" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Unsupported),
            "k_ESteamDeckCompatibilityResultDisplayType_Playable" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Playable),
            "k_ESteamDeckCompatibilityResultDisplayType_Verified" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Verified),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityResultDisplayType] = &[
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Informational,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Unsupported,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Playable,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Verified,
    ];
}

impl ::protobuf::EnumFull for ESteamDeckCompatibilityResultDisplayType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamDeckCompatibilityResultDisplayType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamDeckCompatibilityResultDisplayType {
    fn default() -> Self {
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible
    }
}

impl ESteamDeckCompatibilityResultDisplayType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamDeckCompatibilityResultDisplayType>("ESteamDeckCompatibilityResultDisplayType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EACState)
pub enum EACState {
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_Unknown)
    k_EACState_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_Disconnected)
    k_EACState_Disconnected = 1,
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_Connected)
    k_EACState_Connected = 2,
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_ConnectedSlow)
    k_EACState_ConnectedSlow = 3,
}

impl ::protobuf::Enum for EACState {
    const NAME: &'static str = "EACState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EACState> {
        match value {
            0 => ::std::option::Option::Some(EACState::k_EACState_Unknown),
            1 => ::std::option::Option::Some(EACState::k_EACState_Disconnected),
            2 => ::std::option::Option::Some(EACState::k_EACState_Connected),
            3 => ::std::option::Option::Some(EACState::k_EACState_ConnectedSlow),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EACState> {
        match str {
            "k_EACState_Unknown" => ::std::option::Option::Some(EACState::k_EACState_Unknown),
            "k_EACState_Disconnected" => ::std::option::Option::Some(EACState::k_EACState_Disconnected),
            "k_EACState_Connected" => ::std::option::Option::Some(EACState::k_EACState_Connected),
            "k_EACState_ConnectedSlow" => ::std::option::Option::Some(EACState::k_EACState_ConnectedSlow),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EACState] = &[
        EACState::k_EACState_Unknown,
        EACState::k_EACState_Disconnected,
        EACState::k_EACState_Connected,
        EACState::k_EACState_ConnectedSlow,
    ];
}

impl ::protobuf::EnumFull for EACState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EACState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EACState {
    fn default() -> Self {
        EACState::k_EACState_Unknown
    }
}

impl EACState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EACState>("EACState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBatteryState)
pub enum EBatteryState {
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Unknown)
    k_EBatteryState_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Discharging)
    k_EBatteryState_Discharging = 1,
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Charging)
    k_EBatteryState_Charging = 2,
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Full)
    k_EBatteryState_Full = 3,
}

impl ::protobuf::Enum for EBatteryState {
    const NAME: &'static str = "EBatteryState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBatteryState> {
        match value {
            0 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Unknown),
            1 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Discharging),
            2 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Charging),
            3 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Full),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBatteryState> {
        match str {
            "k_EBatteryState_Unknown" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Unknown),
            "k_EBatteryState_Discharging" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Discharging),
            "k_EBatteryState_Charging" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Charging),
            "k_EBatteryState_Full" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Full),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBatteryState] = &[
        EBatteryState::k_EBatteryState_Unknown,
        EBatteryState::k_EBatteryState_Discharging,
        EBatteryState::k_EBatteryState_Charging,
        EBatteryState::k_EBatteryState_Full,
    ];
}

impl ::protobuf::EnumFull for EBatteryState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBatteryState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EBatteryState {
    fn default() -> Self {
        EBatteryState::k_EBatteryState_Unknown
    }
}

impl EBatteryState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EBatteryState>("EBatteryState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EOSBranch)
pub enum EOSBranch {
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Unknown)
    k_EOSBranch_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Release)
    k_EOSBranch_Release = 1,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_ReleaseCandidate)
    k_EOSBranch_ReleaseCandidate = 2,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Beta)
    k_EOSBranch_Beta = 3,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_BetaCandidate)
    k_EOSBranch_BetaCandidate = 4,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Main)
    k_EOSBranch_Main = 5,
}

impl ::protobuf::Enum for EOSBranch {
    const NAME: &'static str = "EOSBranch";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOSBranch> {
        match value {
            0 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Unknown),
            1 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Release),
            2 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_ReleaseCandidate),
            3 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Beta),
            4 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_BetaCandidate),
            5 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Main),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOSBranch> {
        match str {
            "k_EOSBranch_Unknown" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Unknown),
            "k_EOSBranch_Release" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Release),
            "k_EOSBranch_ReleaseCandidate" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_ReleaseCandidate),
            "k_EOSBranch_Beta" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Beta),
            "k_EOSBranch_BetaCandidate" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_BetaCandidate),
            "k_EOSBranch_Main" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Main),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOSBranch] = &[
        EOSBranch::k_EOSBranch_Unknown,
        EOSBranch::k_EOSBranch_Release,
        EOSBranch::k_EOSBranch_ReleaseCandidate,
        EOSBranch::k_EOSBranch_Beta,
        EOSBranch::k_EOSBranch_BetaCandidate,
        EOSBranch::k_EOSBranch_Main,
    ];
}

impl ::protobuf::EnumFull for EOSBranch {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EOSBranch").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EOSBranch {
    fn default() -> Self {
        EOSBranch::k_EOSBranch_Unknown
    }
}

impl EOSBranch {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EOSBranch>("EOSBranch")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECommunityItemClass)
pub enum ECommunityItemClass {
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Invalid)
    k_ECommunityItemClass_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Badge)
    k_ECommunityItemClass_Badge = 1,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_GameCard)
    k_ECommunityItemClass_GameCard = 2,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_ProfileBackground)
    k_ECommunityItemClass_ProfileBackground = 3,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Emoticon)
    k_ECommunityItemClass_Emoticon = 4,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_BoosterPack)
    k_ECommunityItemClass_BoosterPack = 5,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Consumable)
    k_ECommunityItemClass_Consumable = 6,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_GameGoo)
    k_ECommunityItemClass_GameGoo = 7,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_ProfileModifier)
    k_ECommunityItemClass_ProfileModifier = 8,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Scene)
    k_ECommunityItemClass_Scene = 9,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_SalienItem)
    k_ECommunityItemClass_SalienItem = 10,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Sticker)
    k_ECommunityItemClass_Sticker = 11,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_ChatEffect)
    k_ECommunityItemClass_ChatEffect = 12,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_MiniProfileBackground)
    k_ECommunityItemClass_MiniProfileBackground = 13,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_AvatarFrame)
    k_ECommunityItemClass_AvatarFrame = 14,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_AnimatedAvatar)
    k_ECommunityItemClass_AnimatedAvatar = 15,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_SteamDeckKeyboardSkin)
    k_ECommunityItemClass_SteamDeckKeyboardSkin = 16,
}

impl ::protobuf::Enum for ECommunityItemClass {
    const NAME: &'static str = "ECommunityItemClass";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECommunityItemClass> {
        match value {
            0 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Invalid),
            1 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Badge),
            2 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameCard),
            3 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileBackground),
            4 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Emoticon),
            5 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_BoosterPack),
            6 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Consumable),
            7 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameGoo),
            8 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileModifier),
            9 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Scene),
            10 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SalienItem),
            11 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Sticker),
            12 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ChatEffect),
            13 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_MiniProfileBackground),
            14 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AvatarFrame),
            15 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AnimatedAvatar),
            16 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckKeyboardSkin),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECommunityItemClass> {
        match str {
            "k_ECommunityItemClass_Invalid" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Invalid),
            "k_ECommunityItemClass_Badge" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Badge),
            "k_ECommunityItemClass_GameCard" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameCard),
            "k_ECommunityItemClass_ProfileBackground" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileBackground),
            "k_ECommunityItemClass_Emoticon" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Emoticon),
            "k_ECommunityItemClass_BoosterPack" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_BoosterPack),
            "k_ECommunityItemClass_Consumable" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Consumable),
            "k_ECommunityItemClass_GameGoo" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameGoo),
            "k_ECommunityItemClass_ProfileModifier" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileModifier),
            "k_ECommunityItemClass_Scene" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Scene),
            "k_ECommunityItemClass_SalienItem" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SalienItem),
            "k_ECommunityItemClass_Sticker" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Sticker),
            "k_ECommunityItemClass_ChatEffect" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ChatEffect),
            "k_ECommunityItemClass_MiniProfileBackground" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_MiniProfileBackground),
            "k_ECommunityItemClass_AvatarFrame" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AvatarFrame),
            "k_ECommunityItemClass_AnimatedAvatar" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AnimatedAvatar),
            "k_ECommunityItemClass_SteamDeckKeyboardSkin" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckKeyboardSkin),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECommunityItemClass] = &[
        ECommunityItemClass::k_ECommunityItemClass_Invalid,
        ECommunityItemClass::k_ECommunityItemClass_Badge,
        ECommunityItemClass::k_ECommunityItemClass_GameCard,
        ECommunityItemClass::k_ECommunityItemClass_ProfileBackground,
        ECommunityItemClass::k_ECommunityItemClass_Emoticon,
        ECommunityItemClass::k_ECommunityItemClass_BoosterPack,
        ECommunityItemClass::k_ECommunityItemClass_Consumable,
        ECommunityItemClass::k_ECommunityItemClass_GameGoo,
        ECommunityItemClass::k_ECommunityItemClass_ProfileModifier,
        ECommunityItemClass::k_ECommunityItemClass_Scene,
        ECommunityItemClass::k_ECommunityItemClass_SalienItem,
        ECommunityItemClass::k_ECommunityItemClass_Sticker,
        ECommunityItemClass::k_ECommunityItemClass_ChatEffect,
        ECommunityItemClass::k_ECommunityItemClass_MiniProfileBackground,
        ECommunityItemClass::k_ECommunityItemClass_AvatarFrame,
        ECommunityItemClass::k_ECommunityItemClass_AnimatedAvatar,
        ECommunityItemClass::k_ECommunityItemClass_SteamDeckKeyboardSkin,
    ];
}

impl ::protobuf::EnumFull for ECommunityItemClass {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECommunityItemClass").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECommunityItemClass {
    fn default() -> Self {
        ECommunityItemClass::k_ECommunityItemClass_Invalid
    }
}

impl ECommunityItemClass {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECommunityItemClass>("ECommunityItemClass")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityFeedback)
pub enum ESteamDeckCompatibilityFeedback {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Unset)
    k_ESteamDeckCompatibilityFeedback_Unset = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Agree)
    k_ESteamDeckCompatibilityFeedback_Agree = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Disagree)
    k_ESteamDeckCompatibilityFeedback_Disagree = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Ignore)
    k_ESteamDeckCompatibilityFeedback_Ignore = 3,
}

impl ::protobuf::Enum for ESteamDeckCompatibilityFeedback {
    const NAME: &'static str = "ESteamDeckCompatibilityFeedback";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityFeedback> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Agree),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Disagree),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Ignore),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityFeedback> {
        match str {
            "k_ESteamDeckCompatibilityFeedback_Unset" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            "k_ESteamDeckCompatibilityFeedback_Agree" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Agree),
            "k_ESteamDeckCompatibilityFeedback_Disagree" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Disagree),
            "k_ESteamDeckCompatibilityFeedback_Ignore" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Ignore),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityFeedback] = &[
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset,
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Agree,
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Disagree,
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Ignore,
    ];
}

impl ::protobuf::EnumFull for ESteamDeckCompatibilityFeedback {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamDeckCompatibilityFeedback").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamDeckCompatibilityFeedback {
    fn default() -> Self {
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset
    }
}

impl ESteamDeckCompatibilityFeedback {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamDeckCompatibilityFeedback>("ESteamDeckCompatibilityFeedback")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProvideDeckFeedbackPreference)
pub enum EProvideDeckFeedbackPreference {
    // @@protoc_insertion_point(enum_value:EProvideDeckFeedbackPreference.k_EProvideDeckFeedbackPreference_Unset)
    k_EProvideDeckFeedbackPreference_Unset = 0,
    // @@protoc_insertion_point(enum_value:EProvideDeckFeedbackPreference.k_EProvideDeckFeedbackPreference_Yes)
    k_EProvideDeckFeedbackPreference_Yes = 1,
    // @@protoc_insertion_point(enum_value:EProvideDeckFeedbackPreference.k_EProvideDeckFeedbackPreference_No)
    k_EProvideDeckFeedbackPreference_No = 2,
}

impl ::protobuf::Enum for EProvideDeckFeedbackPreference {
    const NAME: &'static str = "EProvideDeckFeedbackPreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProvideDeckFeedbackPreference> {
        match value {
            0 => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset),
            1 => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Yes),
            2 => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_No),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProvideDeckFeedbackPreference> {
        match str {
            "k_EProvideDeckFeedbackPreference_Unset" => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset),
            "k_EProvideDeckFeedbackPreference_Yes" => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Yes),
            "k_EProvideDeckFeedbackPreference_No" => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_No),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProvideDeckFeedbackPreference] = &[
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset,
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Yes,
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_No,
    ];
}

impl ::protobuf::EnumFull for EProvideDeckFeedbackPreference {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EProvideDeckFeedbackPreference").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EProvideDeckFeedbackPreference {
    fn default() -> Self {
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset
    }
}

impl EProvideDeckFeedbackPreference {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EProvideDeckFeedbackPreference>("EProvideDeckFeedbackPreference")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETouchGesture)
pub enum ETouchGesture {
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureNone)
    k_ETouchGestureNone = 0,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTouch)
    k_ETouchGestureTouch = 1,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTap)
    k_ETouchGestureTap = 2,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureDoubleTap)
    k_ETouchGestureDoubleTap = 3,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureShortPress)
    k_ETouchGestureShortPress = 4,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureLongPress)
    k_ETouchGestureLongPress = 5,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureLongTap)
    k_ETouchGestureLongTap = 6,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTwoFingerTap)
    k_ETouchGestureTwoFingerTap = 7,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTapCancelled)
    k_ETouchGestureTapCancelled = 8,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGesturePinchBegin)
    k_ETouchGesturePinchBegin = 9,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGesturePinchUpdate)
    k_ETouchGesturePinchUpdate = 10,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGesturePinchEnd)
    k_ETouchGesturePinchEnd = 11,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureFlingStart)
    k_ETouchGestureFlingStart = 12,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureFlingCancelled)
    k_ETouchGestureFlingCancelled = 13,
}

impl ::protobuf::Enum for ETouchGesture {
    const NAME: &'static str = "ETouchGesture";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETouchGesture> {
        match value {
            0 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureNone),
            1 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTouch),
            2 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTap),
            3 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureDoubleTap),
            4 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureShortPress),
            5 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongPress),
            6 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongTap),
            7 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTwoFingerTap),
            8 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTapCancelled),
            9 => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchBegin),
            10 => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchUpdate),
            11 => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchEnd),
            12 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingStart),
            13 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingCancelled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETouchGesture> {
        match str {
            "k_ETouchGestureNone" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureNone),
            "k_ETouchGestureTouch" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTouch),
            "k_ETouchGestureTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTap),
            "k_ETouchGestureDoubleTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureDoubleTap),
            "k_ETouchGestureShortPress" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureShortPress),
            "k_ETouchGestureLongPress" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongPress),
            "k_ETouchGestureLongTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongTap),
            "k_ETouchGestureTwoFingerTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTwoFingerTap),
            "k_ETouchGestureTapCancelled" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTapCancelled),
            "k_ETouchGesturePinchBegin" => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchBegin),
            "k_ETouchGesturePinchUpdate" => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchUpdate),
            "k_ETouchGesturePinchEnd" => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchEnd),
            "k_ETouchGestureFlingStart" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingStart),
            "k_ETouchGestureFlingCancelled" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingCancelled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETouchGesture] = &[
        ETouchGesture::k_ETouchGestureNone,
        ETouchGesture::k_ETouchGestureTouch,
        ETouchGesture::k_ETouchGestureTap,
        ETouchGesture::k_ETouchGestureDoubleTap,
        ETouchGesture::k_ETouchGestureShortPress,
        ETouchGesture::k_ETouchGestureLongPress,
        ETouchGesture::k_ETouchGestureLongTap,
        ETouchGesture::k_ETouchGestureTwoFingerTap,
        ETouchGesture::k_ETouchGestureTapCancelled,
        ETouchGesture::k_ETouchGesturePinchBegin,
        ETouchGesture::k_ETouchGesturePinchUpdate,
        ETouchGesture::k_ETouchGesturePinchEnd,
        ETouchGesture::k_ETouchGestureFlingStart,
        ETouchGesture::k_ETouchGestureFlingCancelled,
    ];
}

impl ::protobuf::EnumFull for ETouchGesture {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETouchGesture").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ETouchGesture {
    fn default() -> Self {
        ETouchGesture::k_ETouchGestureNone
    }
}

impl ETouchGesture {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETouchGesture>("ETouchGesture")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESessionPersistence)
pub enum ESessionPersistence {
    // @@protoc_insertion_point(enum_value:ESessionPersistence.k_ESessionPersistence_Invalid)
    k_ESessionPersistence_Invalid = -1,
    // @@protoc_insertion_point(enum_value:ESessionPersistence.k_ESessionPersistence_Ephemeral)
    k_ESessionPersistence_Ephemeral = 0,
    // @@protoc_insertion_point(enum_value:ESessionPersistence.k_ESessionPersistence_Persistent)
    k_ESessionPersistence_Persistent = 1,
}

impl ::protobuf::Enum for ESessionPersistence {
    const NAME: &'static str = "ESessionPersistence";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESessionPersistence> {
        match value {
            -1 => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Invalid),
            0 => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Ephemeral),
            1 => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Persistent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESessionPersistence> {
        match str {
            "k_ESessionPersistence_Invalid" => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Invalid),
            "k_ESessionPersistence_Ephemeral" => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Ephemeral),
            "k_ESessionPersistence_Persistent" => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Persistent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESessionPersistence] = &[
        ESessionPersistence::k_ESessionPersistence_Invalid,
        ESessionPersistence::k_ESessionPersistence_Ephemeral,
        ESessionPersistence::k_ESessionPersistence_Persistent,
    ];
}

impl ::protobuf::EnumFull for ESessionPersistence {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESessionPersistence").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ESessionPersistence::k_ESessionPersistence_Invalid => 0,
            ESessionPersistence::k_ESessionPersistence_Ephemeral => 1,
            ESessionPersistence::k_ESessionPersistence_Persistent => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ESessionPersistence {
    fn default() -> Self {
        ESessionPersistence::k_ESessionPersistence_Invalid
    }
}

impl ESessionPersistence {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESessionPersistence>("ESessionPersistence")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0benums.proto\x1a\x18steammessages_base.proto*\x80\n\n\x17EPublished\
    FileQueryType\x12)\n%k_PublishedFileQueryType_RankedByVote\x10\0\x124\n0\
    k_PublishedFileQueryType_RankedByPublicationDate\x10\x01\x12B\n>k_Publis\
    hedFileQueryType_AcceptedForGameRankedByAcceptanceDate\x10\x02\x12*\n&k_\
    PublishedFileQueryType_RankedByTrend\x10\x03\x12F\nBk_PublishedFileQuery\
    Type_FavoritedByFriendsRankedByPublicationDate\x10\x04\x12D\n@k_Publishe\
    dFileQueryType_CreatedByFriendsRankedByPublicationDate\x10\x05\x125\n1k_\
    PublishedFileQueryType_RankedByNumTimesReported\x10\x06\x12J\nFk_Publish\
    edFileQueryType_CreatedByFollowedUsersRankedByPublicationDate\x10\x07\
    \x12(\n$k_PublishedFileQueryType_NotYetRated\x10\x08\x12=\n9k_PublishedF\
    ileQueryType_RankedByTotalUniqueSubscriptions\x10\t\x122\n.k_PublishedFi\
    leQueryType_RankedByTotalVotesAsc\x10\n\x12,\n(k_PublishedFileQueryType_\
    RankedByVotesUp\x10\x0b\x12/\n+k_PublishedFileQueryType_RankedByTextSear\
    ch\x10\x0c\x122\n.k_PublishedFileQueryType_RankedByPlaytimeTrend\x10\r\
    \x122\n.k_PublishedFileQueryType_RankedByTotalPlaytime\x10\x0e\x129\n5k_\
    PublishedFileQueryType_RankedByAveragePlaytimeTrend\x10\x0f\x12<\n8k_Pub\
    lishedFileQueryType_RankedByLifetimeAveragePlaytime\x10\x10\x12:\n6k_Pub\
    lishedFileQueryType_RankedByPlaytimeSessionsTrend\x10\x11\x12=\n9k_Publi\
    shedFileQueryType_RankedByLifetimePlaytimeSessions\x10\x12\x12?\n;k_Publ\
    ishedFileQueryType_RankedByInappropriateContentRating\x10\x13\x124\n0k_P\
    ublishedFileQueryType_RankedByBanContentCheck\x10\x14\x124\n0k_Published\
    FileQueryType_RankedByLastUpdatedDate\x10\x15*\xbc\x01\n#EPublishedFileI\
    nappropriateProvider\x121\n-k_EPublishedFileInappropriateProvider_Invali\
    d\x10\0\x120\n,k_EPublishedFileInappropriateProvider_Google\x10\x01\x120\
    \n,k_EPublishedFileInappropriateProvider_Amazon\x10\x02*\xd5\x02\n!EPubl\
    ishedFileInappropriateResult\x122\n.k_EPublishedFileInappropriateResult_\
    NotScanned\x10\0\x124\n0k_EPublishedFileInappropriateResult_VeryUnlikely\
    \x10\x01\x120\n,k_EPublishedFileInappropriateResult_Unlikely\x10\x1e\x12\
    0\n,k_EPublishedFileInappropriateResult_Possible\x102\x12.\n*k_EPublishe\
    dFileInappropriateResult_Likely\x10K\x122\n.k_EPublishedFileInappropriat\
    eResult_VeryLikely\x10d*\xb1\x03\n\x11EPersonaStateFlag\x12'\n#k_EPerson\
    aStateFlag_HasRichPresence\x10\x01\x12&\n\"k_EPersonaStateFlag_InJoinabl\
    eGame\x10\x02\x12\x1e\n\x1ak_EPersonaStateFlag_Golden\x10\x04\x12*\n&k_E\
    PersonaStateFlag_RemotePlayTogether\x10\x08\x12&\n!k_EPersonaStateFlag_C\
    lientTypeWeb\x10\x80\x02\x12)\n$k_EPersonaStateFlag_ClientTypeMobile\x10\
    \x80\x04\x12*\n%k_EPersonaStateFlag_ClientTypeTenfoot\x10\x80\x08\x12%\n\
    \x20k_EPersonaStateFlag_ClientTypeVR\x10\x80\x10\x12*\n%k_EPersonaStateF\
    lag_LaunchTypeGamepad\x10\x80\x20\x12-\n(k_EPersonaStateFlag_LaunchTypeC\
    ompatTool\x10\x80@*\xa7\x01\n\x15EContentCheckProvider\x12#\n\x1fk_ECont\
    entCheckProvider_Invalid\x10\0\x12\"\n\x1ek_EContentCheckProvider_Google\
    \x10\x01\x12\"\n\x1ek_EContentCheckProvider_Amazon\x10\x02\x12!\n\x1dk_E\
    ContentCheckProvider_Local\x10\x03*\xec\x08\n\x19EProfileCustomizationTy\
    pe\x12&\n\"k_EProfileCustomizationTypeInvalid\x10\0\x126\n2k_EProfileCus\
    tomizationTypeRareAchievementShowcase\x10\x01\x12,\n(k_EProfileCustomiza\
    tionTypeGameCollector\x10\x02\x12+\n'k_EProfileCustomizationTypeItemShow\
    case\x10\x03\x12,\n(k_EProfileCustomizationTypeTradeShowcase\x10\x04\x12\
    %\n!k_EProfileCustomizationTypeBadges\x10\x05\x12+\n'k_EProfileCustomiza\
    tionTypeFavoriteGame\x10\x06\x121\n-k_EProfileCustomizationTypeScreensho\
    tShowcase\x10\x07\x12)\n%k_EProfileCustomizationTypeCustomText\x10\x08\
    \x12,\n(k_EProfileCustomizationTypeFavoriteGroup\x10\t\x12-\n)k_EProfile\
    CustomizationTypeRecommendation\x10\n\x12+\n'k_EProfileCustomizationType\
    WorkshopItem\x10\x0b\x12)\n%k_EProfileCustomizationTypeMyWorkshop\x10\
    \x0c\x12.\n*k_EProfileCustomizationTypeArtworkShowcase\x10\r\x12,\n(k_EP\
    rofileCustomizationTypeVideoShowcase\x10\x0e\x12%\n!k_EProfileCustomizat\
    ionTypeGuides\x10\x0f\x12'\n#k_EProfileCustomizationTypeMyGuides\x10\x10\
    \x12+\n'k_EProfileCustomizationTypeAchievements\x10\x11\x12)\n%k_EProfil\
    eCustomizationTypeGreenlight\x10\x12\x12+\n'k_EProfileCustomizationTypeM\
    yGreenlight\x10\x13\x12%\n!k_EProfileCustomizationTypeSalien\x10\x14\x12\
    5\n1k_EProfileCustomizationTypeLoyaltyRewardReactions\x10\x15\x124\n0k_E\
    ProfileCustomizationTypeSingleArtworkShowcase\x10\x16\x128\n4k_EProfileC\
    ustomizationTypeAchievementsCompletionist\x10\x17*\xc8\x01\n\x1bEPublish\
    edFileStorageSystem\x12(\n$k_EPublishedFileStorageSystemInvalid\x10\0\
    \x12,\n(k_EPublishedFileStorageSystemLegacyCloud\x10\x01\x12&\n\"k_EPubl\
    ishedFileStorageSystemDepot\x10\x02\x12)\n%k_EPublishedFileStorageSystem\
    UGCCloud\x10\x03*\x97\x01\n\x19ECloudStoragePersistState\x12(\n$k_ECloud\
    StoragePersistStatePersisted\x10\0\x12(\n$k_ECloudStoragePersistStateFor\
    gotten\x10\x01\x12&\n\"k_ECloudStoragePersistStateDeleted\x10\x02*\xe8\
    \x01\n\x12ESDCardFormatStage\x12\x20\n\x1ck_ESDCardFormatStage_Invalid\
    \x10\0\x12!\n\x1dk_ESDCardFormatStage_Starting\x10\x01\x12\x20\n\x1ck_ES\
    DCardFormatStage_Testing\x10\x02\x12!\n\x1dk_ESDCardFormatStage_Rescuing\
    \x10\x03\x12#\n\x1fk_ESDCardFormatStage_Formatting\x10\x04\x12#\n\x1fk_E\
    SDCardFormatStage_Finalizing\x10\x05*\x84\x01\n\x15ESystemFanControlMode\
    \x12\"\n\x1ek_SystemFanControlMode_Invalid\x10\0\x12#\n\x1fk_SystemFanCo\
    ntrolMode_Disabled\x10\x01\x12\"\n\x1ek_SystemFanControlMode_Default\x10\
    \x02*\x81\x01\n\rEColorProfile\x12\x1b\n\x17k_EColorProfile_Invalid\x10\
    \0\x12\x1a\n\x16k_EColorProfile_Native\x10\x01\x12\x1c\n\x18k_EColorProf\
    ile_Standard\x10\x02\x12\x19\n\x15k_EColorProfile_Vivid\x10\x03*\xc0\x03\
    \n\x14EBluetoothDeviceType\x12!\n\x1dk_BluetoothDeviceType_Invalid\x10\0\
    \x12!\n\x1dk_BluetoothDeviceType_Unknown\x10\x01\x12\x1f\n\x1bk_Bluetoot\
    hDeviceType_Phone\x10\x02\x12\"\n\x1ek_BluetoothDeviceType_Computer\x10\
    \x03\x12!\n\x1dk_BluetoothDeviceType_Headset\x10\x04\x12$\n\x20k_Bluetoo\
    thDeviceType_Headphones\x10\x05\x12\"\n\x1ek_BluetoothDeviceType_Speaker\
    s\x10\x06\x12$\n\x20k_BluetoothDeviceType_OtherAudio\x10\x07\x12\x1f\n\
    \x1bk_BluetoothDeviceType_Mouse\x10\x08\x12\"\n\x1ek_BluetoothDeviceType\
    _Joystick\x10\t\x12!\n\x1dk_BluetoothDeviceType_Gamepad\x10\n\x12\"\n\
    \x1ek_BluetoothDeviceType_Keyboard\x10\x0b*\x80\x01\n\x15ESystemAudioDir\
    ection\x12\"\n\x1ek_SystemAudioDirection_Invalid\x10\0\x12\x20\n\x1ck_Sy\
    stemAudioDirection_Input\x10\x01\x12!\n\x1dk_SystemAudioDirection_Output\
    \x10\x02*\xf1\x02\n\x13ESystemAudioChannel\x12\x20\n\x1ck_SystemAudioCha\
    nnel_Invalid\x10\0\x12#\n\x1fk_SystemAudioChannel_Aggregated\x10\x01\x12\
    \"\n\x1ek_SystemAudioChannel_FrontLeft\x10\x02\x12#\n\x1fk_SystemAudioCh\
    annel_FrontRight\x10\x03\x12\x1c\n\x18k_SystemAudioChannel_LFE\x10\x04\
    \x12!\n\x1dk_SystemAudioChannel_BackLeft\x10\x05\x12\"\n\x1ek_SystemAudi\
    oChannel_BackRight\x10\x06\x12$\n\x20k_SystemAudioChannel_FrontCenter\
    \x10\x07\x12\x20\n\x1ck_SystemAudioChannel_Unknown\x10\x08\x12\x1d\n\x19\
    k_SystemAudioChannel_Mono\x10\t*\xc9\x01\n\x14ESystemAudioPortType\x12!\
    \n\x1dk_SystemAudioPortType_Invalid\x10\0\x12!\n\x1dk_SystemAudioPortTyp\
    e_Unknown\x10\x01\x12\"\n\x1ek_SystemAudioPortType_Audio32f\x10\x02\x12\
    \x20\n\x1ck_SystemAudioPortType_Midi8b\x10\x03\x12%\n!k_SystemAudioPortT\
    ype_Video32RGBA\x10\x04*\x90\x01\n\x19ESystemAudioPortDirection\x12&\n\"\
    k_SystemAudioPortDirection_Invalid\x10\0\x12$\n\x20k_SystemAudioPortDire\
    ction_Input\x10\x01\x12%\n!k_SystemAudioPortDirection_Output\x10\x02*\
    \x83\x01\n\x13ESystemServiceState\x12%\n!k_ESystemServiceState_Unavailab\
    le\x10\0\x12\"\n\x1ek_ESystemServiceState_Disabled\x10\x01\x12!\n\x1dk_E\
    SystemServiceState_Enabled\x10\x02*\xe1\x01\n\x19EGraphicsPerfOverlayLev\
    el\x12&\n\"k_EGraphicsPerfOverlayLevel_Hidden\x10\0\x12%\n!k_EGraphicsPe\
    rfOverlayLevel_Basic\x10\x01\x12&\n\"k_EGraphicsPerfOverlayLevel_Medium\
    \x10\x02\x12$\n\x20k_EGraphicsPerfOverlayLevel_Full\x10\x03\x12'\n#k_EGr\
    aphicsPerfOverlayLevel_Minimal\x10\x04*\xe5\x01\n\x14EGPUPerformanceLeve\
    l\x12\"\n\x1ek_EGPUPerformanceLevel_Invalid\x10\0\x12\x1f\n\x1bk_EGPUPer\
    formanceLevel_Auto\x10\x01\x12!\n\x1dk_EGPUPerformanceLevel_Manual\x10\
    \x02\x12\x1e\n\x1ak_EGPUPerformanceLevel_Low\x10\x03\x12\x1f\n\x1bk_EGPU\
    PerformanceLevel_High\x10\x04\x12$\n\x20k_EGPUPerformanceLevel_Profiling\
    \x10\x05*\xbb\x01\n\x0eEScalingFilter\x12\x1c\n\x18k_EScalingFilter_Inva\
    lid\x10\0\x12\x18\n\x14k_EScalingFilter_FSR\x10\x01\x12\x1c\n\x18k_EScal\
    ingFilter_Nearest\x10\x02\x12\x1c\n\x18k_EScalingFilter_Integer\x10\x03\
    \x12\x1b\n\x17k_EScalingFilter_Linear\x10\x04\x12\x18\n\x14k_EScalingFil\
    ter_NIS\x10\x05*|\n\x0cECPUGovernor\x12\x1a\n\x16k_ECPUGovernor_Invalid\
    \x10\0\x12\x17\n\x13k_ECPUGovernor_Perf\x10\x01\x12\x1c\n\x18k_ECPUGover\
    nor_Powersave\x10\x02\x12\x19\n\x15k_ECPUGovernor_Manual\x10\x03*\xe2\
    \x01\n\x0cEUpdaterType\x12\x1a\n\x16k_EUpdaterType_Invalid\x10\0\x12\x19\
    \n\x15k_EUpdaterType_Client\x10\x01\x12\x15\n\x11k_EUpdaterType_OS\x10\
    \x02\x12\x17\n\x13k_EUpdaterType_BIOS\x10\x03\x12\x1d\n\x19k_EUpdaterTyp\
    e_Aggregated\x10\x04\x12\x18\n\x14k_EUpdaterType_Test1\x10\x05\x12\x18\n\
    \x14k_EUpdaterType_Test2\x10\x06\x12\x18\n\x14k_EUpdaterType_Dummy\x10\
    \x07*\xf9\x01\n\rEUpdaterState\x12\x1b\n\x17k_EUpdaterState_Invalid\x10\
    \0\x12\x1c\n\x18k_EUpdaterState_UpToDate\x10\x02\x12\x1c\n\x18k_EUpdater\
    State_Checking\x10\x03\x12\x1d\n\x19k_EUpdaterState_Available\x10\x04\
    \x12\x1c\n\x18k_EUpdaterState_Applying\x10\x05\x12(\n$k_EUpdaterState_Cl\
    ientRestartPending\x10\x06\x12(\n$k_EUpdaterState_SystemRestartPending\
    \x10\x07*\xe1\x01\n\x18EStorageBlockContentType\x12&\n\"k_EStorageBlockC\
    ontentType_Invalid\x10\0\x12&\n\"k_EStorageBlockContentType_Unknown\x10\
    \x01\x12)\n%k_EStorageBlockContentType_FileSystem\x10\x02\x12%\n!k_EStor\
    ageBlockContentType_Crypto\x10\x03\x12#\n\x1fk_EStorageBlockContentType_\
    Raid\x10\x04*\xc3\x01\n\x1bEStorageBlockFileSystemType\x12)\n%k_EStorage\
    BlockFileSystemType_Invalid\x10\0\x12)\n%k_EStorageBlockFileSystemType_U\
    nknown\x10\x01\x12&\n\"k_EStorageBlockFileSystemType_VFat\x10\x02\x12&\n\
    \"k_EStorageBlockFileSystemType_Ext4\x10\x03*\xe3\x01\n\x1fESteamDeckCom\
    patibilityCategory\x12-\n)k_ESteamDeckCompatibilityCategory_Unknown\x10\
    \0\x121\n-k_ESteamDeckCompatibilityCategory_Unsupported\x10\x01\x12.\n*k\
    _ESteamDeckCompatibilityCategory_Playable\x10\x02\x12.\n*k_ESteamDeckCom\
    patibilityCategory_Verified\x10\x03*\xd0\x02\n(ESteamDeckCompatibilityRe\
    sultDisplayType\x128\n4k_ESteamDeckCompatibilityResultDisplayType_Invisi\
    ble\x10\0\x12<\n8k_ESteamDeckCompatibilityResultDisplayType_Informationa\
    l\x10\x01\x12:\n6k_ESteamDeckCompatibilityResultDisplayType_Unsupported\
    \x10\x02\x127\n3k_ESteamDeckCompatibilityResultDisplayType_Playable\x10\
    \x03\x127\n3k_ESteamDeckCompatibilityResultDisplayType_Verified\x10\x04*\
    w\n\x08EACState\x12\x16\n\x12k_EACState_Unknown\x10\0\x12\x1b\n\x17k_EAC\
    State_Disconnected\x10\x01\x12\x18\n\x14k_EACState_Connected\x10\x02\x12\
    \x1c\n\x18k_EACState_ConnectedSlow\x10\x03*\x85\x01\n\rEBatteryState\x12\
    \x1b\n\x17k_EBatteryState_Unknown\x10\0\x12\x1f\n\x1bk_EBatteryState_Dis\
    charging\x10\x01\x12\x1c\n\x18k_EBatteryState_Charging\x10\x02\x12\x18\n\
    \x14k_EBatteryState_Full\x10\x03*\xaa\x01\n\tEOSBranch\x12\x17\n\x13k_EO\
    SBranch_Unknown\x10\0\x12\x17\n\x13k_EOSBranch_Release\x10\x01\x12\x20\n\
    \x1ck_EOSBranch_ReleaseCandidate\x10\x02\x12\x14\n\x10k_EOSBranch_Beta\
    \x10\x03\x12\x1d\n\x19k_EOSBranch_BetaCandidate\x10\x04\x12\x14\n\x10k_E\
    OSBranch_Main\x10\x05*\xac\x05\n\x13ECommunityItemClass\x12!\n\x1dk_ECom\
    munityItemClass_Invalid\x10\0\x12\x1f\n\x1bk_ECommunityItemClass_Badge\
    \x10\x01\x12\"\n\x1ek_ECommunityItemClass_GameCard\x10\x02\x12+\n'k_ECom\
    munityItemClass_ProfileBackground\x10\x03\x12\"\n\x1ek_ECommunityItemCla\
    ss_Emoticon\x10\x04\x12%\n!k_ECommunityItemClass_BoosterPack\x10\x05\x12\
    $\n\x20k_ECommunityItemClass_Consumable\x10\x06\x12!\n\x1dk_ECommunityIt\
    emClass_GameGoo\x10\x07\x12)\n%k_ECommunityItemClass_ProfileModifier\x10\
    \x08\x12\x1f\n\x1bk_ECommunityItemClass_Scene\x10\t\x12$\n\x20k_ECommuni\
    tyItemClass_SalienItem\x10\n\x12!\n\x1dk_ECommunityItemClass_Sticker\x10\
    \x0b\x12$\n\x20k_ECommunityItemClass_ChatEffect\x10\x0c\x12/\n+k_ECommun\
    ityItemClass_MiniProfileBackground\x10\r\x12%\n!k_ECommunityItemClass_Av\
    atarFrame\x10\x0e\x12(\n$k_ECommunityItemClass_AnimatedAvatar\x10\x0f\
    \x12/\n+k_ECommunityItemClass_SteamDeckKeyboardSkin\x10\x10*\xd9\x01\n\
    \x1fESteamDeckCompatibilityFeedback\x12+\n'k_ESteamDeckCompatibilityFeed\
    back_Unset\x10\0\x12+\n'k_ESteamDeckCompatibilityFeedback_Agree\x10\x01\
    \x12.\n*k_ESteamDeckCompatibilityFeedback_Disagree\x10\x02\x12,\n(k_ESte\
    amDeckCompatibilityFeedback_Ignore\x10\x03*\x9f\x01\n\x1eEProvideDeckFee\
    dbackPreference\x12*\n&k_EProvideDeckFeedbackPreference_Unset\x10\0\x12(\
    \n$k_EProvideDeckFeedbackPreference_Yes\x10\x01\x12'\n#k_EProvideDeckFee\
    dbackPreference_No\x10\x02*\xb1\x03\n\rETouchGesture\x12\x17\n\x13k_ETou\
    chGestureNone\x10\0\x12\x18\n\x14k_ETouchGestureTouch\x10\x01\x12\x16\n\
    \x12k_ETouchGestureTap\x10\x02\x12\x1c\n\x18k_ETouchGestureDoubleTap\x10\
    \x03\x12\x1d\n\x19k_ETouchGestureShortPress\x10\x04\x12\x1c\n\x18k_ETouc\
    hGestureLongPress\x10\x05\x12\x1a\n\x16k_ETouchGestureLongTap\x10\x06\
    \x12\x1f\n\x1bk_ETouchGestureTwoFingerTap\x10\x07\x12\x1f\n\x1bk_ETouchG\
    estureTapCancelled\x10\x08\x12\x1d\n\x19k_ETouchGesturePinchBegin\x10\t\
    \x12\x1e\n\x1ak_ETouchGesturePinchUpdate\x10\n\x12\x1b\n\x17k_ETouchGest\
    urePinchEnd\x10\x0b\x12\x1d\n\x19k_ETouchGestureFlingStart\x10\x0c\x12!\
    \n\x1dk_ETouchGestureFlingCancelled\x10\r*\x8c\x01\n\x13ESessionPersiste\
    nce\x12*\n\x1dk_ESessionPersistence_Invalid\x10\xff\xff\xff\xff\xff\xff\
    \xff\xff\xff\x01\x12#\n\x1fk_ESessionPersistence_Ephemeral\x10\0\x12$\n\
    \x20k_ESessionPersistence_Persistent\x10\x01B\tH\x01\x80\x01\x01\x80\xb5\
    \x18\x01J\x92V\n\x07\x12\x05\0\0\xd7\x02\x01\n\t\n\x02\x03\0\x12\x03\0\0\
    \"\n\x08\n\x01\x08\x12\x03\x02\0\x1c\n\t\n\x02\x08\t\x12\x03\x02\0\x1c\n\
    \x08\n\x01\x08\x12\x03\x03\0\"\n\t\n\x02\x08\x10\x12\x03\x03\0\"\n\x08\n\
    \x01\x08\x12\x03\x04\0%\n\x0b\n\x04\x08\xd0\x86\x03\x12\x03\x04\0%\n\n\n\
    \x02\x05\0\x12\x04\x06\0\x1d\x01\n\n\n\x03\x05\0\x01\x12\x03\x06\x05\x1c\
    \n\x0b\n\x04\x05\0\x02\0\x12\x03\x07\x082\n\x0c\n\x05\x05\0\x02\0\x01\
    \x12\x03\x07\x08-\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x0701\n\x0b\n\x04\
    \x05\0\x02\x01\x12\x03\x08\x08=\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\
    \x08\x088\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x08;<\n\x0b\n\x04\x05\0\
    \x02\x02\x12\x03\t\x08K\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\t\x08F\n\
    \x0c\n\x05\x05\0\x02\x02\x02\x12\x03\tIJ\n\x0b\n\x04\x05\0\x02\x03\x12\
    \x03\n\x083\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\n\x08.\n\x0c\n\x05\x05\
    \0\x02\x03\x02\x12\x03\n12\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x0b\x08O\n\
    \x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x0b\x08J\n\x0c\n\x05\x05\0\x02\x04\
    \x02\x12\x03\x0bMN\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x0c\x08M\n\x0c\n\
    \x05\x05\0\x02\x05\x01\x12\x03\x0c\x08H\n\x0c\n\x05\x05\0\x02\x05\x02\
    \x12\x03\x0cKL\n\x0b\n\x04\x05\0\x02\x06\x12\x03\r\x08>\n\x0c\n\x05\x05\
    \0\x02\x06\x01\x12\x03\r\x089\n\x0c\n\x05\x05\0\x02\x06\x02\x12\x03\r<=\
    \n\x0b\n\x04\x05\0\x02\x07\x12\x03\x0e\x08S\n\x0c\n\x05\x05\0\x02\x07\
    \x01\x12\x03\x0e\x08N\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x0eQR\n\x0b\
    \n\x04\x05\0\x02\x08\x12\x03\x0f\x081\n\x0c\n\x05\x05\0\x02\x08\x01\x12\
    \x03\x0f\x08,\n\x0c\n\x05\x05\0\x02\x08\x02\x12\x03\x0f/0\n\x0b\n\x04\
    \x05\0\x02\t\x12\x03\x10\x08F\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x10\
    \x08A\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x10DE\n\x0b\n\x04\x05\0\x02\n\
    \x12\x03\x11\x08<\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\x11\x086\n\x0c\n\
    \x05\x05\0\x02\n\x02\x12\x03\x119;\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\x12\
    \x086\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x12\x080\n\x0c\n\x05\x05\0\
    \x02\x0b\x02\x12\x03\x1235\n\x0b\n\x04\x05\0\x02\x0c\x12\x03\x13\x089\n\
    \x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x13\x083\n\x0c\n\x05\x05\0\x02\x0c\
    \x02\x12\x03\x1368\n\x0b\n\x04\x05\0\x02\r\x12\x03\x14\x08<\n\x0c\n\x05\
    \x05\0\x02\r\x01\x12\x03\x14\x086\n\x0c\n\x05\x05\0\x02\r\x02\x12\x03\
    \x149;\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x15\x08<\n\x0c\n\x05\x05\0\x02\
    \x0e\x01\x12\x03\x15\x086\n\x0c\n\x05\x05\0\x02\x0e\x02\x12\x03\x159;\n\
    \x0b\n\x04\x05\0\x02\x0f\x12\x03\x16\x08C\n\x0c\n\x05\x05\0\x02\x0f\x01\
    \x12\x03\x16\x08=\n\x0c\n\x05\x05\0\x02\x0f\x02\x12\x03\x16@B\n\x0b\n\
    \x04\x05\0\x02\x10\x12\x03\x17\x08F\n\x0c\n\x05\x05\0\x02\x10\x01\x12\
    \x03\x17\x08@\n\x0c\n\x05\x05\0\x02\x10\x02\x12\x03\x17CE\n\x0b\n\x04\
    \x05\0\x02\x11\x12\x03\x18\x08D\n\x0c\n\x05\x05\0\x02\x11\x01\x12\x03\
    \x18\x08>\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x18AC\n\x0b\n\x04\x05\0\
    \x02\x12\x12\x03\x19\x08G\n\x0c\n\x05\x05\0\x02\x12\x01\x12\x03\x19\x08A\
    \n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\x19DF\n\x0b\n\x04\x05\0\x02\x13\
    \x12\x03\x1a\x08I\n\x0c\n\x05\x05\0\x02\x13\x01\x12\x03\x1a\x08C\n\x0c\n\
    \x05\x05\0\x02\x13\x02\x12\x03\x1aFH\n\x0b\n\x04\x05\0\x02\x14\x12\x03\
    \x1b\x08>\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\x1b\x088\n\x0c\n\x05\x05\
    \0\x02\x14\x02\x12\x03\x1b;=\n\x0b\n\x04\x05\0\x02\x15\x12\x03\x1c\x08>\
    \n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\x1c\x088\n\x0c\n\x05\x05\0\x02\
    \x15\x02\x12\x03\x1c;=\n\n\n\x02\x05\x01\x12\x04\x1f\0#\x01\n\n\n\x03\
    \x05\x01\x01\x12\x03\x1f\x05(\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x20\x08:\
    \n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x20\x085\n\x0c\n\x05\x05\x01\x02\
    \0\x02\x12\x03\x2089\n\x0b\n\x04\x05\x01\x02\x01\x12\x03!\x089\n\x0c\n\
    \x05\x05\x01\x02\x01\x01\x12\x03!\x084\n\x0c\n\x05\x05\x01\x02\x01\x02\
    \x12\x03!78\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\"\x089\n\x0c\n\x05\x05\
    \x01\x02\x02\x01\x12\x03\"\x084\n\x0c\n\x05\x05\x01\x02\x02\x02\x12\x03\
    \"78\n\n\n\x02\x05\x02\x12\x04%\0,\x01\n\n\n\x03\x05\x02\x01\x12\x03%\
    \x05&\n\x0b\n\x04\x05\x02\x02\0\x12\x03&\x08;\n\x0c\n\x05\x05\x02\x02\0\
    \x01\x12\x03&\x086\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03&9:\n\x0b\n\x04\
    \x05\x02\x02\x01\x12\x03'\x08=\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03'\
    \x088\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03';<\n\x0b\n\x04\x05\x02\x02\
    \x02\x12\x03(\x08:\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03(\x084\n\x0c\n\
    \x05\x05\x02\x02\x02\x02\x12\x03(79\n\x0b\n\x04\x05\x02\x02\x03\x12\x03)\
    \x08:\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03)\x084\n\x0c\n\x05\x05\x02\
    \x02\x03\x02\x12\x03)79\n\x0b\n\x04\x05\x02\x02\x04\x12\x03*\x088\n\x0c\
    \n\x05\x05\x02\x02\x04\x01\x12\x03*\x082\n\x0c\n\x05\x05\x02\x02\x04\x02\
    \x12\x03*57\n\x0b\n\x04\x05\x02\x02\x05\x12\x03+\x08=\n\x0c\n\x05\x05\
    \x02\x02\x05\x01\x12\x03+\x086\n\x0c\n\x05\x05\x02\x02\x05\x02\x12\x03+9\
    <\n\n\n\x02\x05\x03\x12\x04.\09\x01\n\n\n\x03\x05\x03\x01\x12\x03.\x05\
    \x16\n\x0b\n\x04\x05\x03\x02\0\x12\x03/\x080\n\x0c\n\x05\x05\x03\x02\0\
    \x01\x12\x03/\x08+\n\x0c\n\x05\x05\x03\x02\0\x02\x12\x03/./\n\x0b\n\x04\
    \x05\x03\x02\x01\x12\x030\x08/\n\x0c\n\x05\x05\x03\x02\x01\x01\x12\x030\
    \x08*\n\x0c\n\x05\x05\x03\x02\x01\x02\x12\x030-.\n\x0b\n\x04\x05\x03\x02\
    \x02\x12\x031\x08'\n\x0c\n\x05\x05\x03\x02\x02\x01\x12\x031\x08\"\n\x0c\
    \n\x05\x05\x03\x02\x02\x02\x12\x031%&\n\x0b\n\x04\x05\x03\x02\x03\x12\
    \x032\x083\n\x0c\n\x05\x05\x03\x02\x03\x01\x12\x032\x08.\n\x0c\n\x05\x05\
    \x03\x02\x03\x02\x12\x03212\n\x0b\n\x04\x05\x03\x02\x04\x12\x033\x080\n\
    \x0c\n\x05\x05\x03\x02\x04\x01\x12\x033\x08)\n\x0c\n\x05\x05\x03\x02\x04\
    \x02\x12\x033,/\n\x0b\n\x04\x05\x03\x02\x05\x12\x034\x083\n\x0c\n\x05\
    \x05\x03\x02\x05\x01\x12\x034\x08,\n\x0c\n\x05\x05\x03\x02\x05\x02\x12\
    \x034/2\n\x0b\n\x04\x05\x03\x02\x06\x12\x035\x085\n\x0c\n\x05\x05\x03\
    \x02\x06\x01\x12\x035\x08-\n\x0c\n\x05\x05\x03\x02\x06\x02\x12\x03504\n\
    \x0b\n\x04\x05\x03\x02\x07\x12\x036\x080\n\x0c\n\x05\x05\x03\x02\x07\x01\
    \x12\x036\x08(\n\x0c\n\x05\x05\x03\x02\x07\x02\x12\x036+/\n\x0b\n\x04\
    \x05\x03\x02\x08\x12\x037\x085\n\x0c\n\x05\x05\x03\x02\x08\x01\x12\x037\
    \x08-\n\x0c\n\x05\x05\x03\x02\x08\x02\x12\x03704\n\x0b\n\x04\x05\x03\x02\
    \t\x12\x038\x088\n\x0c\n\x05\x05\x03\x02\t\x01\x12\x038\x080\n\x0c\n\x05\
    \x05\x03\x02\t\x02\x12\x03837\n\n\n\x02\x05\x04\x12\x04;\0@\x01\n\n\n\
    \x03\x05\x04\x01\x12\x03;\x05\x1a\n\x0b\n\x04\x05\x04\x02\0\x12\x03<\x08\
    ,\n\x0c\n\x05\x05\x04\x02\0\x01\x12\x03<\x08'\n\x0c\n\x05\x05\x04\x02\0\
    \x02\x12\x03<*+\n\x0b\n\x04\x05\x04\x02\x01\x12\x03=\x08+\n\x0c\n\x05\
    \x05\x04\x02\x01\x01\x12\x03=\x08&\n\x0c\n\x05\x05\x04\x02\x01\x02\x12\
    \x03=)*\n\x0b\n\x04\x05\x04\x02\x02\x12\x03>\x08+\n\x0c\n\x05\x05\x04\
    \x02\x02\x01\x12\x03>\x08&\n\x0c\n\x05\x05\x04\x02\x02\x02\x12\x03>)*\n\
    \x0b\n\x04\x05\x04\x02\x03\x12\x03?\x08*\n\x0c\n\x05\x05\x04\x02\x03\x01\
    \x12\x03?\x08%\n\x0c\n\x05\x05\x04\x02\x03\x02\x12\x03?()\n\n\n\x02\x05\
    \x05\x12\x04B\0[\x01\n\n\n\x03\x05\x05\x01\x12\x03B\x05\x1e\n\x0b\n\x04\
    \x05\x05\x02\0\x12\x03C\x08/\n\x0c\n\x05\x05\x05\x02\0\x01\x12\x03C\x08*\
    \n\x0c\n\x05\x05\x05\x02\0\x02\x12\x03C-.\n\x0b\n\x04\x05\x05\x02\x01\
    \x12\x03D\x08?\n\x0c\n\x05\x05\x05\x02\x01\x01\x12\x03D\x08:\n\x0c\n\x05\
    \x05\x05\x02\x01\x02\x12\x03D=>\n\x0b\n\x04\x05\x05\x02\x02\x12\x03E\x08\
    5\n\x0c\n\x05\x05\x05\x02\x02\x01\x12\x03E\x080\n\x0c\n\x05\x05\x05\x02\
    \x02\x02\x12\x03E34\n\x0b\n\x04\x05\x05\x02\x03\x12\x03F\x084\n\x0c\n\
    \x05\x05\x05\x02\x03\x01\x12\x03F\x08/\n\x0c\n\x05\x05\x05\x02\x03\x02\
    \x12\x03F23\n\x0b\n\x04\x05\x05\x02\x04\x12\x03G\x085\n\x0c\n\x05\x05\
    \x05\x02\x04\x01\x12\x03G\x080\n\x0c\n\x05\x05\x05\x02\x04\x02\x12\x03G3\
    4\n\x0b\n\x04\x05\x05\x02\x05\x12\x03H\x08.\n\x0c\n\x05\x05\x05\x02\x05\
    \x01\x12\x03H\x08)\n\x0c\n\x05\x05\x05\x02\x05\x02\x12\x03H,-\n\x0b\n\
    \x04\x05\x05\x02\x06\x12\x03I\x084\n\x0c\n\x05\x05\x05\x02\x06\x01\x12\
    \x03I\x08/\n\x0c\n\x05\x05\x05\x02\x06\x02\x12\x03I23\n\x0b\n\x04\x05\
    \x05\x02\x07\x12\x03J\x08:\n\x0c\n\x05\x05\x05\x02\x07\x01\x12\x03J\x085\
    \n\x0c\n\x05\x05\x05\x02\x07\x02\x12\x03J89\n\x0b\n\x04\x05\x05\x02\x08\
    \x12\x03K\x082\n\x0c\n\x05\x05\x05\x02\x08\x01\x12\x03K\x08-\n\x0c\n\x05\
    \x05\x05\x02\x08\x02\x12\x03K01\n\x0b\n\x04\x05\x05\x02\t\x12\x03L\x085\
    \n\x0c\n\x05\x05\x05\x02\t\x01\x12\x03L\x080\n\x0c\n\x05\x05\x05\x02\t\
    \x02\x12\x03L34\n\x0b\n\x04\x05\x05\x02\n\x12\x03M\x087\n\x0c\n\x05\x05\
    \x05\x02\n\x01\x12\x03M\x081\n\x0c\n\x05\x05\x05\x02\n\x02\x12\x03M46\n\
    \x0b\n\x04\x05\x05\x02\x0b\x12\x03N\x085\n\x0c\n\x05\x05\x05\x02\x0b\x01\
    \x12\x03N\x08/\n\x0c\n\x05\x05\x05\x02\x0b\x02\x12\x03N24\n\x0b\n\x04\
    \x05\x05\x02\x0c\x12\x03O\x083\n\x0c\n\x05\x05\x05\x02\x0c\x01\x12\x03O\
    \x08-\n\x0c\n\x05\x05\x05\x02\x0c\x02\x12\x03O02\n\x0b\n\x04\x05\x05\x02\
    \r\x12\x03P\x088\n\x0c\n\x05\x05\x05\x02\r\x01\x12\x03P\x082\n\x0c\n\x05\
    \x05\x05\x02\r\x02\x12\x03P57\n\x0b\n\x04\x05\x05\x02\x0e\x12\x03Q\x086\
    \n\x0c\n\x05\x05\x05\x02\x0e\x01\x12\x03Q\x080\n\x0c\n\x05\x05\x05\x02\
    \x0e\x02\x12\x03Q35\n\x0b\n\x04\x05\x05\x02\x0f\x12\x03R\x08/\n\x0c\n\
    \x05\x05\x05\x02\x0f\x01\x12\x03R\x08)\n\x0c\n\x05\x05\x05\x02\x0f\x02\
    \x12\x03R,.\n\x0b\n\x04\x05\x05\x02\x10\x12\x03S\x081\n\x0c\n\x05\x05\
    \x05\x02\x10\x01\x12\x03S\x08+\n\x0c\n\x05\x05\x05\x02\x10\x02\x12\x03S.\
    0\n\x0b\n\x04\x05\x05\x02\x11\x12\x03T\x085\n\x0c\n\x05\x05\x05\x02\x11\
    \x01\x12\x03T\x08/\n\x0c\n\x05\x05\x05\x02\x11\x02\x12\x03T24\n\x0b\n\
    \x04\x05\x05\x02\x12\x12\x03U\x083\n\x0c\n\x05\x05\x05\x02\x12\x01\x12\
    \x03U\x08-\n\x0c\n\x05\x05\x05\x02\x12\x02\x12\x03U02\n\x0b\n\x04\x05\
    \x05\x02\x13\x12\x03V\x085\n\x0c\n\x05\x05\x05\x02\x13\x01\x12\x03V\x08/\
    \n\x0c\n\x05\x05\x05\x02\x13\x02\x12\x03V24\n\x0b\n\x04\x05\x05\x02\x14\
    \x12\x03W\x08/\n\x0c\n\x05\x05\x05\x02\x14\x01\x12\x03W\x08)\n\x0c\n\x05\
    \x05\x05\x02\x14\x02\x12\x03W,.\n\x0b\n\x04\x05\x05\x02\x15\x12\x03X\x08\
    ?\n\x0c\n\x05\x05\x05\x02\x15\x01\x12\x03X\x089\n\x0c\n\x05\x05\x05\x02\
    \x15\x02\x12\x03X<>\n\x0b\n\x04\x05\x05\x02\x16\x12\x03Y\x08>\n\x0c\n\
    \x05\x05\x05\x02\x16\x01\x12\x03Y\x088\n\x0c\n\x05\x05\x05\x02\x16\x02\
    \x12\x03Y;=\n\x0b\n\x04\x05\x05\x02\x17\x12\x03Z\x08B\n\x0c\n\x05\x05\
    \x05\x02\x17\x01\x12\x03Z\x08<\n\x0c\n\x05\x05\x05\x02\x17\x02\x12\x03Z?\
    A\n\n\n\x02\x05\x06\x12\x04]\0b\x01\n\n\n\x03\x05\x06\x01\x12\x03]\x05\
    \x20\n\x0b\n\x04\x05\x06\x02\0\x12\x03^\x081\n\x0c\n\x05\x05\x06\x02\0\
    \x01\x12\x03^\x08,\n\x0c\n\x05\x05\x06\x02\0\x02\x12\x03^/0\n\x0b\n\x04\
    \x05\x06\x02\x01\x12\x03_\x085\n\x0c\n\x05\x05\x06\x02\x01\x01\x12\x03_\
    \x080\n\x0c\n\x05\x05\x06\x02\x01\x02\x12\x03_34\n\x0b\n\x04\x05\x06\x02\
    \x02\x12\x03`\x08/\n\x0c\n\x05\x05\x06\x02\x02\x01\x12\x03`\x08*\n\x0c\n\
    \x05\x05\x06\x02\x02\x02\x12\x03`-.\n\x0b\n\x04\x05\x06\x02\x03\x12\x03a\
    \x082\n\x0c\n\x05\x05\x06\x02\x03\x01\x12\x03a\x08-\n\x0c\n\x05\x05\x06\
    \x02\x03\x02\x12\x03a01\n\n\n\x02\x05\x07\x12\x04d\0h\x01\n\n\n\x03\x05\
    \x07\x01\x12\x03d\x05\x1e\n\x0b\n\x04\x05\x07\x02\0\x12\x03e\x081\n\x0c\
    \n\x05\x05\x07\x02\0\x01\x12\x03e\x08,\n\x0c\n\x05\x05\x07\x02\0\x02\x12\
    \x03e/0\n\x0b\n\x04\x05\x07\x02\x01\x12\x03f\x081\n\x0c\n\x05\x05\x07\
    \x02\x01\x01\x12\x03f\x08,\n\x0c\n\x05\x05\x07\x02\x01\x02\x12\x03f/0\n\
    \x0b\n\x04\x05\x07\x02\x02\x12\x03g\x08/\n\x0c\n\x05\x05\x07\x02\x02\x01\
    \x12\x03g\x08*\n\x0c\n\x05\x05\x07\x02\x02\x02\x12\x03g-.\n\n\n\x02\x05\
    \x08\x12\x04j\0q\x01\n\n\n\x03\x05\x08\x01\x12\x03j\x05\x17\n\x0b\n\x04\
    \x05\x08\x02\0\x12\x03k\x08)\n\x0c\n\x05\x05\x08\x02\0\x01\x12\x03k\x08$\
    \n\x0c\n\x05\x05\x08\x02\0\x02\x12\x03k'(\n\x0b\n\x04\x05\x08\x02\x01\
    \x12\x03l\x08*\n\x0c\n\x05\x05\x08\x02\x01\x01\x12\x03l\x08%\n\x0c\n\x05\
    \x05\x08\x02\x01\x02\x12\x03l()\n\x0b\n\x04\x05\x08\x02\x02\x12\x03m\x08\
    )\n\x0c\n\x05\x05\x08\x02\x02\x01\x12\x03m\x08$\n\x0c\n\x05\x05\x08\x02\
    \x02\x02\x12\x03m'(\n\x0b\n\x04\x05\x08\x02\x03\x12\x03n\x08*\n\x0c\n\
    \x05\x05\x08\x02\x03\x01\x12\x03n\x08%\n\x0c\n\x05\x05\x08\x02\x03\x02\
    \x12\x03n()\n\x0b\n\x04\x05\x08\x02\x04\x12\x03o\x08,\n\x0c\n\x05\x05\
    \x08\x02\x04\x01\x12\x03o\x08'\n\x0c\n\x05\x05\x08\x02\x04\x02\x12\x03o*\
    +\n\x0b\n\x04\x05\x08\x02\x05\x12\x03p\x08,\n\x0c\n\x05\x05\x08\x02\x05\
    \x01\x12\x03p\x08'\n\x0c\n\x05\x05\x08\x02\x05\x02\x12\x03p*+\n\n\n\x02\
    \x05\t\x12\x04s\0w\x01\n\n\n\x03\x05\t\x01\x12\x03s\x05\x1a\n\x0b\n\x04\
    \x05\t\x02\0\x12\x03t\x08+\n\x0c\n\x05\x05\t\x02\0\x01\x12\x03t\x08&\n\
    \x0c\n\x05\x05\t\x02\0\x02\x12\x03t)*\n\x0b\n\x04\x05\t\x02\x01\x12\x03u\
    \x08,\n\x0c\n\x05\x05\t\x02\x01\x01\x12\x03u\x08'\n\x0c\n\x05\x05\t\x02\
    \x01\x02\x12\x03u*+\n\x0b\n\x04\x05\t\x02\x02\x12\x03v\x08+\n\x0c\n\x05\
    \x05\t\x02\x02\x01\x12\x03v\x08&\n\x0c\n\x05\x05\t\x02\x02\x02\x12\x03v)\
    *\n\n\n\x02\x05\n\x12\x04y\0~\x01\n\n\n\x03\x05\n\x01\x12\x03y\x05\x12\n\
    \x0b\n\x04\x05\n\x02\0\x12\x03z\x08$\n\x0c\n\x05\x05\n\x02\0\x01\x12\x03\
    z\x08\x1f\n\x0c\n\x05\x05\n\x02\0\x02\x12\x03z\"#\n\x0b\n\x04\x05\n\x02\
    \x01\x12\x03{\x08#\n\x0c\n\x05\x05\n\x02\x01\x01\x12\x03{\x08\x1e\n\x0c\
    \n\x05\x05\n\x02\x01\x02\x12\x03{!\"\n\x0b\n\x04\x05\n\x02\x02\x12\x03|\
    \x08%\n\x0c\n\x05\x05\n\x02\x02\x01\x12\x03|\x08\x20\n\x0c\n\x05\x05\n\
    \x02\x02\x02\x12\x03|#$\n\x0b\n\x04\x05\n\x02\x03\x12\x03}\x08\"\n\x0c\n\
    \x05\x05\n\x02\x03\x01\x12\x03}\x08\x1d\n\x0c\n\x05\x05\n\x02\x03\x02\
    \x12\x03}\x20!\n\x0c\n\x02\x05\x0b\x12\x06\x80\x01\0\x8d\x01\x01\n\x0b\n\
    \x03\x05\x0b\x01\x12\x04\x80\x01\x05\x19\n\x0c\n\x04\x05\x0b\x02\0\x12\
    \x04\x81\x01\x08*\n\r\n\x05\x05\x0b\x02\0\x01\x12\x04\x81\x01\x08%\n\r\n\
    \x05\x05\x0b\x02\0\x02\x12\x04\x81\x01()\n\x0c\n\x04\x05\x0b\x02\x01\x12\
    \x04\x82\x01\x08*\n\r\n\x05\x05\x0b\x02\x01\x01\x12\x04\x82\x01\x08%\n\r\
    \n\x05\x05\x0b\x02\x01\x02\x12\x04\x82\x01()\n\x0c\n\x04\x05\x0b\x02\x02\
    \x12\x04\x83\x01\x08(\n\r\n\x05\x05\x0b\x02\x02\x01\x12\x04\x83\x01\x08#\
    \n\r\n\x05\x05\x0b\x02\x02\x02\x12\x04\x83\x01&'\n\x0c\n\x04\x05\x0b\x02\
    \x03\x12\x04\x84\x01\x08+\n\r\n\x05\x05\x0b\x02\x03\x01\x12\x04\x84\x01\
    \x08&\n\r\n\x05\x05\x0b\x02\x03\x02\x12\x04\x84\x01)*\n\x0c\n\x04\x05\
    \x0b\x02\x04\x12\x04\x85\x01\x08*\n\r\n\x05\x05\x0b\x02\x04\x01\x12\x04\
    \x85\x01\x08%\n\r\n\x05\x05\x0b\x02\x04\x02\x12\x04\x85\x01()\n\x0c\n\
    \x04\x05\x0b\x02\x05\x12\x04\x86\x01\x08-\n\r\n\x05\x05\x0b\x02\x05\x01\
    \x12\x04\x86\x01\x08(\n\r\n\x05\x05\x0b\x02\x05\x02\x12\x04\x86\x01+,\n\
    \x0c\n\x04\x05\x0b\x02\x06\x12\x04\x87\x01\x08+\n\r\n\x05\x05\x0b\x02\
    \x06\x01\x12\x04\x87\x01\x08&\n\r\n\x05\x05\x0b\x02\x06\x02\x12\x04\x87\
    \x01)*\n\x0c\n\x04\x05\x0b\x02\x07\x12\x04\x88\x01\x08-\n\r\n\x05\x05\
    \x0b\x02\x07\x01\x12\x04\x88\x01\x08(\n\r\n\x05\x05\x0b\x02\x07\x02\x12\
    \x04\x88\x01+,\n\x0c\n\x04\x05\x0b\x02\x08\x12\x04\x89\x01\x08(\n\r\n\
    \x05\x05\x0b\x02\x08\x01\x12\x04\x89\x01\x08#\n\r\n\x05\x05\x0b\x02\x08\
    \x02\x12\x04\x89\x01&'\n\x0c\n\x04\x05\x0b\x02\t\x12\x04\x8a\x01\x08+\n\
    \r\n\x05\x05\x0b\x02\t\x01\x12\x04\x8a\x01\x08&\n\r\n\x05\x05\x0b\x02\t\
    \x02\x12\x04\x8a\x01)*\n\x0c\n\x04\x05\x0b\x02\n\x12\x04\x8b\x01\x08+\n\
    \r\n\x05\x05\x0b\x02\n\x01\x12\x04\x8b\x01\x08%\n\r\n\x05\x05\x0b\x02\n\
    \x02\x12\x04\x8b\x01(*\n\x0c\n\x04\x05\x0b\x02\x0b\x12\x04\x8c\x01\x08,\
    \n\r\n\x05\x05\x0b\x02\x0b\x01\x12\x04\x8c\x01\x08&\n\r\n\x05\x05\x0b\
    \x02\x0b\x02\x12\x04\x8c\x01)+\n\x0c\n\x02\x05\x0c\x12\x06\x8f\x01\0\x93\
    \x01\x01\n\x0b\n\x03\x05\x0c\x01\x12\x04\x8f\x01\x05\x1a\n\x0c\n\x04\x05\
    \x0c\x02\0\x12\x04\x90\x01\x08+\n\r\n\x05\x05\x0c\x02\0\x01\x12\x04\x90\
    \x01\x08&\n\r\n\x05\x05\x0c\x02\0\x02\x12\x04\x90\x01)*\n\x0c\n\x04\x05\
    \x0c\x02\x01\x12\x04\x91\x01\x08)\n\r\n\x05\x05\x0c\x02\x01\x01\x12\x04\
    \x91\x01\x08$\n\r\n\x05\x05\x0c\x02\x01\x02\x12\x04\x91\x01'(\n\x0c\n\
    \x04\x05\x0c\x02\x02\x12\x04\x92\x01\x08*\n\r\n\x05\x05\x0c\x02\x02\x01\
    \x12\x04\x92\x01\x08%\n\r\n\x05\x05\x0c\x02\x02\x02\x12\x04\x92\x01()\n\
    \x0c\n\x02\x05\r\x12\x06\x95\x01\0\xa0\x01\x01\n\x0b\n\x03\x05\r\x01\x12\
    \x04\x95\x01\x05\x18\n\x0c\n\x04\x05\r\x02\0\x12\x04\x96\x01\x08)\n\r\n\
    \x05\x05\r\x02\0\x01\x12\x04\x96\x01\x08$\n\r\n\x05\x05\r\x02\0\x02\x12\
    \x04\x96\x01'(\n\x0c\n\x04\x05\r\x02\x01\x12\x04\x97\x01\x08,\n\r\n\x05\
    \x05\r\x02\x01\x01\x12\x04\x97\x01\x08'\n\r\n\x05\x05\r\x02\x01\x02\x12\
    \x04\x97\x01*+\n\x0c\n\x04\x05\r\x02\x02\x12\x04\x98\x01\x08+\n\r\n\x05\
    \x05\r\x02\x02\x01\x12\x04\x98\x01\x08&\n\r\n\x05\x05\r\x02\x02\x02\x12\
    \x04\x98\x01)*\n\x0c\n\x04\x05\r\x02\x03\x12\x04\x99\x01\x08,\n\r\n\x05\
    \x05\r\x02\x03\x01\x12\x04\x99\x01\x08'\n\r\n\x05\x05\r\x02\x03\x02\x12\
    \x04\x99\x01*+\n\x0c\n\x04\x05\r\x02\x04\x12\x04\x9a\x01\x08%\n\r\n\x05\
    \x05\r\x02\x04\x01\x12\x04\x9a\x01\x08\x20\n\r\n\x05\x05\r\x02\x04\x02\
    \x12\x04\x9a\x01#$\n\x0c\n\x04\x05\r\x02\x05\x12\x04\x9b\x01\x08*\n\r\n\
    \x05\x05\r\x02\x05\x01\x12\x04\x9b\x01\x08%\n\r\n\x05\x05\r\x02\x05\x02\
    \x12\x04\x9b\x01()\n\x0c\n\x04\x05\r\x02\x06\x12\x04\x9c\x01\x08+\n\r\n\
    \x05\x05\r\x02\x06\x01\x12\x04\x9c\x01\x08&\n\r\n\x05\x05\r\x02\x06\x02\
    \x12\x04\x9c\x01)*\n\x0c\n\x04\x05\r\x02\x07\x12\x04\x9d\x01\x08-\n\r\n\
    \x05\x05\r\x02\x07\x01\x12\x04\x9d\x01\x08(\n\r\n\x05\x05\r\x02\x07\x02\
    \x12\x04\x9d\x01+,\n\x0c\n\x04\x05\r\x02\x08\x12\x04\x9e\x01\x08)\n\r\n\
    \x05\x05\r\x02\x08\x01\x12\x04\x9e\x01\x08$\n\r\n\x05\x05\r\x02\x08\x02\
    \x12\x04\x9e\x01'(\n\x0c\n\x04\x05\r\x02\t\x12\x04\x9f\x01\x08&\n\r\n\
    \x05\x05\r\x02\t\x01\x12\x04\x9f\x01\x08!\n\r\n\x05\x05\r\x02\t\x02\x12\
    \x04\x9f\x01$%\n\x0c\n\x02\x05\x0e\x12\x06\xa2\x01\0\xa8\x01\x01\n\x0b\n\
    \x03\x05\x0e\x01\x12\x04\xa2\x01\x05\x19\n\x0c\n\x04\x05\x0e\x02\0\x12\
    \x04\xa3\x01\x08*\n\r\n\x05\x05\x0e\x02\0\x01\x12\x04\xa3\x01\x08%\n\r\n\
    \x05\x05\x0e\x02\0\x02\x12\x04\xa3\x01()\n\x0c\n\x04\x05\x0e\x02\x01\x12\
    \x04\xa4\x01\x08*\n\r\n\x05\x05\x0e\x02\x01\x01\x12\x04\xa4\x01\x08%\n\r\
    \n\x05\x05\x0e\x02\x01\x02\x12\x04\xa4\x01()\n\x0c\n\x04\x05\x0e\x02\x02\
    \x12\x04\xa5\x01\x08+\n\r\n\x05\x05\x0e\x02\x02\x01\x12\x04\xa5\x01\x08&\
    \n\r\n\x05\x05\x0e\x02\x02\x02\x12\x04\xa5\x01)*\n\x0c\n\x04\x05\x0e\x02\
    \x03\x12\x04\xa6\x01\x08)\n\r\n\x05\x05\x0e\x02\x03\x01\x12\x04\xa6\x01\
    \x08$\n\r\n\x05\x05\x0e\x02\x03\x02\x12\x04\xa6\x01'(\n\x0c\n\x04\x05\
    \x0e\x02\x04\x12\x04\xa7\x01\x08.\n\r\n\x05\x05\x0e\x02\x04\x01\x12\x04\
    \xa7\x01\x08)\n\r\n\x05\x05\x0e\x02\x04\x02\x12\x04\xa7\x01,-\n\x0c\n\
    \x02\x05\x0f\x12\x06\xaa\x01\0\xae\x01\x01\n\x0b\n\x03\x05\x0f\x01\x12\
    \x04\xaa\x01\x05\x1e\n\x0c\n\x04\x05\x0f\x02\0\x12\x04\xab\x01\x08/\n\r\
    \n\x05\x05\x0f\x02\0\x01\x12\x04\xab\x01\x08*\n\r\n\x05\x05\x0f\x02\0\
    \x02\x12\x04\xab\x01-.\n\x0c\n\x04\x05\x0f\x02\x01\x12\x04\xac\x01\x08-\
    \n\r\n\x05\x05\x0f\x02\x01\x01\x12\x04\xac\x01\x08(\n\r\n\x05\x05\x0f\
    \x02\x01\x02\x12\x04\xac\x01+,\n\x0c\n\x04\x05\x0f\x02\x02\x12\x04\xad\
    \x01\x08.\n\r\n\x05\x05\x0f\x02\x02\x01\x12\x04\xad\x01\x08)\n\r\n\x05\
    \x05\x0f\x02\x02\x02\x12\x04\xad\x01,-\n\x0c\n\x02\x05\x10\x12\x06\xb0\
    \x01\0\xb4\x01\x01\n\x0b\n\x03\x05\x10\x01\x12\x04\xb0\x01\x05\x18\n\x0c\
    \n\x04\x05\x10\x02\0\x12\x04\xb1\x01\x08.\n\r\n\x05\x05\x10\x02\0\x01\
    \x12\x04\xb1\x01\x08)\n\r\n\x05\x05\x10\x02\0\x02\x12\x04\xb1\x01,-\n\
    \x0c\n\x04\x05\x10\x02\x01\x12\x04\xb2\x01\x08+\n\r\n\x05\x05\x10\x02\
    \x01\x01\x12\x04\xb2\x01\x08&\n\r\n\x05\x05\x10\x02\x01\x02\x12\x04\xb2\
    \x01)*\n\x0c\n\x04\x05\x10\x02\x02\x12\x04\xb3\x01\x08*\n\r\n\x05\x05\
    \x10\x02\x02\x01\x12\x04\xb3\x01\x08%\n\r\n\x05\x05\x10\x02\x02\x02\x12\
    \x04\xb3\x01()\n\x0c\n\x02\x05\x11\x12\x06\xb6\x01\0\xbc\x01\x01\n\x0b\n\
    \x03\x05\x11\x01\x12\x04\xb6\x01\x05\x1e\n\x0c\n\x04\x05\x11\x02\0\x12\
    \x04\xb7\x01\x08/\n\r\n\x05\x05\x11\x02\0\x01\x12\x04\xb7\x01\x08*\n\r\n\
    \x05\x05\x11\x02\0\x02\x12\x04\xb7\x01-.\n\x0c\n\x04\x05\x11\x02\x01\x12\
    \x04\xb8\x01\x08.\n\r\n\x05\x05\x11\x02\x01\x01\x12\x04\xb8\x01\x08)\n\r\
    \n\x05\x05\x11\x02\x01\x02\x12\x04\xb8\x01,-\n\x0c\n\x04\x05\x11\x02\x02\
    \x12\x04\xb9\x01\x08/\n\r\n\x05\x05\x11\x02\x02\x01\x12\x04\xb9\x01\x08*\
    \n\r\n\x05\x05\x11\x02\x02\x02\x12\x04\xb9\x01-.\n\x0c\n\x04\x05\x11\x02\
    \x03\x12\x04\xba\x01\x08-\n\r\n\x05\x05\x11\x02\x03\x01\x12\x04\xba\x01\
    \x08(\n\r\n\x05\x05\x11\x02\x03\x02\x12\x04\xba\x01+,\n\x0c\n\x04\x05\
    \x11\x02\x04\x12\x04\xbb\x01\x080\n\r\n\x05\x05\x11\x02\x04\x01\x12\x04\
    \xbb\x01\x08+\n\r\n\x05\x05\x11\x02\x04\x02\x12\x04\xbb\x01./\n\x0c\n\
    \x02\x05\x12\x12\x06\xbe\x01\0\xc5\x01\x01\n\x0b\n\x03\x05\x12\x01\x12\
    \x04\xbe\x01\x05\x19\n\x0c\n\x04\x05\x12\x02\0\x12\x04\xbf\x01\x08+\n\r\
    \n\x05\x05\x12\x02\0\x01\x12\x04\xbf\x01\x08&\n\r\n\x05\x05\x12\x02\0\
    \x02\x12\x04\xbf\x01)*\n\x0c\n\x04\x05\x12\x02\x01\x12\x04\xc0\x01\x08(\
    \n\r\n\x05\x05\x12\x02\x01\x01\x12\x04\xc0\x01\x08#\n\r\n\x05\x05\x12\
    \x02\x01\x02\x12\x04\xc0\x01&'\n\x0c\n\x04\x05\x12\x02\x02\x12\x04\xc1\
    \x01\x08*\n\r\n\x05\x05\x12\x02\x02\x01\x12\x04\xc1\x01\x08%\n\r\n\x05\
    \x05\x12\x02\x02\x02\x12\x04\xc1\x01()\n\x0c\n\x04\x05\x12\x02\x03\x12\
    \x04\xc2\x01\x08'\n\r\n\x05\x05\x12\x02\x03\x01\x12\x04\xc2\x01\x08\"\n\
    \r\n\x05\x05\x12\x02\x03\x02\x12\x04\xc2\x01%&\n\x0c\n\x04\x05\x12\x02\
    \x04\x12\x04\xc3\x01\x08(\n\r\n\x05\x05\x12\x02\x04\x01\x12\x04\xc3\x01\
    \x08#\n\r\n\x05\x05\x12\x02\x04\x02\x12\x04\xc3\x01&'\n\x0c\n\x04\x05\
    \x12\x02\x05\x12\x04\xc4\x01\x08-\n\r\n\x05\x05\x12\x02\x05\x01\x12\x04\
    \xc4\x01\x08(\n\r\n\x05\x05\x12\x02\x05\x02\x12\x04\xc4\x01+,\n\x0c\n\
    \x02\x05\x13\x12\x06\xc7\x01\0\xce\x01\x01\n\x0b\n\x03\x05\x13\x01\x12\
    \x04\xc7\x01\x05\x13\n\x0c\n\x04\x05\x13\x02\0\x12\x04\xc8\x01\x08%\n\r\
    \n\x05\x05\x13\x02\0\x01\x12\x04\xc8\x01\x08\x20\n\r\n\x05\x05\x13\x02\0\
    \x02\x12\x04\xc8\x01#$\n\x0c\n\x04\x05\x13\x02\x01\x12\x04\xc9\x01\x08!\
    \n\r\n\x05\x05\x13\x02\x01\x01\x12\x04\xc9\x01\x08\x1c\n\r\n\x05\x05\x13\
    \x02\x01\x02\x12\x04\xc9\x01\x1f\x20\n\x0c\n\x04\x05\x13\x02\x02\x12\x04\
    \xca\x01\x08%\n\r\n\x05\x05\x13\x02\x02\x01\x12\x04\xca\x01\x08\x20\n\r\
    \n\x05\x05\x13\x02\x02\x02\x12\x04\xca\x01#$\n\x0c\n\x04\x05\x13\x02\x03\
    \x12\x04\xcb\x01\x08%\n\r\n\x05\x05\x13\x02\x03\x01\x12\x04\xcb\x01\x08\
    \x20\n\r\n\x05\x05\x13\x02\x03\x02\x12\x04\xcb\x01#$\n\x0c\n\x04\x05\x13\
    \x02\x04\x12\x04\xcc\x01\x08$\n\r\n\x05\x05\x13\x02\x04\x01\x12\x04\xcc\
    \x01\x08\x1f\n\r\n\x05\x05\x13\x02\x04\x02\x12\x04\xcc\x01\"#\n\x0c\n\
    \x04\x05\x13\x02\x05\x12\x04\xcd\x01\x08!\n\r\n\x05\x05\x13\x02\x05\x01\
    \x12\x04\xcd\x01\x08\x1c\n\r\n\x05\x05\x13\x02\x05\x02\x12\x04\xcd\x01\
    \x1f\x20\n\x0c\n\x02\x05\x14\x12\x06\xd0\x01\0\xd5\x01\x01\n\x0b\n\x03\
    \x05\x14\x01\x12\x04\xd0\x01\x05\x11\n\x0c\n\x04\x05\x14\x02\0\x12\x04\
    \xd1\x01\x08#\n\r\n\x05\x05\x14\x02\0\x01\x12\x04\xd1\x01\x08\x1e\n\r\n\
    \x05\x05\x14\x02\0\x02\x12\x04\xd1\x01!\"\n\x0c\n\x04\x05\x14\x02\x01\
    \x12\x04\xd2\x01\x08\x20\n\r\n\x05\x05\x14\x02\x01\x01\x12\x04\xd2\x01\
    \x08\x1b\n\r\n\x05\x05\x14\x02\x01\x02\x12\x04\xd2\x01\x1e\x1f\n\x0c\n\
    \x04\x05\x14\x02\x02\x12\x04\xd3\x01\x08%\n\r\n\x05\x05\x14\x02\x02\x01\
    \x12\x04\xd3\x01\x08\x20\n\r\n\x05\x05\x14\x02\x02\x02\x12\x04\xd3\x01#$\
    \n\x0c\n\x04\x05\x14\x02\x03\x12\x04\xd4\x01\x08\"\n\r\n\x05\x05\x14\x02\
    \x03\x01\x12\x04\xd4\x01\x08\x1d\n\r\n\x05\x05\x14\x02\x03\x02\x12\x04\
    \xd4\x01\x20!\n\x0c\n\x02\x05\x15\x12\x06\xd7\x01\0\xe0\x01\x01\n\x0b\n\
    \x03\x05\x15\x01\x12\x04\xd7\x01\x05\x11\n\x0c\n\x04\x05\x15\x02\0\x12\
    \x04\xd8\x01\x08#\n\r\n\x05\x05\x15\x02\0\x01\x12\x04\xd8\x01\x08\x1e\n\
    \r\n\x05\x05\x15\x02\0\x02\x12\x04\xd8\x01!\"\n\x0c\n\x04\x05\x15\x02\
    \x01\x12\x04\xd9\x01\x08\"\n\r\n\x05\x05\x15\x02\x01\x01\x12\x04\xd9\x01\
    \x08\x1d\n\r\n\x05\x05\x15\x02\x01\x02\x12\x04\xd9\x01\x20!\n\x0c\n\x04\
    \x05\x15\x02\x02\x12\x04\xda\x01\x08\x1e\n\r\n\x05\x05\x15\x02\x02\x01\
    \x12\x04\xda\x01\x08\x19\n\r\n\x05\x05\x15\x02\x02\x02\x12\x04\xda\x01\
    \x1c\x1d\n\x0c\n\x04\x05\x15\x02\x03\x12\x04\xdb\x01\x08\x20\n\r\n\x05\
    \x05\x15\x02\x03\x01\x12\x04\xdb\x01\x08\x1b\n\r\n\x05\x05\x15\x02\x03\
    \x02\x12\x04\xdb\x01\x1e\x1f\n\x0c\n\x04\x05\x15\x02\x04\x12\x04\xdc\x01\
    \x08&\n\r\n\x05\x05\x15\x02\x04\x01\x12\x04\xdc\x01\x08!\n\r\n\x05\x05\
    \x15\x02\x04\x02\x12\x04\xdc\x01$%\n\x0c\n\x04\x05\x15\x02\x05\x12\x04\
    \xdd\x01\x08!\n\r\n\x05\x05\x15\x02\x05\x01\x12\x04\xdd\x01\x08\x1c\n\r\
    \n\x05\x05\x15\x02\x05\x02\x12\x04\xdd\x01\x1f\x20\n\x0c\n\x04\x05\x15\
    \x02\x06\x12\x04\xde\x01\x08!\n\r\n\x05\x05\x15\x02\x06\x01\x12\x04\xde\
    \x01\x08\x1c\n\r\n\x05\x05\x15\x02\x06\x02\x12\x04\xde\x01\x1f\x20\n\x0c\
    \n\x04\x05\x15\x02\x07\x12\x04\xdf\x01\x08!\n\r\n\x05\x05\x15\x02\x07\
    \x01\x12\x04\xdf\x01\x08\x1c\n\r\n\x05\x05\x15\x02\x07\x02\x12\x04\xdf\
    \x01\x1f\x20\n\x0c\n\x02\x05\x16\x12\x06\xe2\x01\0\xea\x01\x01\n\x0b\n\
    \x03\x05\x16\x01\x12\x04\xe2\x01\x05\x12\n\x0c\n\x04\x05\x16\x02\0\x12\
    \x04\xe3\x01\x08$\n\r\n\x05\x05\x16\x02\0\x01\x12\x04\xe3\x01\x08\x1f\n\
    \r\n\x05\x05\x16\x02\0\x02\x12\x04\xe3\x01\"#\n\x0c\n\x04\x05\x16\x02\
    \x01\x12\x04\xe4\x01\x08%\n\r\n\x05\x05\x16\x02\x01\x01\x12\x04\xe4\x01\
    \x08\x20\n\r\n\x05\x05\x16\x02\x01\x02\x12\x04\xe4\x01#$\n\x0c\n\x04\x05\
    \x16\x02\x02\x12\x04\xe5\x01\x08%\n\r\n\x05\x05\x16\x02\x02\x01\x12\x04\
    \xe5\x01\x08\x20\n\r\n\x05\x05\x16\x02\x02\x02\x12\x04\xe5\x01#$\n\x0c\n\
    \x04\x05\x16\x02\x03\x12\x04\xe6\x01\x08&\n\r\n\x05\x05\x16\x02\x03\x01\
    \x12\x04\xe6\x01\x08!\n\r\n\x05\x05\x16\x02\x03\x02\x12\x04\xe6\x01$%\n\
    \x0c\n\x04\x05\x16\x02\x04\x12\x04\xe7\x01\x08%\n\r\n\x05\x05\x16\x02\
    \x04\x01\x12\x04\xe7\x01\x08\x20\n\r\n\x05\x05\x16\x02\x04\x02\x12\x04\
    \xe7\x01#$\n\x0c\n\x04\x05\x16\x02\x05\x12\x04\xe8\x01\x081\n\r\n\x05\
    \x05\x16\x02\x05\x01\x12\x04\xe8\x01\x08,\n\r\n\x05\x05\x16\x02\x05\x02\
    \x12\x04\xe8\x01/0\n\x0c\n\x04\x05\x16\x02\x06\x12\x04\xe9\x01\x081\n\r\
    \n\x05\x05\x16\x02\x06\x01\x12\x04\xe9\x01\x08,\n\r\n\x05\x05\x16\x02\
    \x06\x02\x12\x04\xe9\x01/0\n\x0c\n\x02\x05\x17\x12\x06\xec\x01\0\xf2\x01\
    \x01\n\x0b\n\x03\x05\x17\x01\x12\x04\xec\x01\x05\x1d\n\x0c\n\x04\x05\x17\
    \x02\0\x12\x04\xed\x01\x08/\n\r\n\x05\x05\x17\x02\0\x01\x12\x04\xed\x01\
    \x08*\n\r\n\x05\x05\x17\x02\0\x02\x12\x04\xed\x01-.\n\x0c\n\x04\x05\x17\
    \x02\x01\x12\x04\xee\x01\x08/\n\r\n\x05\x05\x17\x02\x01\x01\x12\x04\xee\
    \x01\x08*\n\r\n\x05\x05\x17\x02\x01\x02\x12\x04\xee\x01-.\n\x0c\n\x04\
    \x05\x17\x02\x02\x12\x04\xef\x01\x082\n\r\n\x05\x05\x17\x02\x02\x01\x12\
    \x04\xef\x01\x08-\n\r\n\x05\x05\x17\x02\x02\x02\x12\x04\xef\x0101\n\x0c\
    \n\x04\x05\x17\x02\x03\x12\x04\xf0\x01\x08.\n\r\n\x05\x05\x17\x02\x03\
    \x01\x12\x04\xf0\x01\x08)\n\r\n\x05\x05\x17\x02\x03\x02\x12\x04\xf0\x01,\
    -\n\x0c\n\x04\x05\x17\x02\x04\x12\x04\xf1\x01\x08,\n\r\n\x05\x05\x17\x02\
    \x04\x01\x12\x04\xf1\x01\x08'\n\r\n\x05\x05\x17\x02\x04\x02\x12\x04\xf1\
    \x01*+\n\x0c\n\x02\x05\x18\x12\x06\xf4\x01\0\xf9\x01\x01\n\x0b\n\x03\x05\
    \x18\x01\x12\x04\xf4\x01\x05\x20\n\x0c\n\x04\x05\x18\x02\0\x12\x04\xf5\
    \x01\x082\n\r\n\x05\x05\x18\x02\0\x01\x12\x04\xf5\x01\x08-\n\r\n\x05\x05\
    \x18\x02\0\x02\x12\x04\xf5\x0101\n\x0c\n\x04\x05\x18\x02\x01\x12\x04\xf6\
    \x01\x082\n\r\n\x05\x05\x18\x02\x01\x01\x12\x04\xf6\x01\x08-\n\r\n\x05\
    \x05\x18\x02\x01\x02\x12\x04\xf6\x0101\n\x0c\n\x04\x05\x18\x02\x02\x12\
    \x04\xf7\x01\x08/\n\r\n\x05\x05\x18\x02\x02\x01\x12\x04\xf7\x01\x08*\n\r\
    \n\x05\x05\x18\x02\x02\x02\x12\x04\xf7\x01-.\n\x0c\n\x04\x05\x18\x02\x03\
    \x12\x04\xf8\x01\x08/\n\r\n\x05\x05\x18\x02\x03\x01\x12\x04\xf8\x01\x08*\
    \n\r\n\x05\x05\x18\x02\x03\x02\x12\x04\xf8\x01-.\n\x0c\n\x02\x05\x19\x12\
    \x06\xfb\x01\0\x80\x02\x01\n\x0b\n\x03\x05\x19\x01\x12\x04\xfb\x01\x05$\
    \n\x0c\n\x04\x05\x19\x02\0\x12\x04\xfc\x01\x086\n\r\n\x05\x05\x19\x02\0\
    \x01\x12\x04\xfc\x01\x081\n\r\n\x05\x05\x19\x02\0\x02\x12\x04\xfc\x0145\
    \n\x0c\n\x04\x05\x19\x02\x01\x12\x04\xfd\x01\x08:\n\r\n\x05\x05\x19\x02\
    \x01\x01\x12\x04\xfd\x01\x085\n\r\n\x05\x05\x19\x02\x01\x02\x12\x04\xfd\
    \x0189\n\x0c\n\x04\x05\x19\x02\x02\x12\x04\xfe\x01\x087\n\r\n\x05\x05\
    \x19\x02\x02\x01\x12\x04\xfe\x01\x082\n\r\n\x05\x05\x19\x02\x02\x02\x12\
    \x04\xfe\x0156\n\x0c\n\x04\x05\x19\x02\x03\x12\x04\xff\x01\x087\n\r\n\
    \x05\x05\x19\x02\x03\x01\x12\x04\xff\x01\x082\n\r\n\x05\x05\x19\x02\x03\
    \x02\x12\x04\xff\x0156\n\x0c\n\x02\x05\x1a\x12\x06\x82\x02\0\x88\x02\x01\
    \n\x0b\n\x03\x05\x1a\x01\x12\x04\x82\x02\x05-\n\x0c\n\x04\x05\x1a\x02\0\
    \x12\x04\x83\x02\x08A\n\r\n\x05\x05\x1a\x02\0\x01\x12\x04\x83\x02\x08<\n\
    \r\n\x05\x05\x1a\x02\0\x02\x12\x04\x83\x02?@\n\x0c\n\x04\x05\x1a\x02\x01\
    \x12\x04\x84\x02\x08E\n\r\n\x05\x05\x1a\x02\x01\x01\x12\x04\x84\x02\x08@\
    \n\r\n\x05\x05\x1a\x02\x01\x02\x12\x04\x84\x02CD\n\x0c\n\x04\x05\x1a\x02\
    \x02\x12\x04\x85\x02\x08C\n\r\n\x05\x05\x1a\x02\x02\x01\x12\x04\x85\x02\
    \x08>\n\r\n\x05\x05\x1a\x02\x02\x02\x12\x04\x85\x02AB\n\x0c\n\x04\x05\
    \x1a\x02\x03\x12\x04\x86\x02\x08@\n\r\n\x05\x05\x1a\x02\x03\x01\x12\x04\
    \x86\x02\x08;\n\r\n\x05\x05\x1a\x02\x03\x02\x12\x04\x86\x02>?\n\x0c\n\
    \x04\x05\x1a\x02\x04\x12\x04\x87\x02\x08@\n\r\n\x05\x05\x1a\x02\x04\x01\
    \x12\x04\x87\x02\x08;\n\r\n\x05\x05\x1a\x02\x04\x02\x12\x04\x87\x02>?\n\
    \x0c\n\x02\x05\x1b\x12\x06\x8a\x02\0\x8f\x02\x01\n\x0b\n\x03\x05\x1b\x01\
    \x12\x04\x8a\x02\x05\r\n\x0c\n\x04\x05\x1b\x02\0\x12\x04\x8b\x02\x08\x1f\
    \n\r\n\x05\x05\x1b\x02\0\x01\x12\x04\x8b\x02\x08\x1a\n\r\n\x05\x05\x1b\
    \x02\0\x02\x12\x04\x8b\x02\x1d\x1e\n\x0c\n\x04\x05\x1b\x02\x01\x12\x04\
    \x8c\x02\x08$\n\r\n\x05\x05\x1b\x02\x01\x01\x12\x04\x8c\x02\x08\x1f\n\r\
    \n\x05\x05\x1b\x02\x01\x02\x12\x04\x8c\x02\"#\n\x0c\n\x04\x05\x1b\x02\
    \x02\x12\x04\x8d\x02\x08!\n\r\n\x05\x05\x1b\x02\x02\x01\x12\x04\x8d\x02\
    \x08\x1c\n\r\n\x05\x05\x1b\x02\x02\x02\x12\x04\x8d\x02\x1f\x20\n\x0c\n\
    \x04\x05\x1b\x02\x03\x12\x04\x8e\x02\x08%\n\r\n\x05\x05\x1b\x02\x03\x01\
    \x12\x04\x8e\x02\x08\x20\n\r\n\x05\x05\x1b\x02\x03\x02\x12\x04\x8e\x02#$\
    \n\x0c\n\x02\x05\x1c\x12\x06\x91\x02\0\x96\x02\x01\n\x0b\n\x03\x05\x1c\
    \x01\x12\x04\x91\x02\x05\x12\n\x0c\n\x04\x05\x1c\x02\0\x12\x04\x92\x02\
    \x08$\n\r\n\x05\x05\x1c\x02\0\x01\x12\x04\x92\x02\x08\x1f\n\r\n\x05\x05\
    \x1c\x02\0\x02\x12\x04\x92\x02\"#\n\x0c\n\x04\x05\x1c\x02\x01\x12\x04\
    \x93\x02\x08(\n\r\n\x05\x05\x1c\x02\x01\x01\x12\x04\x93\x02\x08#\n\r\n\
    \x05\x05\x1c\x02\x01\x02\x12\x04\x93\x02&'\n\x0c\n\x04\x05\x1c\x02\x02\
    \x12\x04\x94\x02\x08%\n\r\n\x05\x05\x1c\x02\x02\x01\x12\x04\x94\x02\x08\
    \x20\n\r\n\x05\x05\x1c\x02\x02\x02\x12\x04\x94\x02#$\n\x0c\n\x04\x05\x1c\
    \x02\x03\x12\x04\x95\x02\x08!\n\r\n\x05\x05\x1c\x02\x03\x01\x12\x04\x95\
    \x02\x08\x1c\n\r\n\x05\x05\x1c\x02\x03\x02\x12\x04\x95\x02\x1f\x20\n\x0c\
    \n\x02\x05\x1d\x12\x06\x98\x02\0\x9f\x02\x01\n\x0b\n\x03\x05\x1d\x01\x12\
    \x04\x98\x02\x05\x0e\n\x0c\n\x04\x05\x1d\x02\0\x12\x04\x99\x02\x08\x20\n\
    \r\n\x05\x05\x1d\x02\0\x01\x12\x04\x99\x02\x08\x1b\n\r\n\x05\x05\x1d\x02\
    \0\x02\x12\x04\x99\x02\x1e\x1f\n\x0c\n\x04\x05\x1d\x02\x01\x12\x04\x9a\
    \x02\x08\x20\n\r\n\x05\x05\x1d\x02\x01\x01\x12\x04\x9a\x02\x08\x1b\n\r\n\
    \x05\x05\x1d\x02\x01\x02\x12\x04\x9a\x02\x1e\x1f\n\x0c\n\x04\x05\x1d\x02\
    \x02\x12\x04\x9b\x02\x08)\n\r\n\x05\x05\x1d\x02\x02\x01\x12\x04\x9b\x02\
    \x08$\n\r\n\x05\x05\x1d\x02\x02\x02\x12\x04\x9b\x02'(\n\x0c\n\x04\x05\
    \x1d\x02\x03\x12\x04\x9c\x02\x08\x1d\n\r\n\x05\x05\x1d\x02\x03\x01\x12\
    \x04\x9c\x02\x08\x18\n\r\n\x05\x05\x1d\x02\x03\x02\x12\x04\x9c\x02\x1b\
    \x1c\n\x0c\n\x04\x05\x1d\x02\x04\x12\x04\x9d\x02\x08&\n\r\n\x05\x05\x1d\
    \x02\x04\x01\x12\x04\x9d\x02\x08!\n\r\n\x05\x05\x1d\x02\x04\x02\x12\x04\
    \x9d\x02$%\n\x0c\n\x04\x05\x1d\x02\x05\x12\x04\x9e\x02\x08\x1d\n\r\n\x05\
    \x05\x1d\x02\x05\x01\x12\x04\x9e\x02\x08\x18\n\r\n\x05\x05\x1d\x02\x05\
    \x02\x12\x04\x9e\x02\x1b\x1c\n\x0c\n\x02\x05\x1e\x12\x06\xa1\x02\0\xb3\
    \x02\x01\n\x0b\n\x03\x05\x1e\x01\x12\x04\xa1\x02\x05\x18\n\x0c\n\x04\x05\
    \x1e\x02\0\x12\x04\xa2\x02\x08*\n\r\n\x05\x05\x1e\x02\0\x01\x12\x04\xa2\
    \x02\x08%\n\r\n\x05\x05\x1e\x02\0\x02\x12\x04\xa2\x02()\n\x0c\n\x04\x05\
    \x1e\x02\x01\x12\x04\xa3\x02\x08(\n\r\n\x05\x05\x1e\x02\x01\x01\x12\x04\
    \xa3\x02\x08#\n\r\n\x05\x05\x1e\x02\x01\x02\x12\x04\xa3\x02&'\n\x0c\n\
    \x04\x05\x1e\x02\x02\x12\x04\xa4\x02\x08+\n\r\n\x05\x05\x1e\x02\x02\x01\
    \x12\x04\xa4\x02\x08&\n\r\n\x05\x05\x1e\x02\x02\x02\x12\x04\xa4\x02)*\n\
    \x0c\n\x04\x05\x1e\x02\x03\x12\x04\xa5\x02\x084\n\r\n\x05\x05\x1e\x02\
    \x03\x01\x12\x04\xa5\x02\x08/\n\r\n\x05\x05\x1e\x02\x03\x02\x12\x04\xa5\
    \x0223\n\x0c\n\x04\x05\x1e\x02\x04\x12\x04\xa6\x02\x08+\n\r\n\x05\x05\
    \x1e\x02\x04\x01\x12\x04\xa6\x02\x08&\n\r\n\x05\x05\x1e\x02\x04\x02\x12\
    \x04\xa6\x02)*\n\x0c\n\x04\x05\x1e\x02\x05\x12\x04\xa7\x02\x08.\n\r\n\
    \x05\x05\x1e\x02\x05\x01\x12\x04\xa7\x02\x08)\n\r\n\x05\x05\x1e\x02\x05\
    \x02\x12\x04\xa7\x02,-\n\x0c\n\x04\x05\x1e\x02\x06\x12\x04\xa8\x02\x08-\
    \n\r\n\x05\x05\x1e\x02\x06\x01\x12\x04\xa8\x02\x08(\n\r\n\x05\x05\x1e\
    \x02\x06\x02\x12\x04\xa8\x02+,\n\x0c\n\x04\x05\x1e\x02\x07\x12\x04\xa9\
    \x02\x08*\n\r\n\x05\x05\x1e\x02\x07\x01\x12\x04\xa9\x02\x08%\n\r\n\x05\
    \x05\x1e\x02\x07\x02\x12\x04\xa9\x02()\n\x0c\n\x04\x05\x1e\x02\x08\x12\
    \x04\xaa\x02\x082\n\r\n\x05\x05\x1e\x02\x08\x01\x12\x04\xaa\x02\x08-\n\r\
    \n\x05\x05\x1e\x02\x08\x02\x12\x04\xaa\x0201\n\x0c\n\x04\x05\x1e\x02\t\
    \x12\x04\xab\x02\x08(\n\r\n\x05\x05\x1e\x02\t\x01\x12\x04\xab\x02\x08#\n\
    \r\n\x05\x05\x1e\x02\t\x02\x12\x04\xab\x02&'\n\x0c\n\x04\x05\x1e\x02\n\
    \x12\x04\xac\x02\x08.\n\r\n\x05\x05\x1e\x02\n\x01\x12\x04\xac\x02\x08(\n\
    \r\n\x05\x05\x1e\x02\n\x02\x12\x04\xac\x02+-\n\x0c\n\x04\x05\x1e\x02\x0b\
    \x12\x04\xad\x02\x08+\n\r\n\x05\x05\x1e\x02\x0b\x01\x12\x04\xad\x02\x08%\
    \n\r\n\x05\x05\x1e\x02\x0b\x02\x12\x04\xad\x02(*\n\x0c\n\x04\x05\x1e\x02\
    \x0c\x12\x04\xae\x02\x08.\n\r\n\x05\x05\x1e\x02\x0c\x01\x12\x04\xae\x02\
    \x08(\n\r\n\x05\x05\x1e\x02\x0c\x02\x12\x04\xae\x02+-\n\x0c\n\x04\x05\
    \x1e\x02\r\x12\x04\xaf\x02\x089\n\r\n\x05\x05\x1e\x02\r\x01\x12\x04\xaf\
    \x02\x083\n\r\n\x05\x05\x1e\x02\r\x02\x12\x04\xaf\x0268\n\x0c\n\x04\x05\
    \x1e\x02\x0e\x12\x04\xb0\x02\x08/\n\r\n\x05\x05\x1e\x02\x0e\x01\x12\x04\
    \xb0\x02\x08)\n\r\n\x05\x05\x1e\x02\x0e\x02\x12\x04\xb0\x02,.\n\x0c\n\
    \x04\x05\x1e\x02\x0f\x12\x04\xb1\x02\x082\n\r\n\x05\x05\x1e\x02\x0f\x01\
    \x12\x04\xb1\x02\x08,\n\r\n\x05\x05\x1e\x02\x0f\x02\x12\x04\xb1\x02/1\n\
    \x0c\n\x04\x05\x1e\x02\x10\x12\x04\xb2\x02\x089\n\r\n\x05\x05\x1e\x02\
    \x10\x01\x12\x04\xb2\x02\x083\n\r\n\x05\x05\x1e\x02\x10\x02\x12\x04\xb2\
    \x0268\n\x0c\n\x02\x05\x1f\x12\x06\xb5\x02\0\xba\x02\x01\n\x0b\n\x03\x05\
    \x1f\x01\x12\x04\xb5\x02\x05$\n\x0c\n\x04\x05\x1f\x02\0\x12\x04\xb6\x02\
    \x084\n\r\n\x05\x05\x1f\x02\0\x01\x12\x04\xb6\x02\x08/\n\r\n\x05\x05\x1f\
    \x02\0\x02\x12\x04\xb6\x0223\n\x0c\n\x04\x05\x1f\x02\x01\x12\x04\xb7\x02\
    \x084\n\r\n\x05\x05\x1f\x02\x01\x01\x12\x04\xb7\x02\x08/\n\r\n\x05\x05\
    \x1f\x02\x01\x02\x12\x04\xb7\x0223\n\x0c\n\x04\x05\x1f\x02\x02\x12\x04\
    \xb8\x02\x087\n\r\n\x05\x05\x1f\x02\x02\x01\x12\x04\xb8\x02\x082\n\r\n\
    \x05\x05\x1f\x02\x02\x02\x12\x04\xb8\x0256\n\x0c\n\x04\x05\x1f\x02\x03\
    \x12\x04\xb9\x02\x085\n\r\n\x05\x05\x1f\x02\x03\x01\x12\x04\xb9\x02\x080\
    \n\r\n\x05\x05\x1f\x02\x03\x02\x12\x04\xb9\x0234\n\x0c\n\x02\x05\x20\x12\
    \x06\xbc\x02\0\xc0\x02\x01\n\x0b\n\x03\x05\x20\x01\x12\x04\xbc\x02\x05#\
    \n\x0c\n\x04\x05\x20\x02\0\x12\x04\xbd\x02\x083\n\r\n\x05\x05\x20\x02\0\
    \x01\x12\x04\xbd\x02\x08.\n\r\n\x05\x05\x20\x02\0\x02\x12\x04\xbd\x0212\
    \n\x0c\n\x04\x05\x20\x02\x01\x12\x04\xbe\x02\x081\n\r\n\x05\x05\x20\x02\
    \x01\x01\x12\x04\xbe\x02\x08,\n\r\n\x05\x05\x20\x02\x01\x02\x12\x04\xbe\
    \x02/0\n\x0c\n\x04\x05\x20\x02\x02\x12\x04\xbf\x02\x080\n\r\n\x05\x05\
    \x20\x02\x02\x01\x12\x04\xbf\x02\x08+\n\r\n\x05\x05\x20\x02\x02\x02\x12\
    \x04\xbf\x02./\n\x0c\n\x02\x05!\x12\x06\xc2\x02\0\xd1\x02\x01\n\x0b\n\
    \x03\x05!\x01\x12\x04\xc2\x02\x05\x12\n\x0c\n\x04\x05!\x02\0\x12\x04\xc3\
    \x02\x08\x20\n\r\n\x05\x05!\x02\0\x01\x12\x04\xc3\x02\x08\x1b\n\r\n\x05\
    \x05!\x02\0\x02\x12\x04\xc3\x02\x1e\x1f\n\x0c\n\x04\x05!\x02\x01\x12\x04\
    \xc4\x02\x08!\n\r\n\x05\x05!\x02\x01\x01\x12\x04\xc4\x02\x08\x1c\n\r\n\
    \x05\x05!\x02\x01\x02\x12\x04\xc4\x02\x1f\x20\n\x0c\n\x04\x05!\x02\x02\
    \x12\x04\xc5\x02\x08\x1f\n\r\n\x05\x05!\x02\x02\x01\x12\x04\xc5\x02\x08\
    \x1a\n\r\n\x05\x05!\x02\x02\x02\x12\x04\xc5\x02\x1d\x1e\n\x0c\n\x04\x05!\
    \x02\x03\x12\x04\xc6\x02\x08%\n\r\n\x05\x05!\x02\x03\x01\x12\x04\xc6\x02\
    \x08\x20\n\r\n\x05\x05!\x02\x03\x02\x12\x04\xc6\x02#$\n\x0c\n\x04\x05!\
    \x02\x04\x12\x04\xc7\x02\x08&\n\r\n\x05\x05!\x02\x04\x01\x12\x04\xc7\x02\
    \x08!\n\r\n\x05\x05!\x02\x04\x02\x12\x04\xc7\x02$%\n\x0c\n\x04\x05!\x02\
    \x05\x12\x04\xc8\x02\x08%\n\r\n\x05\x05!\x02\x05\x01\x12\x04\xc8\x02\x08\
    \x20\n\r\n\x05\x05!\x02\x05\x02\x12\x04\xc8\x02#$\n\x0c\n\x04\x05!\x02\
    \x06\x12\x04\xc9\x02\x08#\n\r\n\x05\x05!\x02\x06\x01\x12\x04\xc9\x02\x08\
    \x1e\n\r\n\x05\x05!\x02\x06\x02\x12\x04\xc9\x02!\"\n\x0c\n\x04\x05!\x02\
    \x07\x12\x04\xca\x02\x08(\n\r\n\x05\x05!\x02\x07\x01\x12\x04\xca\x02\x08\
    #\n\r\n\x05\x05!\x02\x07\x02\x12\x04\xca\x02&'\n\x0c\n\x04\x05!\x02\x08\
    \x12\x04\xcb\x02\x08(\n\r\n\x05\x05!\x02\x08\x01\x12\x04\xcb\x02\x08#\n\
    \r\n\x05\x05!\x02\x08\x02\x12\x04\xcb\x02&'\n\x0c\n\x04\x05!\x02\t\x12\
    \x04\xcc\x02\x08&\n\r\n\x05\x05!\x02\t\x01\x12\x04\xcc\x02\x08!\n\r\n\
    \x05\x05!\x02\t\x02\x12\x04\xcc\x02$%\n\x0c\n\x04\x05!\x02\n\x12\x04\xcd\
    \x02\x08(\n\r\n\x05\x05!\x02\n\x01\x12\x04\xcd\x02\x08\"\n\r\n\x05\x05!\
    \x02\n\x02\x12\x04\xcd\x02%'\n\x0c\n\x04\x05!\x02\x0b\x12\x04\xce\x02\
    \x08%\n\r\n\x05\x05!\x02\x0b\x01\x12\x04\xce\x02\x08\x1f\n\r\n\x05\x05!\
    \x02\x0b\x02\x12\x04\xce\x02\"$\n\x0c\n\x04\x05!\x02\x0c\x12\x04\xcf\x02\
    \x08'\n\r\n\x05\x05!\x02\x0c\x01\x12\x04\xcf\x02\x08!\n\r\n\x05\x05!\x02\
    \x0c\x02\x12\x04\xcf\x02$&\n\x0c\n\x04\x05!\x02\r\x12\x04\xd0\x02\x08+\n\
    \r\n\x05\x05!\x02\r\x01\x12\x04\xd0\x02\x08%\n\r\n\x05\x05!\x02\r\x02\
    \x12\x04\xd0\x02(*\n\x0c\n\x02\x05\"\x12\x06\xd3\x02\0\xd7\x02\x01\n\x0b\
    \n\x03\x05\"\x01\x12\x04\xd3\x02\x05\x18\n\x0c\n\x04\x05\"\x02\0\x12\x04\
    \xd4\x02\x08+\n\r\n\x05\x05\"\x02\0\x01\x12\x04\xd4\x02\x08%\n\r\n\x05\
    \x05\"\x02\0\x02\x12\x04\xd4\x02(*\n\x0c\n\x04\x05\"\x02\x01\x12\x04\xd5\
    \x02\x08,\n\r\n\x05\x05\"\x02\x01\x01\x12\x04\xd5\x02\x08'\n\r\n\x05\x05\
    \"\x02\x01\x02\x12\x04\xd5\x02*+\n\x0c\n\x04\x05\"\x02\x02\x12\x04\xd6\
    \x02\x08-\n\r\n\x05\x05\"\x02\x02\x01\x12\x04\xd6\x02\x08(\n\r\n\x05\x05\
    \"\x02\x02\x02\x12\x04\xd6\x02+,\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_base::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(0);
            let mut enums = ::std::vec::Vec::with_capacity(35);
            enums.push(EPublishedFileQueryType::generated_enum_descriptor_data());
            enums.push(EPublishedFileInappropriateProvider::generated_enum_descriptor_data());
            enums.push(EPublishedFileInappropriateResult::generated_enum_descriptor_data());
            enums.push(EPersonaStateFlag::generated_enum_descriptor_data());
            enums.push(EContentCheckProvider::generated_enum_descriptor_data());
            enums.push(EProfileCustomizationType::generated_enum_descriptor_data());
            enums.push(EPublishedFileStorageSystem::generated_enum_descriptor_data());
            enums.push(ECloudStoragePersistState::generated_enum_descriptor_data());
            enums.push(ESDCardFormatStage::generated_enum_descriptor_data());
            enums.push(ESystemFanControlMode::generated_enum_descriptor_data());
            enums.push(EColorProfile::generated_enum_descriptor_data());
            enums.push(EBluetoothDeviceType::generated_enum_descriptor_data());
            enums.push(ESystemAudioDirection::generated_enum_descriptor_data());
            enums.push(ESystemAudioChannel::generated_enum_descriptor_data());
            enums.push(ESystemAudioPortType::generated_enum_descriptor_data());
            enums.push(ESystemAudioPortDirection::generated_enum_descriptor_data());
            enums.push(ESystemServiceState::generated_enum_descriptor_data());
            enums.push(EGraphicsPerfOverlayLevel::generated_enum_descriptor_data());
            enums.push(EGPUPerformanceLevel::generated_enum_descriptor_data());
            enums.push(EScalingFilter::generated_enum_descriptor_data());
            enums.push(ECPUGovernor::generated_enum_descriptor_data());
            enums.push(EUpdaterType::generated_enum_descriptor_data());
            enums.push(EUpdaterState::generated_enum_descriptor_data());
            enums.push(EStorageBlockContentType::generated_enum_descriptor_data());
            enums.push(EStorageBlockFileSystemType::generated_enum_descriptor_data());
            enums.push(ESteamDeckCompatibilityCategory::generated_enum_descriptor_data());
            enums.push(ESteamDeckCompatibilityResultDisplayType::generated_enum_descriptor_data());
            enums.push(EACState::generated_enum_descriptor_data());
            enums.push(EBatteryState::generated_enum_descriptor_data());
            enums.push(EOSBranch::generated_enum_descriptor_data());
            enums.push(ECommunityItemClass::generated_enum_descriptor_data());
            enums.push(ESteamDeckCompatibilityFeedback::generated_enum_descriptor_data());
            enums.push(EProvideDeckFeedbackPreference::generated_enum_descriptor_data());
            enums.push(ETouchGesture::generated_enum_descriptor_data());
            enums.push(ESessionPersistence::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
