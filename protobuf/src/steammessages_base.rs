// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by protoc --rust_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_base.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgIPAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgIPAddress {
    // message oneof groups
    pub ip: ::std::option::Option<cmsg_ipaddress::Ip>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIPAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIPAddress {
    fn default() -> &'a CMsgIPAddress {
        <CMsgIPAddress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIPAddress {
    pub fn new() -> CMsgIPAddress {
        ::std::default::Default::default()
    }

    // optional fixed32 v4 = 1;

    pub fn v4(&self) -> u32 {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_v4(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_v4(&self) -> bool {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_v4(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(v))
    }

    // optional bytes v6 = 2;

    pub fn v6(&self) -> &[u8] {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_v6(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_v6(&self) -> bool {
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_v6(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(v))
    }

    // Mutable pointer to the field.
    pub fn mut_v6(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(_)) = self.ip {
        } else {
            self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(::std::vec::Vec::new()));
        }
        match self.ip {
            ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_v6(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_v6() {
            match self.ip.take() {
                ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "v4",
            CMsgIPAddress::has_v4,
            CMsgIPAddress::v4,
            CMsgIPAddress::set_v4,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "v6",
            CMsgIPAddress::has_v6,
            CMsgIPAddress::v6,
            CMsgIPAddress::set_v6,
        ));
        oneofs.push(cmsg_ipaddress::Ip::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgIPAddress>(
            "CMsgIPAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgIPAddress {
    const NAME: &'static str = "CMsgIPAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V4(is.read_fixed32()?));
                },
                18 => {
                    self.ip = ::std::option::Option::Some(cmsg_ipaddress::Ip::V6(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.ip {
            match v {
                &cmsg_ipaddress::Ip::V4(v) => {
                    my_size += 1 + 4;
                },
                &cmsg_ipaddress::Ip::V6(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.ip {
            match v {
                &cmsg_ipaddress::Ip::V4(v) => {
                    os.write_fixed32(1, v)?;
                },
                &cmsg_ipaddress::Ip::V6(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIPAddress {
        CMsgIPAddress::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIPAddress {
        static instance: CMsgIPAddress = CMsgIPAddress {
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgIPAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgIPAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgIPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIPAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgIPAddress`
pub mod cmsg_ipaddress {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgIPAddress.ip)
    pub enum Ip {
        // @@protoc_insertion_point(oneof_field:CMsgIPAddress.v4)
        V4(u32),
        // @@protoc_insertion_point(oneof_field:CMsgIPAddress.v6)
        V6(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Ip {
    }

    impl ::protobuf::OneofFull for Ip {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CMsgIPAddress as ::protobuf::MessageFull>::descriptor().oneof_by_name("ip").unwrap()).clone()
        }
    }

    impl Ip {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Ip>("ip")
        }
    }
}

// @@protoc_insertion_point(message:CMsgIPAddressBucket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgIPAddressBucket {
    // message fields
    // @@protoc_insertion_point(field:CMsgIPAddressBucket.original_ip_address)
    pub original_ip_address: ::protobuf::MessageField<CMsgIPAddress>,
    // @@protoc_insertion_point(field:CMsgIPAddressBucket.bucket)
    pub bucket: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIPAddressBucket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIPAddressBucket {
    fn default() -> &'a CMsgIPAddressBucket {
        <CMsgIPAddressBucket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIPAddressBucket {
    pub fn new() -> CMsgIPAddressBucket {
        ::std::default::Default::default()
    }

    // optional fixed64 bucket = 2;

    pub fn bucket(&self) -> u64 {
        self.bucket.unwrap_or(0)
    }

    pub fn clear_bucket(&mut self) {
        self.bucket = ::std::option::Option::None;
    }

    pub fn has_bucket(&self) -> bool {
        self.bucket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: u64) {
        self.bucket = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgIPAddress>(
            "original_ip_address",
            |m: &CMsgIPAddressBucket| { &m.original_ip_address },
            |m: &mut CMsgIPAddressBucket| { &mut m.original_ip_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bucket",
            |m: &CMsgIPAddressBucket| { &m.bucket },
            |m: &mut CMsgIPAddressBucket| { &mut m.bucket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgIPAddressBucket>(
            "CMsgIPAddressBucket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgIPAddressBucket {
    const NAME: &'static str = "CMsgIPAddressBucket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.original_ip_address)?;
                },
                17 => {
                    self.bucket = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.original_ip_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bucket {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.original_ip_address.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.bucket {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIPAddressBucket {
        CMsgIPAddressBucket::new()
    }

    fn clear(&mut self) {
        self.original_ip_address.clear();
        self.bucket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIPAddressBucket {
        static instance: CMsgIPAddressBucket = CMsgIPAddressBucket {
            original_ip_address: ::protobuf::MessageField::none(),
            bucket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgIPAddressBucket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgIPAddressBucket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgIPAddressBucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIPAddressBucket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCRoutingProtoBufHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRoutingProtoBufHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRoutingProtoBufHeader.dst_gcid_queue)
    pub dst_gcid_queue: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCRoutingProtoBufHeader.dst_gc_dir_index)
    pub dst_gc_dir_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRoutingProtoBufHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRoutingProtoBufHeader {
    fn default() -> &'a CMsgGCRoutingProtoBufHeader {
        <CMsgGCRoutingProtoBufHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRoutingProtoBufHeader {
    pub fn new() -> CMsgGCRoutingProtoBufHeader {
        ::std::default::Default::default()
    }

    // optional uint64 dst_gcid_queue = 1;

    pub fn dst_gcid_queue(&self) -> u64 {
        self.dst_gcid_queue.unwrap_or(0)
    }

    pub fn clear_dst_gcid_queue(&mut self) {
        self.dst_gcid_queue = ::std::option::Option::None;
    }

    pub fn has_dst_gcid_queue(&self) -> bool {
        self.dst_gcid_queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_gcid_queue(&mut self, v: u64) {
        self.dst_gcid_queue = ::std::option::Option::Some(v);
    }

    // optional uint32 dst_gc_dir_index = 2;

    pub fn dst_gc_dir_index(&self) -> u32 {
        self.dst_gc_dir_index.unwrap_or(0)
    }

    pub fn clear_dst_gc_dir_index(&mut self) {
        self.dst_gc_dir_index = ::std::option::Option::None;
    }

    pub fn has_dst_gc_dir_index(&self) -> bool {
        self.dst_gc_dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dst_gc_dir_index(&mut self, v: u32) {
        self.dst_gc_dir_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_gcid_queue",
            |m: &CMsgGCRoutingProtoBufHeader| { &m.dst_gcid_queue },
            |m: &mut CMsgGCRoutingProtoBufHeader| { &mut m.dst_gcid_queue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dst_gc_dir_index",
            |m: &CMsgGCRoutingProtoBufHeader| { &m.dst_gc_dir_index },
            |m: &mut CMsgGCRoutingProtoBufHeader| { &mut m.dst_gc_dir_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRoutingProtoBufHeader>(
            "CMsgGCRoutingProtoBufHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRoutingProtoBufHeader {
    const NAME: &'static str = "CMsgGCRoutingProtoBufHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dst_gcid_queue = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.dst_gc_dir_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dst_gcid_queue {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.dst_gc_dir_index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dst_gcid_queue {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.dst_gc_dir_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRoutingProtoBufHeader {
        CMsgGCRoutingProtoBufHeader::new()
    }

    fn clear(&mut self) {
        self.dst_gcid_queue = ::std::option::Option::None;
        self.dst_gc_dir_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRoutingProtoBufHeader {
        static instance: CMsgGCRoutingProtoBufHeader = CMsgGCRoutingProtoBufHeader {
            dst_gcid_queue: ::std::option::Option::None,
            dst_gc_dir_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRoutingProtoBufHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRoutingProtoBufHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRoutingProtoBufHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRoutingProtoBufHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgProtoBufHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProtoBufHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.client_sessionid)
    pub client_sessionid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.routing_appid)
    pub routing_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.jobid_source)
    pub jobid_source: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.jobid_target)
    pub jobid_target: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.target_job_name)
    pub target_job_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.seq_num)
    pub seq_num: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.eresult)
    pub eresult: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.error_message)
    pub error_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.auth_account_flags)
    pub auth_account_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.token_source)
    pub token_source: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.admin_spoofing_user)
    pub admin_spoofing_user: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.transport_error)
    pub transport_error: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.messageid)
    pub messageid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.publisher_group_id)
    pub publisher_group_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.sysid)
    pub sysid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.trace_tag)
    pub trace_tag: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.webapi_key_id)
    pub webapi_key_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.is_from_external_source)
    pub is_from_external_source: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.forward_to_sysid)
    pub forward_to_sysid: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.cm_sysid)
    pub cm_sysid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.launcher_type)
    pub launcher_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.realm)
    pub realm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.timeout_ms)
    pub timeout_ms: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.debug_source)
    pub debug_source: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.debug_source_string_index)
    pub debug_source_string_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.token_id)
    pub token_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProtoBufHeader.routing_gc)
    pub routing_gc: ::protobuf::MessageField<CMsgGCRoutingProtoBufHeader>,
    // message oneof groups
    pub ip_addr: ::std::option::Option<cmsg_proto_buf_header::Ip_addr>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtoBufHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtoBufHeader {
    fn default() -> &'a CMsgProtoBufHeader {
        <CMsgProtoBufHeader as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProtoBufHeader {
    pub fn new() -> CMsgProtoBufHeader {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 client_sessionid = 2;

    pub fn client_sessionid(&self) -> i32 {
        self.client_sessionid.unwrap_or(0)
    }

    pub fn clear_client_sessionid(&mut self) {
        self.client_sessionid = ::std::option::Option::None;
    }

    pub fn has_client_sessionid(&self) -> bool {
        self.client_sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_sessionid(&mut self, v: i32) {
        self.client_sessionid = ::std::option::Option::Some(v);
    }

    // optional uint32 routing_appid = 3;

    pub fn routing_appid(&self) -> u32 {
        self.routing_appid.unwrap_or(0)
    }

    pub fn clear_routing_appid(&mut self) {
        self.routing_appid = ::std::option::Option::None;
    }

    pub fn has_routing_appid(&self) -> bool {
        self.routing_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_appid(&mut self, v: u32) {
        self.routing_appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 jobid_source = 10;

    pub fn jobid_source(&self) -> u64 {
        self.jobid_source.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_jobid_source(&mut self) {
        self.jobid_source = ::std::option::Option::None;
    }

    pub fn has_jobid_source(&self) -> bool {
        self.jobid_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jobid_source(&mut self, v: u64) {
        self.jobid_source = ::std::option::Option::Some(v);
    }

    // optional fixed64 jobid_target = 11;

    pub fn jobid_target(&self) -> u64 {
        self.jobid_target.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_jobid_target(&mut self) {
        self.jobid_target = ::std::option::Option::None;
    }

    pub fn has_jobid_target(&self) -> bool {
        self.jobid_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jobid_target(&mut self, v: u64) {
        self.jobid_target = ::std::option::Option::Some(v);
    }

    // optional string target_job_name = 12;

    pub fn target_job_name(&self) -> &str {
        match self.target_job_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_target_job_name(&mut self) {
        self.target_job_name = ::std::option::Option::None;
    }

    pub fn has_target_job_name(&self) -> bool {
        self.target_job_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_job_name(&mut self, v: ::std::string::String) {
        self.target_job_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_job_name(&mut self) -> &mut ::std::string::String {
        if self.target_job_name.is_none() {
            self.target_job_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.target_job_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_job_name(&mut self) -> ::std::string::String {
        self.target_job_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 seq_num = 24;

    pub fn seq_num(&self) -> i32 {
        self.seq_num.unwrap_or(0)
    }

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: i32) {
        self.seq_num = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 13;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string error_message = 14;

    pub fn error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_message(&mut self) {
        self.error_message = ::std::option::Option::None;
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 auth_account_flags = 16;

    pub fn auth_account_flags(&self) -> u32 {
        self.auth_account_flags.unwrap_or(0)
    }

    pub fn clear_auth_account_flags(&mut self) {
        self.auth_account_flags = ::std::option::Option::None;
    }

    pub fn has_auth_account_flags(&self) -> bool {
        self.auth_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_account_flags(&mut self, v: u32) {
        self.auth_account_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 token_source = 22;

    pub fn token_source(&self) -> u32 {
        self.token_source.unwrap_or(0)
    }

    pub fn clear_token_source(&mut self) {
        self.token_source = ::std::option::Option::None;
    }

    pub fn has_token_source(&self) -> bool {
        self.token_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_source(&mut self, v: u32) {
        self.token_source = ::std::option::Option::Some(v);
    }

    // optional bool admin_spoofing_user = 23;

    pub fn admin_spoofing_user(&self) -> bool {
        self.admin_spoofing_user.unwrap_or(false)
    }

    pub fn clear_admin_spoofing_user(&mut self) {
        self.admin_spoofing_user = ::std::option::Option::None;
    }

    pub fn has_admin_spoofing_user(&self) -> bool {
        self.admin_spoofing_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin_spoofing_user(&mut self, v: bool) {
        self.admin_spoofing_user = ::std::option::Option::Some(v);
    }

    // optional int32 transport_error = 17;

    pub fn transport_error(&self) -> i32 {
        self.transport_error.unwrap_or(1i32)
    }

    pub fn clear_transport_error(&mut self) {
        self.transport_error = ::std::option::Option::None;
    }

    pub fn has_transport_error(&self) -> bool {
        self.transport_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_error(&mut self, v: i32) {
        self.transport_error = ::std::option::Option::Some(v);
    }

    // optional uint64 messageid = 18;

    pub fn messageid(&self) -> u64 {
        self.messageid.unwrap_or(18446744073709551615u64)
    }

    pub fn clear_messageid(&mut self) {
        self.messageid = ::std::option::Option::None;
    }

    pub fn has_messageid(&self) -> bool {
        self.messageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageid(&mut self, v: u64) {
        self.messageid = ::std::option::Option::Some(v);
    }

    // optional uint32 publisher_group_id = 19;

    pub fn publisher_group_id(&self) -> u32 {
        self.publisher_group_id.unwrap_or(0)
    }

    pub fn clear_publisher_group_id(&mut self) {
        self.publisher_group_id = ::std::option::Option::None;
    }

    pub fn has_publisher_group_id(&self) -> bool {
        self.publisher_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publisher_group_id(&mut self, v: u32) {
        self.publisher_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sysid = 20;

    pub fn sysid(&self) -> u32 {
        self.sysid.unwrap_or(0)
    }

    pub fn clear_sysid(&mut self) {
        self.sysid = ::std::option::Option::None;
    }

    pub fn has_sysid(&self) -> bool {
        self.sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid(&mut self, v: u32) {
        self.sysid = ::std::option::Option::Some(v);
    }

    // optional uint64 trace_tag = 21;

    pub fn trace_tag(&self) -> u64 {
        self.trace_tag.unwrap_or(0)
    }

    pub fn clear_trace_tag(&mut self) {
        self.trace_tag = ::std::option::Option::None;
    }

    pub fn has_trace_tag(&self) -> bool {
        self.trace_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace_tag(&mut self, v: u64) {
        self.trace_tag = ::std::option::Option::Some(v);
    }

    // optional uint32 webapi_key_id = 25;

    pub fn webapi_key_id(&self) -> u32 {
        self.webapi_key_id.unwrap_or(0)
    }

    pub fn clear_webapi_key_id(&mut self) {
        self.webapi_key_id = ::std::option::Option::None;
    }

    pub fn has_webapi_key_id(&self) -> bool {
        self.webapi_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webapi_key_id(&mut self, v: u32) {
        self.webapi_key_id = ::std::option::Option::Some(v);
    }

    // optional bool is_from_external_source = 26;

    pub fn is_from_external_source(&self) -> bool {
        self.is_from_external_source.unwrap_or(false)
    }

    pub fn clear_is_from_external_source(&mut self) {
        self.is_from_external_source = ::std::option::Option::None;
    }

    pub fn has_is_from_external_source(&self) -> bool {
        self.is_from_external_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_from_external_source(&mut self, v: bool) {
        self.is_from_external_source = ::std::option::Option::Some(v);
    }

    // optional uint32 cm_sysid = 28;

    pub fn cm_sysid(&self) -> u32 {
        self.cm_sysid.unwrap_or(0)
    }

    pub fn clear_cm_sysid(&mut self) {
        self.cm_sysid = ::std::option::Option::None;
    }

    pub fn has_cm_sysid(&self) -> bool {
        self.cm_sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cm_sysid(&mut self, v: u32) {
        self.cm_sysid = ::std::option::Option::Some(v);
    }

    // optional uint32 launcher_type = 31;

    pub fn launcher_type(&self) -> u32 {
        self.launcher_type.unwrap_or(0u32)
    }

    pub fn clear_launcher_type(&mut self) {
        self.launcher_type = ::std::option::Option::None;
    }

    pub fn has_launcher_type(&self) -> bool {
        self.launcher_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher_type(&mut self, v: u32) {
        self.launcher_type = ::std::option::Option::Some(v);
    }

    // optional uint32 realm = 32;

    pub fn realm(&self) -> u32 {
        self.realm.unwrap_or(0u32)
    }

    pub fn clear_realm(&mut self) {
        self.realm = ::std::option::Option::None;
    }

    pub fn has_realm(&self) -> bool {
        self.realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realm(&mut self, v: u32) {
        self.realm = ::std::option::Option::Some(v);
    }

    // optional int32 timeout_ms = 33;

    pub fn timeout_ms(&self) -> i32 {
        self.timeout_ms.unwrap_or(-1i32)
    }

    pub fn clear_timeout_ms(&mut self) {
        self.timeout_ms = ::std::option::Option::None;
    }

    pub fn has_timeout_ms(&self) -> bool {
        self.timeout_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ms(&mut self, v: i32) {
        self.timeout_ms = ::std::option::Option::Some(v);
    }

    // optional string debug_source = 34;

    pub fn debug_source(&self) -> &str {
        match self.debug_source.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_source(&mut self) {
        self.debug_source = ::std::option::Option::None;
    }

    pub fn has_debug_source(&self) -> bool {
        self.debug_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_source(&mut self, v: ::std::string::String) {
        self.debug_source = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_source(&mut self) -> &mut ::std::string::String {
        if self.debug_source.is_none() {
            self.debug_source = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_source(&mut self) -> ::std::string::String {
        self.debug_source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 debug_source_string_index = 35;

    pub fn debug_source_string_index(&self) -> u32 {
        self.debug_source_string_index.unwrap_or(0)
    }

    pub fn clear_debug_source_string_index(&mut self) {
        self.debug_source_string_index = ::std::option::Option::None;
    }

    pub fn has_debug_source_string_index(&self) -> bool {
        self.debug_source_string_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_source_string_index(&mut self, v: u32) {
        self.debug_source_string_index = ::std::option::Option::Some(v);
    }

    // optional uint64 token_id = 36;

    pub fn token_id(&self) -> u64 {
        self.token_id.unwrap_or(0)
    }

    pub fn clear_token_id(&mut self) {
        self.token_id = ::std::option::Option::None;
    }

    pub fn has_token_id(&self) -> bool {
        self.token_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: u64) {
        self.token_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ip = 15;

    pub fn ip(&self) -> u32 {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_ip(&mut self) {
        self.ip_addr = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(v))
    }

    // optional bytes ip_v6 = 29;

    pub fn ip_v6(&self) -> &[u8] {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(ref v)) => v,
            _ => &[],
        }
    }

    pub fn clear_ip_v6(&mut self) {
        self.ip_addr = ::std::option::Option::None;
    }

    pub fn has_ip_v6(&self) -> bool {
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ip_v6(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ip_v6(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(_)) = self.ip_addr {
        } else {
            self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(::std::vec::Vec::new()));
        }
        match self.ip_addr {
            ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ip_v6(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_ip_v6() {
            match self.ip_addr.take() {
                ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(30);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgProtoBufHeader| { &m.steamid },
            |m: &mut CMsgProtoBufHeader| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_sessionid",
            |m: &CMsgProtoBufHeader| { &m.client_sessionid },
            |m: &mut CMsgProtoBufHeader| { &mut m.client_sessionid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "routing_appid",
            |m: &CMsgProtoBufHeader| { &m.routing_appid },
            |m: &mut CMsgProtoBufHeader| { &mut m.routing_appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jobid_source",
            |m: &CMsgProtoBufHeader| { &m.jobid_source },
            |m: &mut CMsgProtoBufHeader| { &mut m.jobid_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jobid_target",
            |m: &CMsgProtoBufHeader| { &m.jobid_target },
            |m: &mut CMsgProtoBufHeader| { &mut m.jobid_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_job_name",
            |m: &CMsgProtoBufHeader| { &m.target_job_name },
            |m: &mut CMsgProtoBufHeader| { &mut m.target_job_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num",
            |m: &CMsgProtoBufHeader| { &m.seq_num },
            |m: &mut CMsgProtoBufHeader| { &mut m.seq_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgProtoBufHeader| { &m.eresult },
            |m: &mut CMsgProtoBufHeader| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_message",
            |m: &CMsgProtoBufHeader| { &m.error_message },
            |m: &mut CMsgProtoBufHeader| { &mut m.error_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "auth_account_flags",
            |m: &CMsgProtoBufHeader| { &m.auth_account_flags },
            |m: &mut CMsgProtoBufHeader| { &mut m.auth_account_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token_source",
            |m: &CMsgProtoBufHeader| { &m.token_source },
            |m: &mut CMsgProtoBufHeader| { &mut m.token_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "admin_spoofing_user",
            |m: &CMsgProtoBufHeader| { &m.admin_spoofing_user },
            |m: &mut CMsgProtoBufHeader| { &mut m.admin_spoofing_user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport_error",
            |m: &CMsgProtoBufHeader| { &m.transport_error },
            |m: &mut CMsgProtoBufHeader| { &mut m.transport_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messageid",
            |m: &CMsgProtoBufHeader| { &m.messageid },
            |m: &mut CMsgProtoBufHeader| { &mut m.messageid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "publisher_group_id",
            |m: &CMsgProtoBufHeader| { &m.publisher_group_id },
            |m: &mut CMsgProtoBufHeader| { &mut m.publisher_group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sysid",
            |m: &CMsgProtoBufHeader| { &m.sysid },
            |m: &mut CMsgProtoBufHeader| { &mut m.sysid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trace_tag",
            |m: &CMsgProtoBufHeader| { &m.trace_tag },
            |m: &mut CMsgProtoBufHeader| { &mut m.trace_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "webapi_key_id",
            |m: &CMsgProtoBufHeader| { &m.webapi_key_id },
            |m: &mut CMsgProtoBufHeader| { &mut m.webapi_key_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_from_external_source",
            |m: &CMsgProtoBufHeader| { &m.is_from_external_source },
            |m: &mut CMsgProtoBufHeader| { &mut m.is_from_external_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "forward_to_sysid",
            |m: &CMsgProtoBufHeader| { &m.forward_to_sysid },
            |m: &mut CMsgProtoBufHeader| { &mut m.forward_to_sysid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cm_sysid",
            |m: &CMsgProtoBufHeader| { &m.cm_sysid },
            |m: &mut CMsgProtoBufHeader| { &mut m.cm_sysid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "launcher_type",
            |m: &CMsgProtoBufHeader| { &m.launcher_type },
            |m: &mut CMsgProtoBufHeader| { &mut m.launcher_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "realm",
            |m: &CMsgProtoBufHeader| { &m.realm },
            |m: &mut CMsgProtoBufHeader| { &mut m.realm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout_ms",
            |m: &CMsgProtoBufHeader| { &m.timeout_ms },
            |m: &mut CMsgProtoBufHeader| { &mut m.timeout_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_source",
            |m: &CMsgProtoBufHeader| { &m.debug_source },
            |m: &mut CMsgProtoBufHeader| { &mut m.debug_source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_source_string_index",
            |m: &CMsgProtoBufHeader| { &m.debug_source_string_index },
            |m: &mut CMsgProtoBufHeader| { &mut m.debug_source_string_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token_id",
            |m: &CMsgProtoBufHeader| { &m.token_id },
            |m: &mut CMsgProtoBufHeader| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCRoutingProtoBufHeader>(
            "routing_gc",
            |m: &CMsgProtoBufHeader| { &m.routing_gc },
            |m: &mut CMsgProtoBufHeader| { &mut m.routing_gc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "ip",
            CMsgProtoBufHeader::has_ip,
            CMsgProtoBufHeader::ip,
            CMsgProtoBufHeader::set_ip,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "ip_v6",
            CMsgProtoBufHeader::has_ip_v6,
            CMsgProtoBufHeader::ip_v6,
            CMsgProtoBufHeader::set_ip_v6,
        ));
        oneofs.push(cmsg_proto_buf_header::Ip_addr::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgProtoBufHeader>(
            "CMsgProtoBufHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgProtoBufHeader {
    const NAME: &'static str = "CMsgProtoBufHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.client_sessionid = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.routing_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                81 => {
                    self.jobid_source = ::std::option::Option::Some(is.read_fixed64()?);
                },
                89 => {
                    self.jobid_target = ::std::option::Option::Some(is.read_fixed64()?);
                },
                98 => {
                    self.target_job_name = ::std::option::Option::Some(is.read_string()?);
                },
                192 => {
                    self.seq_num = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                114 => {
                    self.error_message = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.auth_account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.token_source = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.admin_spoofing_user = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.transport_error = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.messageid = ::std::option::Option::Some(is.read_uint64()?);
                },
                152 => {
                    self.publisher_group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.sysid = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.trace_tag = ::std::option::Option::Some(is.read_uint64()?);
                },
                200 => {
                    self.webapi_key_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.is_from_external_source = ::std::option::Option::Some(is.read_bool()?);
                },
                218 => {
                    is.read_repeated_packed_uint32_into(&mut self.forward_to_sysid)?;
                },
                216 => {
                    self.forward_to_sysid.push(is.read_uint32()?);
                },
                224 => {
                    self.cm_sysid = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.launcher_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.realm = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.timeout_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                274 => {
                    self.debug_source = ::std::option::Option::Some(is.read_string()?);
                },
                280 => {
                    self.debug_source_string_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                288 => {
                    self.token_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                298 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.routing_gc)?;
                },
                120 => {
                    self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::Ip(is.read_uint32()?));
                },
                234 => {
                    self.ip_addr = ::std::option::Option::Some(cmsg_proto_buf_header::Ip_addr::IpV6(is.read_bytes()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_sessionid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.routing_appid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.jobid_source {
            my_size += 1 + 8;
        }
        if let Some(v) = self.jobid_target {
            my_size += 1 + 8;
        }
        if let Some(v) = self.target_job_name.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.seq_num {
            my_size += ::protobuf::rt::int32_size(24, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.auth_account_flags {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.token_source {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.admin_spoofing_user {
            my_size += 2 + 1;
        }
        if let Some(v) = self.transport_error {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.messageid {
            my_size += ::protobuf::rt::uint64_size(18, v);
        }
        if let Some(v) = self.publisher_group_id {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.sysid {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.trace_tag {
            my_size += ::protobuf::rt::uint64_size(21, v);
        }
        if let Some(v) = self.webapi_key_id {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.is_from_external_source {
            my_size += 2 + 1;
        }
        for value in &self.forward_to_sysid {
            my_size += ::protobuf::rt::uint32_size(27, *value);
        };
        if let Some(v) = self.cm_sysid {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.launcher_type {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.realm {
            my_size += ::protobuf::rt::uint32_size(32, v);
        }
        if let Some(v) = self.timeout_ms {
            my_size += ::protobuf::rt::int32_size(33, v);
        }
        if let Some(v) = self.debug_source.as_ref() {
            my_size += ::protobuf::rt::string_size(34, &v);
        }
        if let Some(v) = self.debug_source_string_index {
            my_size += ::protobuf::rt::uint32_size(35, v);
        }
        if let Some(v) = self.token_id {
            my_size += ::protobuf::rt::uint64_size(36, v);
        }
        if let Some(v) = self.routing_gc.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.ip_addr {
            match v {
                &cmsg_proto_buf_header::Ip_addr::Ip(v) => {
                    my_size += ::protobuf::rt::uint32_size(15, v);
                },
                &cmsg_proto_buf_header::Ip_addr::IpV6(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(29, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_sessionid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.routing_appid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.jobid_source {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.jobid_target {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.target_job_name.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.seq_num {
            os.write_int32(24, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.error_message.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.auth_account_flags {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.token_source {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.admin_spoofing_user {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.transport_error {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.messageid {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.publisher_group_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.sysid {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.trace_tag {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.webapi_key_id {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.is_from_external_source {
            os.write_bool(26, v)?;
        }
        for v in &self.forward_to_sysid {
            os.write_uint32(27, *v)?;
        };
        if let Some(v) = self.cm_sysid {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.launcher_type {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.realm {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.timeout_ms {
            os.write_int32(33, v)?;
        }
        if let Some(v) = self.debug_source.as_ref() {
            os.write_string(34, v)?;
        }
        if let Some(v) = self.debug_source_string_index {
            os.write_uint32(35, v)?;
        }
        if let Some(v) = self.token_id {
            os.write_uint64(36, v)?;
        }
        if let Some(v) = self.routing_gc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.ip_addr {
            match v {
                &cmsg_proto_buf_header::Ip_addr::Ip(v) => {
                    os.write_uint32(15, v)?;
                },
                &cmsg_proto_buf_header::Ip_addr::IpV6(ref v) => {
                    os.write_bytes(29, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtoBufHeader {
        CMsgProtoBufHeader::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.client_sessionid = ::std::option::Option::None;
        self.routing_appid = ::std::option::Option::None;
        self.jobid_source = ::std::option::Option::None;
        self.jobid_target = ::std::option::Option::None;
        self.target_job_name = ::std::option::Option::None;
        self.seq_num = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.error_message = ::std::option::Option::None;
        self.auth_account_flags = ::std::option::Option::None;
        self.token_source = ::std::option::Option::None;
        self.admin_spoofing_user = ::std::option::Option::None;
        self.transport_error = ::std::option::Option::None;
        self.messageid = ::std::option::Option::None;
        self.publisher_group_id = ::std::option::Option::None;
        self.sysid = ::std::option::Option::None;
        self.trace_tag = ::std::option::Option::None;
        self.webapi_key_id = ::std::option::Option::None;
        self.is_from_external_source = ::std::option::Option::None;
        self.forward_to_sysid.clear();
        self.cm_sysid = ::std::option::Option::None;
        self.launcher_type = ::std::option::Option::None;
        self.realm = ::std::option::Option::None;
        self.timeout_ms = ::std::option::Option::None;
        self.debug_source = ::std::option::Option::None;
        self.debug_source_string_index = ::std::option::Option::None;
        self.token_id = ::std::option::Option::None;
        self.routing_gc.clear();
        self.ip_addr = ::std::option::Option::None;
        self.ip_addr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtoBufHeader {
        static instance: CMsgProtoBufHeader = CMsgProtoBufHeader {
            steamid: ::std::option::Option::None,
            client_sessionid: ::std::option::Option::None,
            routing_appid: ::std::option::Option::None,
            jobid_source: ::std::option::Option::None,
            jobid_target: ::std::option::Option::None,
            target_job_name: ::std::option::Option::None,
            seq_num: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            error_message: ::std::option::Option::None,
            auth_account_flags: ::std::option::Option::None,
            token_source: ::std::option::Option::None,
            admin_spoofing_user: ::std::option::Option::None,
            transport_error: ::std::option::Option::None,
            messageid: ::std::option::Option::None,
            publisher_group_id: ::std::option::Option::None,
            sysid: ::std::option::Option::None,
            trace_tag: ::std::option::Option::None,
            webapi_key_id: ::std::option::Option::None,
            is_from_external_source: ::std::option::Option::None,
            forward_to_sysid: ::std::vec::Vec::new(),
            cm_sysid: ::std::option::Option::None,
            launcher_type: ::std::option::Option::None,
            realm: ::std::option::Option::None,
            timeout_ms: ::std::option::Option::None,
            debug_source: ::std::option::Option::None,
            debug_source_string_index: ::std::option::Option::None,
            token_id: ::std::option::Option::None,
            routing_gc: ::protobuf::MessageField::none(),
            ip_addr: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgProtoBufHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgProtoBufHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgProtoBufHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProtoBufHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgProtoBufHeader`
pub mod cmsg_proto_buf_header {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CMsgProtoBufHeader.ip_addr)
    pub enum Ip_addr {
        // @@protoc_insertion_point(oneof_field:CMsgProtoBufHeader.ip)
        Ip(u32),
        // @@protoc_insertion_point(oneof_field:CMsgProtoBufHeader.ip_v6)
        IpV6(::std::vec::Vec<u8>),
    }

    impl ::protobuf::Oneof for Ip_addr {
    }

    impl ::protobuf::OneofFull for Ip_addr {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CMsgProtoBufHeader as ::protobuf::MessageFull>::descriptor().oneof_by_name("ip_addr").unwrap()).clone()
        }
    }

    impl Ip_addr {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Ip_addr>("ip_addr")
        }
    }
}

// @@protoc_insertion_point(message:CMsgMulti)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMulti {
    // message fields
    // @@protoc_insertion_point(field:CMsgMulti.size_unzipped)
    pub size_unzipped: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMulti.message_body)
    pub message_body: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMulti.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMulti {
    fn default() -> &'a CMsgMulti {
        <CMsgMulti as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMulti {
    pub fn new() -> CMsgMulti {
        ::std::default::Default::default()
    }

    // optional uint32 size_unzipped = 1;

    pub fn size_unzipped(&self) -> u32 {
        self.size_unzipped.unwrap_or(0)
    }

    pub fn clear_size_unzipped(&mut self) {
        self.size_unzipped = ::std::option::Option::None;
    }

    pub fn has_size_unzipped(&self) -> bool {
        self.size_unzipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_unzipped(&mut self, v: u32) {
        self.size_unzipped = ::std::option::Option::Some(v);
    }

    // optional bytes message_body = 2;

    pub fn message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_body(&mut self) {
        self.message_body = ::std::option::Option::None;
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_body.is_none() {
            self.message_body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::std::vec::Vec<u8> {
        self.message_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_unzipped",
            |m: &CMsgMulti| { &m.size_unzipped },
            |m: &mut CMsgMulti| { &mut m.size_unzipped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_body",
            |m: &CMsgMulti| { &m.message_body },
            |m: &mut CMsgMulti| { &mut m.message_body },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgMulti>(
            "CMsgMulti",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgMulti {
    const NAME: &'static str = "CMsgMulti";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.size_unzipped = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message_body = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.size_unzipped {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message_body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.size_unzipped {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message_body.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMulti {
        CMsgMulti::new()
    }

    fn clear(&mut self) {
        self.size_unzipped = ::std::option::Option::None;
        self.message_body = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMulti {
        static instance: CMsgMulti = CMsgMulti {
            size_unzipped: ::std::option::Option::None,
            message_body: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgMulti {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgMulti").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgMulti {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMulti {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgProtobufWrapped)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProtobufWrapped {
    // message fields
    // @@protoc_insertion_point(field:CMsgProtobufWrapped.message_body)
    pub message_body: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProtobufWrapped.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProtobufWrapped {
    fn default() -> &'a CMsgProtobufWrapped {
        <CMsgProtobufWrapped as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProtobufWrapped {
    pub fn new() -> CMsgProtobufWrapped {
        ::std::default::Default::default()
    }

    // optional bytes message_body = 1;

    pub fn message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_message_body(&mut self) {
        self.message_body = ::std::option::Option::None;
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_body.is_none() {
            self.message_body = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::std::vec::Vec<u8> {
        self.message_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_body",
            |m: &CMsgProtobufWrapped| { &m.message_body },
            |m: &mut CMsgProtobufWrapped| { &mut m.message_body },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgProtobufWrapped>(
            "CMsgProtobufWrapped",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgProtobufWrapped {
    const NAME: &'static str = "CMsgProtobufWrapped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message_body = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_body.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProtobufWrapped {
        CMsgProtobufWrapped::new()
    }

    fn clear(&mut self) {
        self.message_body = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProtobufWrapped {
        static instance: CMsgProtobufWrapped = CMsgProtobufWrapped {
            message_body: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgProtobufWrapped {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgProtobufWrapped").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgProtobufWrapped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProtobufWrapped {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAuthTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAuthTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgAuthTicket.estate)
    pub estate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.eresult)
    pub eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.h_steam_pipe)
    pub h_steam_pipe: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.ticket_crc)
    pub ticket_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.ticket)
    pub ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgAuthTicket.server_secret)
    pub server_secret: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAuthTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAuthTicket {
    fn default() -> &'a CMsgAuthTicket {
        <CMsgAuthTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAuthTicket {
    pub fn new() -> CMsgAuthTicket {
        ::std::default::Default::default()
    }

    // optional uint32 estate = 1;

    pub fn estate(&self) -> u32 {
        self.estate.unwrap_or(0)
    }

    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameid = 4;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 h_steam_pipe = 5;

    pub fn h_steam_pipe(&self) -> u32 {
        self.h_steam_pipe.unwrap_or(0)
    }

    pub fn clear_h_steam_pipe(&mut self) {
        self.h_steam_pipe = ::std::option::Option::None;
    }

    pub fn has_h_steam_pipe(&self) -> bool {
        self.h_steam_pipe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_h_steam_pipe(&mut self, v: u32) {
        self.h_steam_pipe = ::std::option::Option::Some(v);
    }

    // optional uint32 ticket_crc = 6;

    pub fn ticket_crc(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 7;

    pub fn ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes server_secret = 8;

    pub fn server_secret(&self) -> &[u8] {
        match self.server_secret.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_server_secret(&mut self) {
        self.server_secret = ::std::option::Option::None;
    }

    pub fn has_server_secret(&self) -> bool {
        self.server_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_secret(&mut self, v: ::std::vec::Vec<u8>) {
        self.server_secret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_secret(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.server_secret.is_none() {
            self.server_secret = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.server_secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_secret(&mut self) -> ::std::vec::Vec<u8> {
        self.server_secret.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "estate",
            |m: &CMsgAuthTicket| { &m.estate },
            |m: &mut CMsgAuthTicket| { &mut m.estate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CMsgAuthTicket| { &m.eresult },
            |m: &mut CMsgAuthTicket| { &mut m.eresult },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgAuthTicket| { &m.steamid },
            |m: &mut CMsgAuthTicket| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CMsgAuthTicket| { &m.gameid },
            |m: &mut CMsgAuthTicket| { &mut m.gameid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "h_steam_pipe",
            |m: &CMsgAuthTicket| { &m.h_steam_pipe },
            |m: &mut CMsgAuthTicket| { &mut m.h_steam_pipe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket_crc",
            |m: &CMsgAuthTicket| { &m.ticket_crc },
            |m: &mut CMsgAuthTicket| { &mut m.ticket_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgAuthTicket| { &m.ticket },
            |m: &mut CMsgAuthTicket| { &mut m.ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_secret",
            |m: &CMsgAuthTicket| { &m.server_secret },
            |m: &mut CMsgAuthTicket| { &mut m.server_secret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAuthTicket>(
            "CMsgAuthTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAuthTicket {
    const NAME: &'static str = "CMsgAuthTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.estate = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                25 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                33 => {
                    self.gameid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.h_steam_pipe = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.ticket_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.server_secret = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.estate {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.h_steam_pipe {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.ticket_crc {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.server_secret.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.estate {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.h_steam_pipe {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ticket_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.server_secret.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAuthTicket {
        CMsgAuthTicket::new()
    }

    fn clear(&mut self) {
        self.estate = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.h_steam_pipe = ::std::option::Option::None;
        self.ticket_crc = ::std::option::Option::None;
        self.ticket = ::std::option::Option::None;
        self.server_secret = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAuthTicket {
        static instance: CMsgAuthTicket = CMsgAuthTicket {
            estate: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            h_steam_pipe: ::std::option::Option::None,
            ticket_crc: ::std::option::Option::None,
            ticket: ::std::option::Option::None,
            server_secret: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAuthTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAuthTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAuthTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAuthTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCDDBAppDetailCommon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCDDBAppDetailCommon {
    // message fields
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.tool)
    pub tool: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.demo)
    pub demo: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.media)
    pub media: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.community_visible_stats)
    pub community_visible_stats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.friendly_name)
    pub friendly_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.propagation)
    pub propagation: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.has_adult_content)
    pub has_adult_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.is_visible_in_steam_china)
    pub is_visible_in_steam_china: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.app_type)
    pub app_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.has_adult_content_sex)
    pub has_adult_content_sex: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.has_adult_content_violence)
    pub has_adult_content_violence: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCDDBAppDetailCommon.content_descriptorids)
    pub content_descriptorids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCDDBAppDetailCommon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCDDBAppDetailCommon {
    fn default() -> &'a CCDDBAppDetailCommon {
        <CCDDBAppDetailCommon as ::protobuf::Message>::default_instance()
    }
}

impl CCDDBAppDetailCommon {
    pub fn new() -> CCDDBAppDetailCommon {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 3;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool tool = 6;

    pub fn tool(&self) -> bool {
        self.tool.unwrap_or(false)
    }

    pub fn clear_tool(&mut self) {
        self.tool = ::std::option::Option::None;
    }

    pub fn has_tool(&self) -> bool {
        self.tool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool(&mut self, v: bool) {
        self.tool = ::std::option::Option::Some(v);
    }

    // optional bool demo = 7;

    pub fn demo(&self) -> bool {
        self.demo.unwrap_or(false)
    }

    pub fn clear_demo(&mut self) {
        self.demo = ::std::option::Option::None;
    }

    pub fn has_demo(&self) -> bool {
        self.demo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo(&mut self, v: bool) {
        self.demo = ::std::option::Option::Some(v);
    }

    // optional bool media = 8;

    pub fn media(&self) -> bool {
        self.media.unwrap_or(false)
    }

    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    // optional bool community_visible_stats = 9;

    pub fn community_visible_stats(&self) -> bool {
        self.community_visible_stats.unwrap_or(false)
    }

    pub fn clear_community_visible_stats(&mut self) {
        self.community_visible_stats = ::std::option::Option::None;
    }

    pub fn has_community_visible_stats(&self) -> bool {
        self.community_visible_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_community_visible_stats(&mut self, v: bool) {
        self.community_visible_stats = ::std::option::Option::Some(v);
    }

    // optional string friendly_name = 10;

    pub fn friendly_name(&self) -> &str {
        match self.friendly_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_friendly_name(&mut self) {
        self.friendly_name = ::std::option::Option::None;
    }

    pub fn has_friendly_name(&self) -> bool {
        self.friendly_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendly_name(&mut self, v: ::std::string::String) {
        self.friendly_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friendly_name(&mut self) -> &mut ::std::string::String {
        if self.friendly_name.is_none() {
            self.friendly_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.friendly_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_friendly_name(&mut self) -> ::std::string::String {
        self.friendly_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string propagation = 11;

    pub fn propagation(&self) -> &str {
        match self.propagation.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_propagation(&mut self) {
        self.propagation = ::std::option::Option::None;
    }

    pub fn has_propagation(&self) -> bool {
        self.propagation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propagation(&mut self, v: ::std::string::String) {
        self.propagation = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propagation(&mut self) -> &mut ::std::string::String {
        if self.propagation.is_none() {
            self.propagation = ::std::option::Option::Some(::std::string::String::new());
        }
        self.propagation.as_mut().unwrap()
    }

    // Take field
    pub fn take_propagation(&mut self) -> ::std::string::String {
        self.propagation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool has_adult_content = 12;

    pub fn has_adult_content(&self) -> bool {
        self.has_adult_content.unwrap_or(false)
    }

    pub fn clear_has_adult_content(&mut self) {
        self.has_adult_content = ::std::option::Option::None;
    }

    pub fn has_has_adult_content(&self) -> bool {
        self.has_adult_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content(&mut self, v: bool) {
        self.has_adult_content = ::std::option::Option::Some(v);
    }

    // optional bool is_visible_in_steam_china = 13;

    pub fn is_visible_in_steam_china(&self) -> bool {
        self.is_visible_in_steam_china.unwrap_or(false)
    }

    pub fn clear_is_visible_in_steam_china(&mut self) {
        self.is_visible_in_steam_china = ::std::option::Option::None;
    }

    pub fn has_is_visible_in_steam_china(&self) -> bool {
        self.is_visible_in_steam_china.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_visible_in_steam_china(&mut self, v: bool) {
        self.is_visible_in_steam_china = ::std::option::Option::Some(v);
    }

    // optional uint32 app_type = 14;

    pub fn app_type(&self) -> u32 {
        self.app_type.unwrap_or(0)
    }

    pub fn clear_app_type(&mut self) {
        self.app_type = ::std::option::Option::None;
    }

    pub fn has_app_type(&self) -> bool {
        self.app_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_type(&mut self, v: u32) {
        self.app_type = ::std::option::Option::Some(v);
    }

    // optional bool has_adult_content_sex = 15;

    pub fn has_adult_content_sex(&self) -> bool {
        self.has_adult_content_sex.unwrap_or(false)
    }

    pub fn clear_has_adult_content_sex(&mut self) {
        self.has_adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_has_adult_content_sex(&self) -> bool {
        self.has_adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content_sex(&mut self, v: bool) {
        self.has_adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional bool has_adult_content_violence = 16;

    pub fn has_adult_content_violence(&self) -> bool {
        self.has_adult_content_violence.unwrap_or(false)
    }

    pub fn clear_has_adult_content_violence(&mut self) {
        self.has_adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_has_adult_content_violence(&self) -> bool {
        self.has_adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content_violence(&mut self, v: bool) {
        self.has_adult_content_violence = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CCDDBAppDetailCommon| { &m.appid },
            |m: &mut CCDDBAppDetailCommon| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CCDDBAppDetailCommon| { &m.name },
            |m: &mut CCDDBAppDetailCommon| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon",
            |m: &CCDDBAppDetailCommon| { &m.icon },
            |m: &mut CCDDBAppDetailCommon| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tool",
            |m: &CCDDBAppDetailCommon| { &m.tool },
            |m: &mut CCDDBAppDetailCommon| { &mut m.tool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "demo",
            |m: &CCDDBAppDetailCommon| { &m.demo },
            |m: &mut CCDDBAppDetailCommon| { &mut m.demo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "media",
            |m: &CCDDBAppDetailCommon| { &m.media },
            |m: &mut CCDDBAppDetailCommon| { &mut m.media },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "community_visible_stats",
            |m: &CCDDBAppDetailCommon| { &m.community_visible_stats },
            |m: &mut CCDDBAppDetailCommon| { &mut m.community_visible_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friendly_name",
            |m: &CCDDBAppDetailCommon| { &m.friendly_name },
            |m: &mut CCDDBAppDetailCommon| { &mut m.friendly_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "propagation",
            |m: &CCDDBAppDetailCommon| { &m.propagation },
            |m: &mut CCDDBAppDetailCommon| { &mut m.propagation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_adult_content",
            |m: &CCDDBAppDetailCommon| { &m.has_adult_content },
            |m: &mut CCDDBAppDetailCommon| { &mut m.has_adult_content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_visible_in_steam_china",
            |m: &CCDDBAppDetailCommon| { &m.is_visible_in_steam_china },
            |m: &mut CCDDBAppDetailCommon| { &mut m.is_visible_in_steam_china },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_type",
            |m: &CCDDBAppDetailCommon| { &m.app_type },
            |m: &mut CCDDBAppDetailCommon| { &mut m.app_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_adult_content_sex",
            |m: &CCDDBAppDetailCommon| { &m.has_adult_content_sex },
            |m: &mut CCDDBAppDetailCommon| { &mut m.has_adult_content_sex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_adult_content_violence",
            |m: &CCDDBAppDetailCommon| { &m.has_adult_content_violence },
            |m: &mut CCDDBAppDetailCommon| { &mut m.has_adult_content_violence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_descriptorids",
            |m: &CCDDBAppDetailCommon| { &m.content_descriptorids },
            |m: &mut CCDDBAppDetailCommon| { &mut m.content_descriptorids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCDDBAppDetailCommon>(
            "CCDDBAppDetailCommon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCDDBAppDetailCommon {
    const NAME: &'static str = "CCDDBAppDetailCommon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.tool = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.demo = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.media = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.community_visible_stats = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.friendly_name = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.propagation = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.has_adult_content = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.is_visible_in_steam_china = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.app_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.has_adult_content_sex = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.has_adult_content_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    is.read_repeated_packed_uint32_into(&mut self.content_descriptorids)?;
                },
                136 => {
                    self.content_descriptorids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.tool {
            my_size += 1 + 1;
        }
        if let Some(v) = self.demo {
            my_size += 1 + 1;
        }
        if let Some(v) = self.media {
            my_size += 1 + 1;
        }
        if let Some(v) = self.community_visible_stats {
            my_size += 1 + 1;
        }
        if let Some(v) = self.friendly_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.propagation.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.has_adult_content {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_visible_in_steam_china {
            my_size += 1 + 1;
        }
        if let Some(v) = self.app_type {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.has_adult_content_sex {
            my_size += 1 + 1;
        }
        if let Some(v) = self.has_adult_content_violence {
            my_size += 2 + 1;
        }
        for value in &self.content_descriptorids {
            my_size += ::protobuf::rt::uint32_size(17, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.tool {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.demo {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.media {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.community_visible_stats {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.friendly_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.propagation.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.has_adult_content {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.is_visible_in_steam_china {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.app_type {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.has_adult_content_sex {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.has_adult_content_violence {
            os.write_bool(16, v)?;
        }
        for v in &self.content_descriptorids {
            os.write_uint32(17, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCDDBAppDetailCommon {
        CCDDBAppDetailCommon::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.tool = ::std::option::Option::None;
        self.demo = ::std::option::Option::None;
        self.media = ::std::option::Option::None;
        self.community_visible_stats = ::std::option::Option::None;
        self.friendly_name = ::std::option::Option::None;
        self.propagation = ::std::option::Option::None;
        self.has_adult_content = ::std::option::Option::None;
        self.is_visible_in_steam_china = ::std::option::Option::None;
        self.app_type = ::std::option::Option::None;
        self.has_adult_content_sex = ::std::option::Option::None;
        self.has_adult_content_violence = ::std::option::Option::None;
        self.content_descriptorids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCDDBAppDetailCommon {
        static instance: CCDDBAppDetailCommon = CCDDBAppDetailCommon {
            appid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            tool: ::std::option::Option::None,
            demo: ::std::option::Option::None,
            media: ::std::option::Option::None,
            community_visible_stats: ::std::option::Option::None,
            friendly_name: ::std::option::Option::None,
            propagation: ::std::option::Option::None,
            has_adult_content: ::std::option::Option::None,
            is_visible_in_steam_china: ::std::option::Option::None,
            app_type: ::std::option::Option::None,
            has_adult_content_sex: ::std::option::Option::None,
            has_adult_content_violence: ::std::option::Option::None,
            content_descriptorids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCDDBAppDetailCommon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCDDBAppDetailCommon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCDDBAppDetailCommon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCDDBAppDetailCommon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAppRights)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAppRights {
    // message fields
    // @@protoc_insertion_point(field:CMsgAppRights.edit_info)
    pub edit_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.publish)
    pub publish: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.view_error_data)
    pub view_error_data: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.download)
    pub download: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.upload_cdkeys)
    pub upload_cdkeys: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.generate_cdkeys)
    pub generate_cdkeys: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.view_financials)
    pub view_financials: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_ceg)
    pub manage_ceg: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_signing)
    pub manage_signing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_cdkeys)
    pub manage_cdkeys: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.edit_marketing)
    pub edit_marketing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.economy_support)
    pub economy_support: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.economy_support_supervisor)
    pub economy_support_supervisor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.manage_pricing)
    pub manage_pricing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.broadcast_live)
    pub broadcast_live: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.view_marketing_traffic)
    pub view_marketing_traffic: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAppRights.edit_store_display_content)
    pub edit_store_display_content: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAppRights.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAppRights {
    fn default() -> &'a CMsgAppRights {
        <CMsgAppRights as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAppRights {
    pub fn new() -> CMsgAppRights {
        ::std::default::Default::default()
    }

    // optional bool edit_info = 1;

    pub fn edit_info(&self) -> bool {
        self.edit_info.unwrap_or(false)
    }

    pub fn clear_edit_info(&mut self) {
        self.edit_info = ::std::option::Option::None;
    }

    pub fn has_edit_info(&self) -> bool {
        self.edit_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_info(&mut self, v: bool) {
        self.edit_info = ::std::option::Option::Some(v);
    }

    // optional bool publish = 2;

    pub fn publish(&self) -> bool {
        self.publish.unwrap_or(false)
    }

    pub fn clear_publish(&mut self) {
        self.publish = ::std::option::Option::None;
    }

    pub fn has_publish(&self) -> bool {
        self.publish.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: bool) {
        self.publish = ::std::option::Option::Some(v);
    }

    // optional bool view_error_data = 3;

    pub fn view_error_data(&self) -> bool {
        self.view_error_data.unwrap_or(false)
    }

    pub fn clear_view_error_data(&mut self) {
        self.view_error_data = ::std::option::Option::None;
    }

    pub fn has_view_error_data(&self) -> bool {
        self.view_error_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_error_data(&mut self, v: bool) {
        self.view_error_data = ::std::option::Option::Some(v);
    }

    // optional bool download = 4;

    pub fn download(&self) -> bool {
        self.download.unwrap_or(false)
    }

    pub fn clear_download(&mut self) {
        self.download = ::std::option::Option::None;
    }

    pub fn has_download(&self) -> bool {
        self.download.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download(&mut self, v: bool) {
        self.download = ::std::option::Option::Some(v);
    }

    // optional bool upload_cdkeys = 5;

    pub fn upload_cdkeys(&self) -> bool {
        self.upload_cdkeys.unwrap_or(false)
    }

    pub fn clear_upload_cdkeys(&mut self) {
        self.upload_cdkeys = ::std::option::Option::None;
    }

    pub fn has_upload_cdkeys(&self) -> bool {
        self.upload_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_cdkeys(&mut self, v: bool) {
        self.upload_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool generate_cdkeys = 6;

    pub fn generate_cdkeys(&self) -> bool {
        self.generate_cdkeys.unwrap_or(false)
    }

    pub fn clear_generate_cdkeys(&mut self) {
        self.generate_cdkeys = ::std::option::Option::None;
    }

    pub fn has_generate_cdkeys(&self) -> bool {
        self.generate_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generate_cdkeys(&mut self, v: bool) {
        self.generate_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool view_financials = 7;

    pub fn view_financials(&self) -> bool {
        self.view_financials.unwrap_or(false)
    }

    pub fn clear_view_financials(&mut self) {
        self.view_financials = ::std::option::Option::None;
    }

    pub fn has_view_financials(&self) -> bool {
        self.view_financials.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_financials(&mut self, v: bool) {
        self.view_financials = ::std::option::Option::Some(v);
    }

    // optional bool manage_ceg = 8;

    pub fn manage_ceg(&self) -> bool {
        self.manage_ceg.unwrap_or(false)
    }

    pub fn clear_manage_ceg(&mut self) {
        self.manage_ceg = ::std::option::Option::None;
    }

    pub fn has_manage_ceg(&self) -> bool {
        self.manage_ceg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_ceg(&mut self, v: bool) {
        self.manage_ceg = ::std::option::Option::Some(v);
    }

    // optional bool manage_signing = 9;

    pub fn manage_signing(&self) -> bool {
        self.manage_signing.unwrap_or(false)
    }

    pub fn clear_manage_signing(&mut self) {
        self.manage_signing = ::std::option::Option::None;
    }

    pub fn has_manage_signing(&self) -> bool {
        self.manage_signing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_signing(&mut self, v: bool) {
        self.manage_signing = ::std::option::Option::Some(v);
    }

    // optional bool manage_cdkeys = 10;

    pub fn manage_cdkeys(&self) -> bool {
        self.manage_cdkeys.unwrap_or(false)
    }

    pub fn clear_manage_cdkeys(&mut self) {
        self.manage_cdkeys = ::std::option::Option::None;
    }

    pub fn has_manage_cdkeys(&self) -> bool {
        self.manage_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_cdkeys(&mut self, v: bool) {
        self.manage_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool edit_marketing = 11;

    pub fn edit_marketing(&self) -> bool {
        self.edit_marketing.unwrap_or(false)
    }

    pub fn clear_edit_marketing(&mut self) {
        self.edit_marketing = ::std::option::Option::None;
    }

    pub fn has_edit_marketing(&self) -> bool {
        self.edit_marketing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_marketing(&mut self, v: bool) {
        self.edit_marketing = ::std::option::Option::Some(v);
    }

    // optional bool economy_support = 12;

    pub fn economy_support(&self) -> bool {
        self.economy_support.unwrap_or(false)
    }

    pub fn clear_economy_support(&mut self) {
        self.economy_support = ::std::option::Option::None;
    }

    pub fn has_economy_support(&self) -> bool {
        self.economy_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_economy_support(&mut self, v: bool) {
        self.economy_support = ::std::option::Option::Some(v);
    }

    // optional bool economy_support_supervisor = 13;

    pub fn economy_support_supervisor(&self) -> bool {
        self.economy_support_supervisor.unwrap_or(false)
    }

    pub fn clear_economy_support_supervisor(&mut self) {
        self.economy_support_supervisor = ::std::option::Option::None;
    }

    pub fn has_economy_support_supervisor(&self) -> bool {
        self.economy_support_supervisor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_economy_support_supervisor(&mut self, v: bool) {
        self.economy_support_supervisor = ::std::option::Option::Some(v);
    }

    // optional bool manage_pricing = 14;

    pub fn manage_pricing(&self) -> bool {
        self.manage_pricing.unwrap_or(false)
    }

    pub fn clear_manage_pricing(&mut self) {
        self.manage_pricing = ::std::option::Option::None;
    }

    pub fn has_manage_pricing(&self) -> bool {
        self.manage_pricing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_pricing(&mut self, v: bool) {
        self.manage_pricing = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_live = 15;

    pub fn broadcast_live(&self) -> bool {
        self.broadcast_live.unwrap_or(false)
    }

    pub fn clear_broadcast_live(&mut self) {
        self.broadcast_live = ::std::option::Option::None;
    }

    pub fn has_broadcast_live(&self) -> bool {
        self.broadcast_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_live(&mut self, v: bool) {
        self.broadcast_live = ::std::option::Option::Some(v);
    }

    // optional bool view_marketing_traffic = 16;

    pub fn view_marketing_traffic(&self) -> bool {
        self.view_marketing_traffic.unwrap_or(false)
    }

    pub fn clear_view_marketing_traffic(&mut self) {
        self.view_marketing_traffic = ::std::option::Option::None;
    }

    pub fn has_view_marketing_traffic(&self) -> bool {
        self.view_marketing_traffic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_marketing_traffic(&mut self, v: bool) {
        self.view_marketing_traffic = ::std::option::Option::Some(v);
    }

    // optional bool edit_store_display_content = 17;

    pub fn edit_store_display_content(&self) -> bool {
        self.edit_store_display_content.unwrap_or(false)
    }

    pub fn clear_edit_store_display_content(&mut self) {
        self.edit_store_display_content = ::std::option::Option::None;
    }

    pub fn has_edit_store_display_content(&self) -> bool {
        self.edit_store_display_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_store_display_content(&mut self, v: bool) {
        self.edit_store_display_content = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "edit_info",
            |m: &CMsgAppRights| { &m.edit_info },
            |m: &mut CMsgAppRights| { &mut m.edit_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "publish",
            |m: &CMsgAppRights| { &m.publish },
            |m: &mut CMsgAppRights| { &mut m.publish },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_error_data",
            |m: &CMsgAppRights| { &m.view_error_data },
            |m: &mut CMsgAppRights| { &mut m.view_error_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "download",
            |m: &CMsgAppRights| { &m.download },
            |m: &mut CMsgAppRights| { &mut m.download },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upload_cdkeys",
            |m: &CMsgAppRights| { &m.upload_cdkeys },
            |m: &mut CMsgAppRights| { &mut m.upload_cdkeys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generate_cdkeys",
            |m: &CMsgAppRights| { &m.generate_cdkeys },
            |m: &mut CMsgAppRights| { &mut m.generate_cdkeys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_financials",
            |m: &CMsgAppRights| { &m.view_financials },
            |m: &mut CMsgAppRights| { &mut m.view_financials },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manage_ceg",
            |m: &CMsgAppRights| { &m.manage_ceg },
            |m: &mut CMsgAppRights| { &mut m.manage_ceg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manage_signing",
            |m: &CMsgAppRights| { &m.manage_signing },
            |m: &mut CMsgAppRights| { &mut m.manage_signing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manage_cdkeys",
            |m: &CMsgAppRights| { &m.manage_cdkeys },
            |m: &mut CMsgAppRights| { &mut m.manage_cdkeys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "edit_marketing",
            |m: &CMsgAppRights| { &m.edit_marketing },
            |m: &mut CMsgAppRights| { &mut m.edit_marketing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "economy_support",
            |m: &CMsgAppRights| { &m.economy_support },
            |m: &mut CMsgAppRights| { &mut m.economy_support },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "economy_support_supervisor",
            |m: &CMsgAppRights| { &m.economy_support_supervisor },
            |m: &mut CMsgAppRights| { &mut m.economy_support_supervisor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manage_pricing",
            |m: &CMsgAppRights| { &m.manage_pricing },
            |m: &mut CMsgAppRights| { &mut m.manage_pricing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_live",
            |m: &CMsgAppRights| { &m.broadcast_live },
            |m: &mut CMsgAppRights| { &mut m.broadcast_live },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_marketing_traffic",
            |m: &CMsgAppRights| { &m.view_marketing_traffic },
            |m: &mut CMsgAppRights| { &mut m.view_marketing_traffic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "edit_store_display_content",
            |m: &CMsgAppRights| { &m.edit_store_display_content },
            |m: &mut CMsgAppRights| { &mut m.edit_store_display_content },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAppRights>(
            "CMsgAppRights",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAppRights {
    const NAME: &'static str = "CMsgAppRights";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.edit_info = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.publish = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.view_error_data = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.download = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.upload_cdkeys = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.generate_cdkeys = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.view_financials = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.manage_ceg = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.manage_signing = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.manage_cdkeys = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.edit_marketing = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.economy_support = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.economy_support_supervisor = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.manage_pricing = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.broadcast_live = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.view_marketing_traffic = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.edit_store_display_content = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.edit_info {
            my_size += 1 + 1;
        }
        if let Some(v) = self.publish {
            my_size += 1 + 1;
        }
        if let Some(v) = self.view_error_data {
            my_size += 1 + 1;
        }
        if let Some(v) = self.download {
            my_size += 1 + 1;
        }
        if let Some(v) = self.upload_cdkeys {
            my_size += 1 + 1;
        }
        if let Some(v) = self.generate_cdkeys {
            my_size += 1 + 1;
        }
        if let Some(v) = self.view_financials {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_ceg {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_signing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_cdkeys {
            my_size += 1 + 1;
        }
        if let Some(v) = self.edit_marketing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.economy_support {
            my_size += 1 + 1;
        }
        if let Some(v) = self.economy_support_supervisor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.manage_pricing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.broadcast_live {
            my_size += 1 + 1;
        }
        if let Some(v) = self.view_marketing_traffic {
            my_size += 2 + 1;
        }
        if let Some(v) = self.edit_store_display_content {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.edit_info {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.publish {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.view_error_data {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.download {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.upload_cdkeys {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.generate_cdkeys {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.view_financials {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.manage_ceg {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.manage_signing {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.manage_cdkeys {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.edit_marketing {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.economy_support {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.economy_support_supervisor {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.manage_pricing {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.broadcast_live {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.view_marketing_traffic {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.edit_store_display_content {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAppRights {
        CMsgAppRights::new()
    }

    fn clear(&mut self) {
        self.edit_info = ::std::option::Option::None;
        self.publish = ::std::option::Option::None;
        self.view_error_data = ::std::option::Option::None;
        self.download = ::std::option::Option::None;
        self.upload_cdkeys = ::std::option::Option::None;
        self.generate_cdkeys = ::std::option::Option::None;
        self.view_financials = ::std::option::Option::None;
        self.manage_ceg = ::std::option::Option::None;
        self.manage_signing = ::std::option::Option::None;
        self.manage_cdkeys = ::std::option::Option::None;
        self.edit_marketing = ::std::option::Option::None;
        self.economy_support = ::std::option::Option::None;
        self.economy_support_supervisor = ::std::option::Option::None;
        self.manage_pricing = ::std::option::Option::None;
        self.broadcast_live = ::std::option::Option::None;
        self.view_marketing_traffic = ::std::option::Option::None;
        self.edit_store_display_content = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAppRights {
        static instance: CMsgAppRights = CMsgAppRights {
            edit_info: ::std::option::Option::None,
            publish: ::std::option::Option::None,
            view_error_data: ::std::option::Option::None,
            download: ::std::option::Option::None,
            upload_cdkeys: ::std::option::Option::None,
            generate_cdkeys: ::std::option::Option::None,
            view_financials: ::std::option::Option::None,
            manage_ceg: ::std::option::Option::None,
            manage_signing: ::std::option::Option::None,
            manage_cdkeys: ::std::option::Option::None,
            edit_marketing: ::std::option::Option::None,
            economy_support: ::std::option::Option::None,
            economy_support_supervisor: ::std::option::Option::None,
            manage_pricing: ::std::option::Option::None,
            broadcast_live: ::std::option::Option::None,
            view_marketing_traffic: ::std::option::Option::None,
            edit_store_display_content: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAppRights {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAppRights").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAppRights {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAppRights {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCuratorPreferences)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCuratorPreferences {
    // message fields
    // @@protoc_insertion_point(field:CCuratorPreferences.supported_languages)
    pub supported_languages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.platform_windows)
    pub platform_windows: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.platform_mac)
    pub platform_mac: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.platform_linux)
    pub platform_linux: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.vr_content)
    pub vr_content: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.adult_content_violence)
    pub adult_content_violence: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.adult_content_sex)
    pub adult_content_sex: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCuratorPreferences.timestamp_updated)
    pub timestamp_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.tagids_curated)
    pub tagids_curated: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.tagids_filtered)
    pub tagids_filtered: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCuratorPreferences.website_title)
    pub website_title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCuratorPreferences.website_url)
    pub website_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCuratorPreferences.discussion_url)
    pub discussion_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCuratorPreferences.show_broadcast)
    pub show_broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCuratorPreferences.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCuratorPreferences {
    fn default() -> &'a CCuratorPreferences {
        <CCuratorPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CCuratorPreferences {
    pub fn new() -> CCuratorPreferences {
        ::std::default::Default::default()
    }

    // optional uint32 supported_languages = 1;

    pub fn supported_languages(&self) -> u32 {
        self.supported_languages.unwrap_or(0)
    }

    pub fn clear_supported_languages(&mut self) {
        self.supported_languages = ::std::option::Option::None;
    }

    pub fn has_supported_languages(&self) -> bool {
        self.supported_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supported_languages(&mut self, v: u32) {
        self.supported_languages = ::std::option::Option::Some(v);
    }

    // optional bool platform_windows = 2;

    pub fn platform_windows(&self) -> bool {
        self.platform_windows.unwrap_or(false)
    }

    pub fn clear_platform_windows(&mut self) {
        self.platform_windows = ::std::option::Option::None;
    }

    pub fn has_platform_windows(&self) -> bool {
        self.platform_windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_windows(&mut self, v: bool) {
        self.platform_windows = ::std::option::Option::Some(v);
    }

    // optional bool platform_mac = 3;

    pub fn platform_mac(&self) -> bool {
        self.platform_mac.unwrap_or(false)
    }

    pub fn clear_platform_mac(&mut self) {
        self.platform_mac = ::std::option::Option::None;
    }

    pub fn has_platform_mac(&self) -> bool {
        self.platform_mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_mac(&mut self, v: bool) {
        self.platform_mac = ::std::option::Option::Some(v);
    }

    // optional bool platform_linux = 4;

    pub fn platform_linux(&self) -> bool {
        self.platform_linux.unwrap_or(false)
    }

    pub fn clear_platform_linux(&mut self) {
        self.platform_linux = ::std::option::Option::None;
    }

    pub fn has_platform_linux(&self) -> bool {
        self.platform_linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_linux(&mut self, v: bool) {
        self.platform_linux = ::std::option::Option::Some(v);
    }

    // optional bool vr_content = 5;

    pub fn vr_content(&self) -> bool {
        self.vr_content.unwrap_or(false)
    }

    pub fn clear_vr_content(&mut self) {
        self.vr_content = ::std::option::Option::None;
    }

    pub fn has_vr_content(&self) -> bool {
        self.vr_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_content(&mut self, v: bool) {
        self.vr_content = ::std::option::Option::Some(v);
    }

    // optional bool adult_content_violence = 6;

    pub fn adult_content_violence(&self) -> bool {
        self.adult_content_violence.unwrap_or(false)
    }

    pub fn clear_adult_content_violence(&mut self) {
        self.adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_adult_content_violence(&self) -> bool {
        self.adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_content_violence(&mut self, v: bool) {
        self.adult_content_violence = ::std::option::Option::Some(v);
    }

    // optional bool adult_content_sex = 7;

    pub fn adult_content_sex(&self) -> bool {
        self.adult_content_sex.unwrap_or(false)
    }

    pub fn clear_adult_content_sex(&mut self) {
        self.adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_adult_content_sex(&self) -> bool {
        self.adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_content_sex(&mut self, v: bool) {
        self.adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_updated = 8;

    pub fn timestamp_updated(&self) -> u32 {
        self.timestamp_updated.unwrap_or(0)
    }

    pub fn clear_timestamp_updated(&mut self) {
        self.timestamp_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_updated(&self) -> bool {
        self.timestamp_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_updated(&mut self, v: u32) {
        self.timestamp_updated = ::std::option::Option::Some(v);
    }

    // optional string website_title = 11;

    pub fn website_title(&self) -> &str {
        match self.website_title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_website_title(&mut self) {
        self.website_title = ::std::option::Option::None;
    }

    pub fn has_website_title(&self) -> bool {
        self.website_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_website_title(&mut self, v: ::std::string::String) {
        self.website_title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website_title(&mut self) -> &mut ::std::string::String {
        if self.website_title.is_none() {
            self.website_title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.website_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_website_title(&mut self) -> ::std::string::String {
        self.website_title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string website_url = 12;

    pub fn website_url(&self) -> &str {
        match self.website_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_website_url(&mut self) {
        self.website_url = ::std::option::Option::None;
    }

    pub fn has_website_url(&self) -> bool {
        self.website_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_website_url(&mut self, v: ::std::string::String) {
        self.website_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website_url(&mut self) -> &mut ::std::string::String {
        if self.website_url.is_none() {
            self.website_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.website_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_website_url(&mut self) -> ::std::string::String {
        self.website_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string discussion_url = 13;

    pub fn discussion_url(&self) -> &str {
        match self.discussion_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_discussion_url(&mut self) {
        self.discussion_url = ::std::option::Option::None;
    }

    pub fn has_discussion_url(&self) -> bool {
        self.discussion_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discussion_url(&mut self, v: ::std::string::String) {
        self.discussion_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discussion_url(&mut self) -> &mut ::std::string::String {
        if self.discussion_url.is_none() {
            self.discussion_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.discussion_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_discussion_url(&mut self) -> ::std::string::String {
        self.discussion_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool show_broadcast = 14;

    pub fn show_broadcast(&self) -> bool {
        self.show_broadcast.unwrap_or(false)
    }

    pub fn clear_show_broadcast(&mut self) {
        self.show_broadcast = ::std::option::Option::None;
    }

    pub fn has_show_broadcast(&self) -> bool {
        self.show_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_broadcast(&mut self, v: bool) {
        self.show_broadcast = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "supported_languages",
            |m: &CCuratorPreferences| { &m.supported_languages },
            |m: &mut CCuratorPreferences| { &mut m.supported_languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_windows",
            |m: &CCuratorPreferences| { &m.platform_windows },
            |m: &mut CCuratorPreferences| { &mut m.platform_windows },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_mac",
            |m: &CCuratorPreferences| { &m.platform_mac },
            |m: &mut CCuratorPreferences| { &mut m.platform_mac },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform_linux",
            |m: &CCuratorPreferences| { &m.platform_linux },
            |m: &mut CCuratorPreferences| { &mut m.platform_linux },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vr_content",
            |m: &CCuratorPreferences| { &m.vr_content },
            |m: &mut CCuratorPreferences| { &mut m.vr_content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "adult_content_violence",
            |m: &CCuratorPreferences| { &m.adult_content_violence },
            |m: &mut CCuratorPreferences| { &mut m.adult_content_violence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "adult_content_sex",
            |m: &CCuratorPreferences| { &m.adult_content_sex },
            |m: &mut CCuratorPreferences| { &mut m.adult_content_sex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_updated",
            |m: &CCuratorPreferences| { &m.timestamp_updated },
            |m: &mut CCuratorPreferences| { &mut m.timestamp_updated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagids_curated",
            |m: &CCuratorPreferences| { &m.tagids_curated },
            |m: &mut CCuratorPreferences| { &mut m.tagids_curated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagids_filtered",
            |m: &CCuratorPreferences| { &m.tagids_filtered },
            |m: &mut CCuratorPreferences| { &mut m.tagids_filtered },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "website_title",
            |m: &CCuratorPreferences| { &m.website_title },
            |m: &mut CCuratorPreferences| { &mut m.website_title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "website_url",
            |m: &CCuratorPreferences| { &m.website_url },
            |m: &mut CCuratorPreferences| { &mut m.website_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "discussion_url",
            |m: &CCuratorPreferences| { &m.discussion_url },
            |m: &mut CCuratorPreferences| { &mut m.discussion_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_broadcast",
            |m: &CCuratorPreferences| { &m.show_broadcast },
            |m: &mut CCuratorPreferences| { &mut m.show_broadcast },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCuratorPreferences>(
            "CCuratorPreferences",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCuratorPreferences {
    const NAME: &'static str = "CCuratorPreferences";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.supported_languages = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.platform_windows = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.platform_mac = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.platform_linux = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.vr_content = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.adult_content_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.adult_content_sex = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.timestamp_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids_curated)?;
                },
                72 => {
                    self.tagids_curated.push(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids_filtered)?;
                },
                80 => {
                    self.tagids_filtered.push(is.read_uint32()?);
                },
                90 => {
                    self.website_title = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.website_url = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.discussion_url = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.show_broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.supported_languages {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.platform_windows {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_mac {
            my_size += 1 + 1;
        }
        if let Some(v) = self.platform_linux {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vr_content {
            my_size += 1 + 1;
        }
        if let Some(v) = self.adult_content_violence {
            my_size += 1 + 1;
        }
        if let Some(v) = self.adult_content_sex {
            my_size += 1 + 1;
        }
        if let Some(v) = self.timestamp_updated {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        for value in &self.tagids_curated {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        for value in &self.tagids_filtered {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        if let Some(v) = self.website_title.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.website_url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.discussion_url.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.show_broadcast {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.supported_languages {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.platform_windows {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.platform_mac {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.platform_linux {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.vr_content {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.adult_content_violence {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.adult_content_sex {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.timestamp_updated {
            os.write_uint32(8, v)?;
        }
        for v in &self.tagids_curated {
            os.write_uint32(9, *v)?;
        };
        for v in &self.tagids_filtered {
            os.write_uint32(10, *v)?;
        };
        if let Some(v) = self.website_title.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.website_url.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.discussion_url.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.show_broadcast {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCuratorPreferences {
        CCuratorPreferences::new()
    }

    fn clear(&mut self) {
        self.supported_languages = ::std::option::Option::None;
        self.platform_windows = ::std::option::Option::None;
        self.platform_mac = ::std::option::Option::None;
        self.platform_linux = ::std::option::Option::None;
        self.vr_content = ::std::option::Option::None;
        self.adult_content_violence = ::std::option::Option::None;
        self.adult_content_sex = ::std::option::Option::None;
        self.timestamp_updated = ::std::option::Option::None;
        self.tagids_curated.clear();
        self.tagids_filtered.clear();
        self.website_title = ::std::option::Option::None;
        self.website_url = ::std::option::Option::None;
        self.discussion_url = ::std::option::Option::None;
        self.show_broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCuratorPreferences {
        static instance: CCuratorPreferences = CCuratorPreferences {
            supported_languages: ::std::option::Option::None,
            platform_windows: ::std::option::Option::None,
            platform_mac: ::std::option::Option::None,
            platform_linux: ::std::option::Option::None,
            vr_content: ::std::option::Option::None,
            adult_content_violence: ::std::option::Option::None,
            adult_content_sex: ::std::option::Option::None,
            timestamp_updated: ::std::option::Option::None,
            tagids_curated: ::std::vec::Vec::new(),
            tagids_filtered: ::std::vec::Vec::new(),
            website_title: ::std::option::Option::None,
            website_url: ::std::option::Option::None,
            discussion_url: ::std::option::Option::None,
            show_broadcast: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCuratorPreferences {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCuratorPreferences").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCuratorPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCuratorPreferences {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CLocalizationToken)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLocalizationToken {
    // message fields
    // @@protoc_insertion_point(field:CLocalizationToken.language)
    pub language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CLocalizationToken.localized_string)
    pub localized_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CLocalizationToken.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLocalizationToken {
    fn default() -> &'a CLocalizationToken {
        <CLocalizationToken as ::protobuf::Message>::default_instance()
    }
}

impl CLocalizationToken {
    pub fn new() -> CLocalizationToken {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional string localized_string = 2;

    pub fn localized_string(&self) -> &str {
        match self.localized_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localized_string(&mut self) {
        self.localized_string = ::std::option::Option::None;
    }

    pub fn has_localized_string(&self) -> bool {
        self.localized_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localized_string(&mut self, v: ::std::string::String) {
        self.localized_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localized_string(&mut self) -> &mut ::std::string::String {
        if self.localized_string.is_none() {
            self.localized_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localized_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_localized_string(&mut self) -> ::std::string::String {
        self.localized_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CLocalizationToken| { &m.language },
            |m: &mut CLocalizationToken| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "localized_string",
            |m: &CLocalizationToken| { &m.localized_string },
            |m: &mut CLocalizationToken| { &mut m.localized_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CLocalizationToken>(
            "CLocalizationToken",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CLocalizationToken {
    const NAME: &'static str = "CLocalizationToken";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.localized_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.localized_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.localized_string.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLocalizationToken {
        CLocalizationToken::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.localized_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLocalizationToken {
        static instance: CLocalizationToken = CLocalizationToken {
            language: ::std::option::Option::None,
            localized_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CLocalizationToken {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CLocalizationToken").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CLocalizationToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLocalizationToken {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanEventUserNewsTuple)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanEventUserNewsTuple {
    // message fields
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.event_gid)
    pub event_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.announcement_gid)
    pub announcement_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.rtime_start)
    pub rtime_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.rtime_end)
    pub rtime_end: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.priority_score)
    pub priority_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.clamp_range_slot)
    pub clamp_range_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventUserNewsTuple.rtime32_last_modified)
    pub rtime32_last_modified: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanEventUserNewsTuple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanEventUserNewsTuple {
    fn default() -> &'a CClanEventUserNewsTuple {
        <CClanEventUserNewsTuple as ::protobuf::Message>::default_instance()
    }
}

impl CClanEventUserNewsTuple {
    pub fn new() -> CClanEventUserNewsTuple {
        ::std::default::Default::default()
    }

    // optional uint32 clanid = 1;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional fixed64 event_gid = 2;

    pub fn event_gid(&self) -> u64 {
        self.event_gid.unwrap_or(0)
    }

    pub fn clear_event_gid(&mut self) {
        self.event_gid = ::std::option::Option::None;
    }

    pub fn has_event_gid(&self) -> bool {
        self.event_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_gid(&mut self, v: u64) {
        self.event_gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 announcement_gid = 3;

    pub fn announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }

    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_start = 4;

    pub fn rtime_start(&self) -> u32 {
        self.rtime_start.unwrap_or(0)
    }

    pub fn clear_rtime_start(&mut self) {
        self.rtime_start = ::std::option::Option::None;
    }

    pub fn has_rtime_start(&self) -> bool {
        self.rtime_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_start(&mut self, v: u32) {
        self.rtime_start = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_end = 5;

    pub fn rtime_end(&self) -> u32 {
        self.rtime_end.unwrap_or(0)
    }

    pub fn clear_rtime_end(&mut self) {
        self.rtime_end = ::std::option::Option::None;
    }

    pub fn has_rtime_end(&self) -> bool {
        self.rtime_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_end(&mut self, v: u32) {
        self.rtime_end = ::std::option::Option::Some(v);
    }

    // optional uint32 priority_score = 6;

    pub fn priority_score(&self) -> u32 {
        self.priority_score.unwrap_or(0)
    }

    pub fn clear_priority_score(&mut self) {
        self.priority_score = ::std::option::Option::None;
    }

    pub fn has_priority_score(&self) -> bool {
        self.priority_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_score(&mut self, v: u32) {
        self.priority_score = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 7;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint32 clamp_range_slot = 8;

    pub fn clamp_range_slot(&self) -> u32 {
        self.clamp_range_slot.unwrap_or(0)
    }

    pub fn clear_clamp_range_slot(&mut self) {
        self.clamp_range_slot = ::std::option::Option::None;
    }

    pub fn has_clamp_range_slot(&self) -> bool {
        self.clamp_range_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clamp_range_slot(&mut self, v: u32) {
        self.clamp_range_slot = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 9;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_last_modified = 10;

    pub fn rtime32_last_modified(&self) -> u32 {
        self.rtime32_last_modified.unwrap_or(0)
    }

    pub fn clear_rtime32_last_modified(&mut self) {
        self.rtime32_last_modified = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_modified(&self) -> bool {
        self.rtime32_last_modified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_modified(&mut self, v: u32) {
        self.rtime32_last_modified = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clanid",
            |m: &CClanEventUserNewsTuple| { &m.clanid },
            |m: &mut CClanEventUserNewsTuple| { &mut m.clanid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_gid",
            |m: &CClanEventUserNewsTuple| { &m.event_gid },
            |m: &mut CClanEventUserNewsTuple| { &mut m.event_gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "announcement_gid",
            |m: &CClanEventUserNewsTuple| { &m.announcement_gid },
            |m: &mut CClanEventUserNewsTuple| { &mut m.announcement_gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_start",
            |m: &CClanEventUserNewsTuple| { &m.rtime_start },
            |m: &mut CClanEventUserNewsTuple| { &mut m.rtime_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_end",
            |m: &CClanEventUserNewsTuple| { &m.rtime_end },
            |m: &mut CClanEventUserNewsTuple| { &mut m.rtime_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "priority_score",
            |m: &CClanEventUserNewsTuple| { &m.priority_score },
            |m: &mut CClanEventUserNewsTuple| { &mut m.priority_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CClanEventUserNewsTuple| { &m.type_ },
            |m: &mut CClanEventUserNewsTuple| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clamp_range_slot",
            |m: &CClanEventUserNewsTuple| { &m.clamp_range_slot },
            |m: &mut CClanEventUserNewsTuple| { &mut m.clamp_range_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClanEventUserNewsTuple| { &m.appid },
            |m: &mut CClanEventUserNewsTuple| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_last_modified",
            |m: &CClanEventUserNewsTuple| { &m.rtime32_last_modified },
            |m: &mut CClanEventUserNewsTuple| { &mut m.rtime32_last_modified },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClanEventUserNewsTuple>(
            "CClanEventUserNewsTuple",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClanEventUserNewsTuple {
    const NAME: &'static str = "CClanEventUserNewsTuple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.event_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.announcement_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.rtime_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rtime_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.priority_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.clamp_range_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.rtime32_last_modified = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.announcement_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.rtime_start {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rtime_end {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.priority_score {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.clamp_range_slot {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.rtime32_last_modified {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clanid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_gid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.rtime_start {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rtime_end {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.priority_score {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.clamp_range_slot {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.rtime32_last_modified {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanEventUserNewsTuple {
        CClanEventUserNewsTuple::new()
    }

    fn clear(&mut self) {
        self.clanid = ::std::option::Option::None;
        self.event_gid = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.rtime_start = ::std::option::Option::None;
        self.rtime_end = ::std::option::Option::None;
        self.priority_score = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.clamp_range_slot = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.rtime32_last_modified = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanEventUserNewsTuple {
        static instance: CClanEventUserNewsTuple = CClanEventUserNewsTuple {
            clanid: ::std::option::Option::None,
            event_gid: ::std::option::Option::None,
            announcement_gid: ::std::option::Option::None,
            rtime_start: ::std::option::Option::None,
            rtime_end: ::std::option::Option::None,
            priority_score: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            clamp_range_slot: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            rtime32_last_modified: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClanEventUserNewsTuple {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanEventUserNewsTuple").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanEventUserNewsTuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanEventUserNewsTuple {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanMatchEventByRange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanMatchEventByRange {
    // message fields
    // @@protoc_insertion_point(field:CClanMatchEventByRange.rtime_before)
    pub rtime_before: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanMatchEventByRange.rtime_after)
    pub rtime_after: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanMatchEventByRange.qualified)
    pub qualified: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanMatchEventByRange.events)
    pub events: ::std::vec::Vec<CClanEventUserNewsTuple>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanMatchEventByRange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanMatchEventByRange {
    fn default() -> &'a CClanMatchEventByRange {
        <CClanMatchEventByRange as ::protobuf::Message>::default_instance()
    }
}

impl CClanMatchEventByRange {
    pub fn new() -> CClanMatchEventByRange {
        ::std::default::Default::default()
    }

    // optional uint32 rtime_before = 1;

    pub fn rtime_before(&self) -> u32 {
        self.rtime_before.unwrap_or(0)
    }

    pub fn clear_rtime_before(&mut self) {
        self.rtime_before = ::std::option::Option::None;
    }

    pub fn has_rtime_before(&self) -> bool {
        self.rtime_before.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_before(&mut self, v: u32) {
        self.rtime_before = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_after = 2;

    pub fn rtime_after(&self) -> u32 {
        self.rtime_after.unwrap_or(0)
    }

    pub fn clear_rtime_after(&mut self) {
        self.rtime_after = ::std::option::Option::None;
    }

    pub fn has_rtime_after(&self) -> bool {
        self.rtime_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_after(&mut self, v: u32) {
        self.rtime_after = ::std::option::Option::Some(v);
    }

    // optional uint32 qualified = 3;

    pub fn qualified(&self) -> u32 {
        self.qualified.unwrap_or(0)
    }

    pub fn clear_qualified(&mut self) {
        self.qualified = ::std::option::Option::None;
    }

    pub fn has_qualified(&self) -> bool {
        self.qualified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qualified(&mut self, v: u32) {
        self.qualified = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_before",
            |m: &CClanMatchEventByRange| { &m.rtime_before },
            |m: &mut CClanMatchEventByRange| { &mut m.rtime_before },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_after",
            |m: &CClanMatchEventByRange| { &m.rtime_after },
            |m: &mut CClanMatchEventByRange| { &mut m.rtime_after },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "qualified",
            |m: &CClanMatchEventByRange| { &m.qualified },
            |m: &mut CClanMatchEventByRange| { &mut m.qualified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &CClanMatchEventByRange| { &m.events },
            |m: &mut CClanMatchEventByRange| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClanMatchEventByRange>(
            "CClanMatchEventByRange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClanMatchEventByRange {
    const NAME: &'static str = "CClanMatchEventByRange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rtime_before = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rtime_after = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.qualified = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rtime_before {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rtime_after {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.qualified {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rtime_before {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rtime_after {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.qualified {
            os.write_uint32(3, v)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanMatchEventByRange {
        CClanMatchEventByRange::new()
    }

    fn clear(&mut self) {
        self.rtime_before = ::std::option::Option::None;
        self.rtime_after = ::std::option::Option::None;
        self.qualified = ::std::option::Option::None;
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanMatchEventByRange {
        static instance: CClanMatchEventByRange = CClanMatchEventByRange {
            rtime_before: ::std::option::Option::None,
            rtime_after: ::std::option::Option::None,
            qualified: ::std::option::Option::None,
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClanMatchEventByRange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanMatchEventByRange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanMatchEventByRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanMatchEventByRange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCommunity_ClanAnnouncementInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCommunity_ClanAnnouncementInfo {
    // message fields
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.clanid)
    pub clanid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.posterid)
    pub posterid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.posttime)
    pub posttime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.updatetime)
    pub updatetime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.body)
    pub body: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.commentcount)
    pub commentcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.forum_topic_id)
    pub forum_topic_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.event_gid)
    pub event_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.voteupcount)
    pub voteupcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.votedowncount)
    pub votedowncount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.ban_check_result)
    pub ban_check_result: ::std::option::Option<::protobuf::EnumOrUnknown<EBanContentCheckResult>>,
    // @@protoc_insertion_point(field:CCommunity_ClanAnnouncementInfo.banned)
    pub banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCommunity_ClanAnnouncementInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClanAnnouncementInfo {
    fn default() -> &'a CCommunity_ClanAnnouncementInfo {
        <CCommunity_ClanAnnouncementInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCommunity_ClanAnnouncementInfo {
    pub fn new() -> CCommunity_ClanAnnouncementInfo {
        ::std::default::Default::default()
    }

    // optional uint64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint64 clanid = 2;

    pub fn clanid(&self) -> u64 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u64) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint64 posterid = 3;

    pub fn posterid(&self) -> u64 {
        self.posterid.unwrap_or(0)
    }

    pub fn clear_posterid(&mut self) {
        self.posterid = ::std::option::Option::None;
    }

    pub fn has_posterid(&self) -> bool {
        self.posterid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posterid(&mut self, v: u64) {
        self.posterid = ::std::option::Option::Some(v);
    }

    // optional string headline = 4;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 posttime = 5;

    pub fn posttime(&self) -> u32 {
        self.posttime.unwrap_or(0)
    }

    pub fn clear_posttime(&mut self) {
        self.posttime = ::std::option::Option::None;
    }

    pub fn has_posttime(&self) -> bool {
        self.posttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posttime(&mut self, v: u32) {
        self.posttime = ::std::option::Option::Some(v);
    }

    // optional uint32 updatetime = 6;

    pub fn updatetime(&self) -> u32 {
        self.updatetime.unwrap_or(0)
    }

    pub fn clear_updatetime(&mut self) {
        self.updatetime = ::std::option::Option::None;
    }

    pub fn has_updatetime(&self) -> bool {
        self.updatetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatetime(&mut self, v: u32) {
        self.updatetime = ::std::option::Option::Some(v);
    }

    // optional string body = 7;

    pub fn body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body = ::std::option::Option::Some(::std::string::String::new());
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 commentcount = 8;

    pub fn commentcount(&self) -> i32 {
        self.commentcount.unwrap_or(0)
    }

    pub fn clear_commentcount(&mut self) {
        self.commentcount = ::std::option::Option::None;
    }

    pub fn has_commentcount(&self) -> bool {
        self.commentcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentcount(&mut self, v: i32) {
        self.commentcount = ::std::option::Option::Some(v);
    }

    // optional int32 language = 10;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 11;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 12;

    pub fn forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }

    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 event_gid = 13;

    pub fn event_gid(&self) -> u64 {
        self.event_gid.unwrap_or(0)
    }

    pub fn clear_event_gid(&mut self) {
        self.event_gid = ::std::option::Option::None;
    }

    pub fn has_event_gid(&self) -> bool {
        self.event_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_gid(&mut self, v: u64) {
        self.event_gid = ::std::option::Option::Some(v);
    }

    // optional int32 voteupcount = 14;

    pub fn voteupcount(&self) -> i32 {
        self.voteupcount.unwrap_or(0)
    }

    pub fn clear_voteupcount(&mut self) {
        self.voteupcount = ::std::option::Option::None;
    }

    pub fn has_voteupcount(&self) -> bool {
        self.voteupcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voteupcount(&mut self, v: i32) {
        self.voteupcount = ::std::option::Option::Some(v);
    }

    // optional int32 votedowncount = 15;

    pub fn votedowncount(&self) -> i32 {
        self.votedowncount.unwrap_or(0)
    }

    pub fn clear_votedowncount(&mut self) {
        self.votedowncount = ::std::option::Option::None;
    }

    pub fn has_votedowncount(&self) -> bool {
        self.votedowncount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votedowncount(&mut self, v: i32) {
        self.votedowncount = ::std::option::Option::Some(v);
    }

    // optional .EBanContentCheckResult ban_check_result = 16;

    pub fn ban_check_result(&self) -> EBanContentCheckResult {
        match self.ban_check_result {
            Some(e) => e.enum_value_or(EBanContentCheckResult::k_EBanContentCheckResult_NotScanned),
            None => EBanContentCheckResult::k_EBanContentCheckResult_NotScanned,
        }
    }

    pub fn clear_ban_check_result(&mut self) {
        self.ban_check_result = ::std::option::Option::None;
    }

    pub fn has_ban_check_result(&self) -> bool {
        self.ban_check_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_check_result(&mut self, v: EBanContentCheckResult) {
        self.ban_check_result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool banned = 17;

    pub fn banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.gid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clanid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.clanid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.clanid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "posterid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.posterid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.posterid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "headline",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.headline },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.headline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "posttime",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.posttime },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.posttime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updatetime",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.updatetime },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.updatetime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "body",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.body },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commentcount",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.commentcount },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.commentcount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.tags },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.tags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.language },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.hidden },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forum_topic_id",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.forum_topic_id },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.forum_topic_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_gid",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.event_gid },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.event_gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voteupcount",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.voteupcount },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.voteupcount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "votedowncount",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.votedowncount },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.votedowncount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ban_check_result",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.ban_check_result },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.ban_check_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "banned",
            |m: &CCommunity_ClanAnnouncementInfo| { &m.banned },
            |m: &mut CCommunity_ClanAnnouncementInfo| { &mut m.banned },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCommunity_ClanAnnouncementInfo>(
            "CCommunity_ClanAnnouncementInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCommunity_ClanAnnouncementInfo {
    const NAME: &'static str = "CCommunity_ClanAnnouncementInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.posterid = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.posttime = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.updatetime = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.body = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.commentcount = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.tags.push(is.read_string()?);
                },
                80 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                97 => {
                    self.forum_topic_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                105 => {
                    self.event_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                112 => {
                    self.voteupcount = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.votedowncount = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.ban_check_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                136 => {
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.posterid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.posttime {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.updatetime {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.commentcount {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.hidden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.voteupcount {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.votedowncount {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.ban_check_result {
            my_size += ::protobuf::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.banned {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.posterid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.posttime {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.updatetime {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.body.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.commentcount {
            os.write_int32(8, v)?;
        }
        for v in &self.tags {
            os.write_string(9, &v)?;
        };
        if let Some(v) = self.language {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.event_gid {
            os.write_fixed64(13, v)?;
        }
        if let Some(v) = self.voteupcount {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.votedowncount {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.ban_check_result {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.banned {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCommunity_ClanAnnouncementInfo {
        CCommunity_ClanAnnouncementInfo::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clanid = ::std::option::Option::None;
        self.posterid = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.posttime = ::std::option::Option::None;
        self.updatetime = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.commentcount = ::std::option::Option::None;
        self.tags.clear();
        self.language = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.event_gid = ::std::option::Option::None;
        self.voteupcount = ::std::option::Option::None;
        self.votedowncount = ::std::option::Option::None;
        self.ban_check_result = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCommunity_ClanAnnouncementInfo {
        static instance: CCommunity_ClanAnnouncementInfo = CCommunity_ClanAnnouncementInfo {
            gid: ::std::option::Option::None,
            clanid: ::std::option::Option::None,
            posterid: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            posttime: ::std::option::Option::None,
            updatetime: ::std::option::Option::None,
            body: ::std::option::Option::None,
            commentcount: ::std::option::Option::None,
            tags: ::std::vec::Vec::new(),
            language: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            forum_topic_id: ::std::option::Option::None,
            event_gid: ::std::option::Option::None,
            voteupcount: ::std::option::Option::None,
            votedowncount: ::std::option::Option::None,
            ban_check_result: ::std::option::Option::None,
            banned: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCommunity_ClanAnnouncementInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCommunity_ClanAnnouncementInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCommunity_ClanAnnouncementInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCommunity_ClanAnnouncementInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanEventData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanEventData {
    // message fields
    // @@protoc_insertion_point(field:CClanEventData.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.clan_steamid)
    pub clan_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.event_type)
    pub event_type: ::std::option::Option<::protobuf::EnumOrUnknown<EProtoClanEventType>>,
    // @@protoc_insertion_point(field:CClanEventData.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.server_address)
    pub server_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.server_password)
    pub server_password: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_start_time)
    pub rtime32_start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_end_time)
    pub rtime32_end_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.comment_count)
    pub comment_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CClanEventData.creator_steamid)
    pub creator_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.last_update_steamid)
    pub last_update_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.event_notes)
    pub event_notes: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.jsondata)
    pub jsondata: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CClanEventData.announcement_body)
    pub announcement_body: ::protobuf::MessageField<CCommunity_ClanAnnouncementInfo>,
    // @@protoc_insertion_point(field:CClanEventData.published)
    pub published: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClanEventData.hidden)
    pub hidden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_visibility_start)
    pub rtime32_visibility_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_visibility_end)
    pub rtime32_visibility_end: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.broadcaster_accountid)
    pub broadcaster_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.follower_count)
    pub follower_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.ignore_count)
    pub ignore_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.forum_topic_id)
    pub forum_topic_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.rtime32_last_modified)
    pub rtime32_last_modified: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.news_post_gid)
    pub news_post_gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanEventData.rtime_mod_reviewed)
    pub rtime_mod_reviewed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.featured_app_tagid)
    pub featured_app_tagid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.referenced_appids)
    pub referenced_appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CClanEventData.build_id)
    pub build_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClanEventData.build_branch)
    pub build_branch: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanEventData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanEventData {
    fn default() -> &'a CClanEventData {
        <CClanEventData as ::protobuf::Message>::default_instance()
    }
}

impl CClanEventData {
    pub fn new() -> CClanEventData {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 clan_steamid = 2;

    pub fn clan_steamid(&self) -> u64 {
        self.clan_steamid.unwrap_or(0)
    }

    pub fn clear_clan_steamid(&mut self) {
        self.clan_steamid = ::std::option::Option::None;
    }

    pub fn has_clan_steamid(&self) -> bool {
        self.clan_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_steamid(&mut self, v: u64) {
        self.clan_steamid = ::std::option::Option::Some(v);
    }

    // optional string event_name = 3;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EProtoClanEventType event_type = 4;

    pub fn event_type(&self) -> EProtoClanEventType {
        match self.event_type {
            Some(e) => e.enum_value_or(EProtoClanEventType::k_EClanOtherEvent),
            None => EProtoClanEventType::k_EClanOtherEvent,
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: EProtoClanEventType) {
        self.event_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 appid = 5;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string server_address = 6;

    pub fn server_address(&self) -> &str {
        match self.server_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: ::std::string::String) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_address(&mut self) -> &mut ::std::string::String {
        if self.server_address.is_none() {
            self.server_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_address(&mut self) -> ::std::string::String {
        self.server_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_password = 7;

    pub fn server_password(&self) -> &str {
        match self.server_password.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_password(&mut self) {
        self.server_password = ::std::option::Option::None;
    }

    pub fn has_server_password(&self) -> bool {
        self.server_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_password(&mut self, v: ::std::string::String) {
        self.server_password = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_password(&mut self) -> &mut ::std::string::String {
        if self.server_password.is_none() {
            self.server_password = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_password.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_password(&mut self) -> ::std::string::String {
        self.server_password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 rtime32_start_time = 8;

    pub fn rtime32_start_time(&self) -> u32 {
        self.rtime32_start_time.unwrap_or(0)
    }

    pub fn clear_rtime32_start_time(&mut self) {
        self.rtime32_start_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_start_time(&self) -> bool {
        self.rtime32_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_start_time(&mut self, v: u32) {
        self.rtime32_start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_end_time = 9;

    pub fn rtime32_end_time(&self) -> u32 {
        self.rtime32_end_time.unwrap_or(0)
    }

    pub fn clear_rtime32_end_time(&mut self) {
        self.rtime32_end_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_end_time(&self) -> bool {
        self.rtime32_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_end_time(&mut self, v: u32) {
        self.rtime32_end_time = ::std::option::Option::Some(v);
    }

    // optional int32 comment_count = 10;

    pub fn comment_count(&self) -> i32 {
        self.comment_count.unwrap_or(0)
    }

    pub fn clear_comment_count(&mut self) {
        self.comment_count = ::std::option::Option::None;
    }

    pub fn has_comment_count(&self) -> bool {
        self.comment_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_count(&mut self, v: i32) {
        self.comment_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator_steamid = 11;

    pub fn creator_steamid(&self) -> u64 {
        self.creator_steamid.unwrap_or(0)
    }

    pub fn clear_creator_steamid(&mut self) {
        self.creator_steamid = ::std::option::Option::None;
    }

    pub fn has_creator_steamid(&self) -> bool {
        self.creator_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_steamid(&mut self, v: u64) {
        self.creator_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 last_update_steamid = 12;

    pub fn last_update_steamid(&self) -> u64 {
        self.last_update_steamid.unwrap_or(0)
    }

    pub fn clear_last_update_steamid(&mut self) {
        self.last_update_steamid = ::std::option::Option::None;
    }

    pub fn has_last_update_steamid(&self) -> bool {
        self.last_update_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_update_steamid(&mut self, v: u64) {
        self.last_update_steamid = ::std::option::Option::Some(v);
    }

    // optional string event_notes = 13;

    pub fn event_notes(&self) -> &str {
        match self.event_notes.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_notes(&mut self) {
        self.event_notes = ::std::option::Option::None;
    }

    pub fn has_event_notes(&self) -> bool {
        self.event_notes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_notes(&mut self, v: ::std::string::String) {
        self.event_notes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_notes(&mut self) -> &mut ::std::string::String {
        if self.event_notes.is_none() {
            self.event_notes = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_notes.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_notes(&mut self) -> ::std::string::String {
        self.event_notes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string jsondata = 14;

    pub fn jsondata(&self) -> &str {
        match self.jsondata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_jsondata(&mut self) {
        self.jsondata = ::std::option::Option::None;
    }

    pub fn has_jsondata(&self) -> bool {
        self.jsondata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jsondata(&mut self, v: ::std::string::String) {
        self.jsondata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jsondata(&mut self) -> &mut ::std::string::String {
        if self.jsondata.is_none() {
            self.jsondata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.jsondata.as_mut().unwrap()
    }

    // Take field
    pub fn take_jsondata(&mut self) -> ::std::string::String {
        self.jsondata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool published = 16;

    pub fn published(&self) -> bool {
        self.published.unwrap_or(false)
    }

    pub fn clear_published(&mut self) {
        self.published = ::std::option::Option::None;
    }

    pub fn has_published(&self) -> bool {
        self.published.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published(&mut self, v: bool) {
        self.published = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 17;

    pub fn hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }

    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_visibility_start = 18;

    pub fn rtime32_visibility_start(&self) -> u32 {
        self.rtime32_visibility_start.unwrap_or(0)
    }

    pub fn clear_rtime32_visibility_start(&mut self) {
        self.rtime32_visibility_start = ::std::option::Option::None;
    }

    pub fn has_rtime32_visibility_start(&self) -> bool {
        self.rtime32_visibility_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_visibility_start(&mut self, v: u32) {
        self.rtime32_visibility_start = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_visibility_end = 19;

    pub fn rtime32_visibility_end(&self) -> u32 {
        self.rtime32_visibility_end.unwrap_or(0)
    }

    pub fn clear_rtime32_visibility_end(&mut self) {
        self.rtime32_visibility_end = ::std::option::Option::None;
    }

    pub fn has_rtime32_visibility_end(&self) -> bool {
        self.rtime32_visibility_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_visibility_end(&mut self, v: u32) {
        self.rtime32_visibility_end = ::std::option::Option::Some(v);
    }

    // optional uint32 broadcaster_accountid = 20;

    pub fn broadcaster_accountid(&self) -> u32 {
        self.broadcaster_accountid.unwrap_or(0)
    }

    pub fn clear_broadcaster_accountid(&mut self) {
        self.broadcaster_accountid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_accountid(&self) -> bool {
        self.broadcaster_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_accountid(&mut self, v: u32) {
        self.broadcaster_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 follower_count = 21;

    pub fn follower_count(&self) -> u32 {
        self.follower_count.unwrap_or(0)
    }

    pub fn clear_follower_count(&mut self) {
        self.follower_count = ::std::option::Option::None;
    }

    pub fn has_follower_count(&self) -> bool {
        self.follower_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follower_count(&mut self, v: u32) {
        self.follower_count = ::std::option::Option::Some(v);
    }

    // optional uint32 ignore_count = 22;

    pub fn ignore_count(&self) -> u32 {
        self.ignore_count.unwrap_or(0)
    }

    pub fn clear_ignore_count(&mut self) {
        self.ignore_count = ::std::option::Option::None;
    }

    pub fn has_ignore_count(&self) -> bool {
        self.ignore_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_count(&mut self, v: u32) {
        self.ignore_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 23;

    pub fn forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }

    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_last_modified = 24;

    pub fn rtime32_last_modified(&self) -> u32 {
        self.rtime32_last_modified.unwrap_or(0)
    }

    pub fn clear_rtime32_last_modified(&mut self) {
        self.rtime32_last_modified = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_modified(&self) -> bool {
        self.rtime32_last_modified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_modified(&mut self, v: u32) {
        self.rtime32_last_modified = ::std::option::Option::Some(v);
    }

    // optional fixed64 news_post_gid = 25;

    pub fn news_post_gid(&self) -> u64 {
        self.news_post_gid.unwrap_or(0)
    }

    pub fn clear_news_post_gid(&mut self) {
        self.news_post_gid = ::std::option::Option::None;
    }

    pub fn has_news_post_gid(&self) -> bool {
        self.news_post_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_news_post_gid(&mut self, v: u64) {
        self.news_post_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_mod_reviewed = 26;

    pub fn rtime_mod_reviewed(&self) -> u32 {
        self.rtime_mod_reviewed.unwrap_or(0)
    }

    pub fn clear_rtime_mod_reviewed(&mut self) {
        self.rtime_mod_reviewed = ::std::option::Option::None;
    }

    pub fn has_rtime_mod_reviewed(&self) -> bool {
        self.rtime_mod_reviewed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_mod_reviewed(&mut self, v: u32) {
        self.rtime_mod_reviewed = ::std::option::Option::Some(v);
    }

    // optional uint32 featured_app_tagid = 27;

    pub fn featured_app_tagid(&self) -> u32 {
        self.featured_app_tagid.unwrap_or(0)
    }

    pub fn clear_featured_app_tagid(&mut self) {
        self.featured_app_tagid = ::std::option::Option::None;
    }

    pub fn has_featured_app_tagid(&self) -> bool {
        self.featured_app_tagid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_app_tagid(&mut self, v: u32) {
        self.featured_app_tagid = ::std::option::Option::Some(v);
    }

    // optional uint32 build_id = 29;

    pub fn build_id(&self) -> u32 {
        self.build_id.unwrap_or(0)
    }

    pub fn clear_build_id(&mut self) {
        self.build_id = ::std::option::Option::None;
    }

    pub fn has_build_id(&self) -> bool {
        self.build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: u32) {
        self.build_id = ::std::option::Option::Some(v);
    }

    // optional string build_branch = 30;

    pub fn build_branch(&self) -> &str {
        match self.build_branch.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_build_branch(&mut self) {
        self.build_branch = ::std::option::Option::None;
    }

    pub fn has_build_branch(&self) -> bool {
        self.build_branch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_branch(&mut self, v: ::std::string::String) {
        self.build_branch = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_branch(&mut self) -> &mut ::std::string::String {
        if self.build_branch.is_none() {
            self.build_branch = ::std::option::Option::Some(::std::string::String::new());
        }
        self.build_branch.as_mut().unwrap()
    }

    // Take field
    pub fn take_build_branch(&mut self) -> ::std::string::String {
        self.build_branch.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(30);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CClanEventData| { &m.gid },
            |m: &mut CClanEventData| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clan_steamid",
            |m: &CClanEventData| { &m.clan_steamid },
            |m: &mut CClanEventData| { &mut m.clan_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &CClanEventData| { &m.event_name },
            |m: &mut CClanEventData| { &mut m.event_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &CClanEventData| { &m.event_type },
            |m: &mut CClanEventData| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CClanEventData| { &m.appid },
            |m: &mut CClanEventData| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_address",
            |m: &CClanEventData| { &m.server_address },
            |m: &mut CClanEventData| { &mut m.server_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_password",
            |m: &CClanEventData| { &m.server_password },
            |m: &mut CClanEventData| { &mut m.server_password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_start_time",
            |m: &CClanEventData| { &m.rtime32_start_time },
            |m: &mut CClanEventData| { &mut m.rtime32_start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_end_time",
            |m: &CClanEventData| { &m.rtime32_end_time },
            |m: &mut CClanEventData| { &mut m.rtime32_end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment_count",
            |m: &CClanEventData| { &m.comment_count },
            |m: &mut CClanEventData| { &mut m.comment_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creator_steamid",
            |m: &CClanEventData| { &m.creator_steamid },
            |m: &mut CClanEventData| { &mut m.creator_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_update_steamid",
            |m: &CClanEventData| { &m.last_update_steamid },
            |m: &mut CClanEventData| { &mut m.last_update_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_notes",
            |m: &CClanEventData| { &m.event_notes },
            |m: &mut CClanEventData| { &mut m.event_notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jsondata",
            |m: &CClanEventData| { &m.jsondata },
            |m: &mut CClanEventData| { &mut m.jsondata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CCommunity_ClanAnnouncementInfo>(
            "announcement_body",
            |m: &CClanEventData| { &m.announcement_body },
            |m: &mut CClanEventData| { &mut m.announcement_body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published",
            |m: &CClanEventData| { &m.published },
            |m: &mut CClanEventData| { &mut m.published },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hidden",
            |m: &CClanEventData| { &m.hidden },
            |m: &mut CClanEventData| { &mut m.hidden },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_visibility_start",
            |m: &CClanEventData| { &m.rtime32_visibility_start },
            |m: &mut CClanEventData| { &mut m.rtime32_visibility_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_visibility_end",
            |m: &CClanEventData| { &m.rtime32_visibility_end },
            |m: &mut CClanEventData| { &mut m.rtime32_visibility_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcaster_accountid",
            |m: &CClanEventData| { &m.broadcaster_accountid },
            |m: &mut CClanEventData| { &mut m.broadcaster_accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "follower_count",
            |m: &CClanEventData| { &m.follower_count },
            |m: &mut CClanEventData| { &mut m.follower_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ignore_count",
            |m: &CClanEventData| { &m.ignore_count },
            |m: &mut CClanEventData| { &mut m.ignore_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "forum_topic_id",
            |m: &CClanEventData| { &m.forum_topic_id },
            |m: &mut CClanEventData| { &mut m.forum_topic_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_last_modified",
            |m: &CClanEventData| { &m.rtime32_last_modified },
            |m: &mut CClanEventData| { &mut m.rtime32_last_modified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "news_post_gid",
            |m: &CClanEventData| { &m.news_post_gid },
            |m: &mut CClanEventData| { &mut m.news_post_gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_mod_reviewed",
            |m: &CClanEventData| { &m.rtime_mod_reviewed },
            |m: &mut CClanEventData| { &mut m.rtime_mod_reviewed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "featured_app_tagid",
            |m: &CClanEventData| { &m.featured_app_tagid },
            |m: &mut CClanEventData| { &mut m.featured_app_tagid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "referenced_appids",
            |m: &CClanEventData| { &m.referenced_appids },
            |m: &mut CClanEventData| { &mut m.referenced_appids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_id",
            |m: &CClanEventData| { &m.build_id },
            |m: &mut CClanEventData| { &mut m.build_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_branch",
            |m: &CClanEventData| { &m.build_branch },
            |m: &mut CClanEventData| { &mut m.build_branch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClanEventData>(
            "CClanEventData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClanEventData {
    const NAME: &'static str = "CClanEventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.clan_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.event_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.server_address = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.server_password = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.rtime32_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.rtime32_end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.comment_count = ::std::option::Option::Some(is.read_int32()?);
                },
                89 => {
                    self.creator_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                97 => {
                    self.last_update_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                106 => {
                    self.event_notes = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.jsondata = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.announcement_body)?;
                },
                128 => {
                    self.published = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.hidden = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.rtime32_visibility_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.rtime32_visibility_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.broadcaster_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.follower_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.ignore_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                185 => {
                    self.forum_topic_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                192 => {
                    self.rtime32_last_modified = ::std::option::Option::Some(is.read_uint32()?);
                },
                201 => {
                    self.news_post_gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                208 => {
                    self.rtime_mod_reviewed = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.featured_app_tagid = ::std::option::Option::Some(is.read_uint32()?);
                },
                226 => {
                    is.read_repeated_packed_uint32_into(&mut self.referenced_appids)?;
                },
                224 => {
                    self.referenced_appids.push(is.read_uint32()?);
                },
                232 => {
                    self.build_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    self.build_branch = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.clan_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.server_address.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.server_password.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.rtime32_start_time {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.rtime32_end_time {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.comment_count {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.creator_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.last_update_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.event_notes.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.jsondata.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.announcement_body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.published {
            my_size += 2 + 1;
        }
        if let Some(v) = self.hidden {
            my_size += 2 + 1;
        }
        if let Some(v) = self.rtime32_visibility_start {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.rtime32_visibility_end {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.broadcaster_accountid {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.follower_count {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.ignore_count {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rtime32_last_modified {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.news_post_gid {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rtime_mod_reviewed {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.featured_app_tagid {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        for value in &self.referenced_appids {
            my_size += ::protobuf::rt::uint32_size(28, *value);
        };
        if let Some(v) = self.build_id {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.build_branch.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.clan_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.server_address.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.server_password.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.rtime32_start_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.rtime32_end_time {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.comment_count {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.creator_steamid {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.last_update_steamid {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.event_notes.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.jsondata.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.announcement_body.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.published {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.rtime32_visibility_start {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.rtime32_visibility_end {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.broadcaster_accountid {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.follower_count {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.ignore_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(23, v)?;
        }
        if let Some(v) = self.rtime32_last_modified {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.news_post_gid {
            os.write_fixed64(25, v)?;
        }
        if let Some(v) = self.rtime_mod_reviewed {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.featured_app_tagid {
            os.write_uint32(27, v)?;
        }
        for v in &self.referenced_appids {
            os.write_uint32(28, *v)?;
        };
        if let Some(v) = self.build_id {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.build_branch.as_ref() {
            os.write_string(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanEventData {
        CClanEventData::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clan_steamid = ::std::option::Option::None;
        self.event_name = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.server_address = ::std::option::Option::None;
        self.server_password = ::std::option::Option::None;
        self.rtime32_start_time = ::std::option::Option::None;
        self.rtime32_end_time = ::std::option::Option::None;
        self.comment_count = ::std::option::Option::None;
        self.creator_steamid = ::std::option::Option::None;
        self.last_update_steamid = ::std::option::Option::None;
        self.event_notes = ::std::option::Option::None;
        self.jsondata = ::std::option::Option::None;
        self.announcement_body.clear();
        self.published = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.rtime32_visibility_start = ::std::option::Option::None;
        self.rtime32_visibility_end = ::std::option::Option::None;
        self.broadcaster_accountid = ::std::option::Option::None;
        self.follower_count = ::std::option::Option::None;
        self.ignore_count = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.rtime32_last_modified = ::std::option::Option::None;
        self.news_post_gid = ::std::option::Option::None;
        self.rtime_mod_reviewed = ::std::option::Option::None;
        self.featured_app_tagid = ::std::option::Option::None;
        self.referenced_appids.clear();
        self.build_id = ::std::option::Option::None;
        self.build_branch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanEventData {
        static instance: CClanEventData = CClanEventData {
            gid: ::std::option::Option::None,
            clan_steamid: ::std::option::Option::None,
            event_name: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            server_address: ::std::option::Option::None,
            server_password: ::std::option::Option::None,
            rtime32_start_time: ::std::option::Option::None,
            rtime32_end_time: ::std::option::Option::None,
            comment_count: ::std::option::Option::None,
            creator_steamid: ::std::option::Option::None,
            last_update_steamid: ::std::option::Option::None,
            event_notes: ::std::option::Option::None,
            jsondata: ::std::option::Option::None,
            announcement_body: ::protobuf::MessageField::none(),
            published: ::std::option::Option::None,
            hidden: ::std::option::Option::None,
            rtime32_visibility_start: ::std::option::Option::None,
            rtime32_visibility_end: ::std::option::Option::None,
            broadcaster_accountid: ::std::option::Option::None,
            follower_count: ::std::option::Option::None,
            ignore_count: ::std::option::Option::None,
            forum_topic_id: ::std::option::Option::None,
            rtime32_last_modified: ::std::option::Option::None,
            news_post_gid: ::std::option::Option::None,
            rtime_mod_reviewed: ::std::option::Option::None,
            featured_app_tagid: ::std::option::Option::None,
            referenced_appids: ::std::vec::Vec::new(),
            build_id: ::std::option::Option::None,
            build_branch: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClanEventData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanEventData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanEventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanEventData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CBilling_Address)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBilling_Address {
    // message fields
    // @@protoc_insertion_point(field:CBilling_Address.first_name)
    pub first_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.last_name)
    pub last_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.address1)
    pub address1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.address2)
    pub address2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.city)
    pub city: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.us_state)
    pub us_state: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.postcode)
    pub postcode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CBilling_Address.zip_plus4)
    pub zip_plus4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBilling_Address.phone)
    pub phone: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CBilling_Address.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBilling_Address {
    fn default() -> &'a CBilling_Address {
        <CBilling_Address as ::protobuf::Message>::default_instance()
    }
}

impl CBilling_Address {
    pub fn new() -> CBilling_Address {
        ::std::default::Default::default()
    }

    // optional string first_name = 1;

    pub fn first_name(&self) -> &str {
        match self.first_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_first_name(&mut self) {
        self.first_name = ::std::option::Option::None;
    }

    pub fn has_first_name(&self) -> bool {
        self.first_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_name(&mut self, v: ::std::string::String) {
        self.first_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_name(&mut self) -> &mut ::std::string::String {
        if self.first_name.is_none() {
            self.first_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.first_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_first_name(&mut self) -> ::std::string::String {
        self.first_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string last_name = 2;

    pub fn last_name(&self) -> &str {
        match self.last_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_name(&mut self) {
        self.last_name = ::std::option::Option::None;
    }

    pub fn has_last_name(&self) -> bool {
        self.last_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_name(&mut self, v: ::std::string::String) {
        self.last_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_name(&mut self) -> &mut ::std::string::String {
        if self.last_name.is_none() {
            self.last_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_name(&mut self) -> ::std::string::String {
        self.last_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address1 = 3;

    pub fn address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address1(&mut self) {
        self.address1 = ::std::option::Option::None;
    }

    pub fn has_address1(&self) -> bool {
        self.address1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address1(&mut self, v: ::std::string::String) {
        self.address1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address1(&mut self) -> &mut ::std::string::String {
        if self.address1.is_none() {
            self.address1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address1.as_mut().unwrap()
    }

    // Take field
    pub fn take_address1(&mut self) -> ::std::string::String {
        self.address1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address2 = 4;

    pub fn address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address2(&mut self) {
        self.address2 = ::std::option::Option::None;
    }

    pub fn has_address2(&self) -> bool {
        self.address2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address2(&mut self, v: ::std::string::String) {
        self.address2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address2(&mut self) -> &mut ::std::string::String {
        if self.address2.is_none() {
            self.address2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address2.as_mut().unwrap()
    }

    // Take field
    pub fn take_address2(&mut self) -> ::std::string::String {
        self.address2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city = 5;

    pub fn city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_city(&mut self) {
        self.city = ::std::option::Option::None;
    }

    pub fn has_city(&self) -> bool {
        self.city.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city(&mut self, v: ::std::string::String) {
        self.city = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city(&mut self) -> &mut ::std::string::String {
        if self.city.is_none() {
            self.city = ::std::option::Option::Some(::std::string::String::new());
        }
        self.city.as_mut().unwrap()
    }

    // Take field
    pub fn take_city(&mut self) -> ::std::string::String {
        self.city.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string us_state = 6;

    pub fn us_state(&self) -> &str {
        match self.us_state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_us_state(&mut self) {
        self.us_state = ::std::option::Option::None;
    }

    pub fn has_us_state(&self) -> bool {
        self.us_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_us_state(&mut self, v: ::std::string::String) {
        self.us_state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_us_state(&mut self) -> &mut ::std::string::String {
        if self.us_state.is_none() {
            self.us_state = ::std::option::Option::Some(::std::string::String::new());
        }
        self.us_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_us_state(&mut self) -> ::std::string::String {
        self.us_state.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_code = 7;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postcode = 8;

    pub fn postcode(&self) -> &str {
        match self.postcode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_postcode(&mut self) {
        self.postcode = ::std::option::Option::None;
    }

    pub fn has_postcode(&self) -> bool {
        self.postcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postcode(&mut self, v: ::std::string::String) {
        self.postcode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postcode(&mut self) -> &mut ::std::string::String {
        if self.postcode.is_none() {
            self.postcode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.postcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_postcode(&mut self) -> ::std::string::String {
        self.postcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 zip_plus4 = 9;

    pub fn zip_plus4(&self) -> i32 {
        self.zip_plus4.unwrap_or(0)
    }

    pub fn clear_zip_plus4(&mut self) {
        self.zip_plus4 = ::std::option::Option::None;
    }

    pub fn has_zip_plus4(&self) -> bool {
        self.zip_plus4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zip_plus4(&mut self, v: i32) {
        self.zip_plus4 = ::std::option::Option::Some(v);
    }

    // optional string phone = 10;

    pub fn phone(&self) -> &str {
        match self.phone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phone(&mut self) {
        self.phone = ::std::option::Option::None;
    }

    pub fn has_phone(&self) -> bool {
        self.phone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone(&mut self, v: ::std::string::String) {
        self.phone = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phone(&mut self) -> &mut ::std::string::String {
        if self.phone.is_none() {
            self.phone = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phone.as_mut().unwrap()
    }

    // Take field
    pub fn take_phone(&mut self) -> ::std::string::String {
        self.phone.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_name",
            |m: &CBilling_Address| { &m.first_name },
            |m: &mut CBilling_Address| { &mut m.first_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_name",
            |m: &CBilling_Address| { &m.last_name },
            |m: &mut CBilling_Address| { &mut m.last_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address1",
            |m: &CBilling_Address| { &m.address1 },
            |m: &mut CBilling_Address| { &mut m.address1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address2",
            |m: &CBilling_Address| { &m.address2 },
            |m: &mut CBilling_Address| { &mut m.address2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "city",
            |m: &CBilling_Address| { &m.city },
            |m: &mut CBilling_Address| { &mut m.city },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "us_state",
            |m: &CBilling_Address| { &m.us_state },
            |m: &mut CBilling_Address| { &mut m.us_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CBilling_Address| { &m.country_code },
            |m: &mut CBilling_Address| { &mut m.country_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "postcode",
            |m: &CBilling_Address| { &m.postcode },
            |m: &mut CBilling_Address| { &mut m.postcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "zip_plus4",
            |m: &CBilling_Address| { &m.zip_plus4 },
            |m: &mut CBilling_Address| { &mut m.zip_plus4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phone",
            |m: &CBilling_Address| { &m.phone },
            |m: &mut CBilling_Address| { &mut m.phone },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBilling_Address>(
            "CBilling_Address",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CBilling_Address {
    const NAME: &'static str = "CBilling_Address";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.first_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.last_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.address1 = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.address2 = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.city = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.us_state = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.postcode = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.zip_plus4 = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.phone = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.first_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.last_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.address1.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.address2.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.us_state.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.postcode.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.zip_plus4 {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.phone.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.first_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.last_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.address1.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.address2.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.city.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.us_state.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.postcode.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.zip_plus4 {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.phone.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBilling_Address {
        CBilling_Address::new()
    }

    fn clear(&mut self) {
        self.first_name = ::std::option::Option::None;
        self.last_name = ::std::option::Option::None;
        self.address1 = ::std::option::Option::None;
        self.address2 = ::std::option::Option::None;
        self.city = ::std::option::Option::None;
        self.us_state = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.postcode = ::std::option::Option::None;
        self.zip_plus4 = ::std::option::Option::None;
        self.phone = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBilling_Address {
        static instance: CBilling_Address = CBilling_Address {
            first_name: ::std::option::Option::None,
            last_name: ::std::option::Option::None,
            address1: ::std::option::Option::None,
            address2: ::std::option::Option::None,
            city: ::std::option::Option::None,
            us_state: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            postcode: ::std::option::Option::None,
            zip_plus4: ::std::option::Option::None,
            phone: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CBilling_Address {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBilling_Address").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBilling_Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBilling_Address {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CPackageReservationStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CPackageReservationStatus {
    // message fields
    // @@protoc_insertion_point(field:CPackageReservationStatus.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.reservation_state)
    pub reservation_state: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.queue_position)
    pub queue_position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.total_queue_size)
    pub total_queue_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.reservation_country_code)
    pub reservation_country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.expired)
    pub expired: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.time_expires)
    pub time_expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CPackageReservationStatus.time_reserved)
    pub time_reserved: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CPackageReservationStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPackageReservationStatus {
    fn default() -> &'a CPackageReservationStatus {
        <CPackageReservationStatus as ::protobuf::Message>::default_instance()
    }
}

impl CPackageReservationStatus {
    pub fn new() -> CPackageReservationStatus {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional int32 reservation_state = 2;

    pub fn reservation_state(&self) -> i32 {
        self.reservation_state.unwrap_or(0)
    }

    pub fn clear_reservation_state(&mut self) {
        self.reservation_state = ::std::option::Option::None;
    }

    pub fn has_reservation_state(&self) -> bool {
        self.reservation_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_state(&mut self, v: i32) {
        self.reservation_state = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;

    pub fn queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }

    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 total_queue_size = 4;

    pub fn total_queue_size(&self) -> i32 {
        self.total_queue_size.unwrap_or(0)
    }

    pub fn clear_total_queue_size(&mut self) {
        self.total_queue_size = ::std::option::Option::None;
    }

    pub fn has_total_queue_size(&self) -> bool {
        self.total_queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_queue_size(&mut self, v: i32) {
        self.total_queue_size = ::std::option::Option::Some(v);
    }

    // optional string reservation_country_code = 5;

    pub fn reservation_country_code(&self) -> &str {
        match self.reservation_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reservation_country_code(&mut self) {
        self.reservation_country_code = ::std::option::Option::None;
    }

    pub fn has_reservation_country_code(&self) -> bool {
        self.reservation_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_country_code(&mut self, v: ::std::string::String) {
        self.reservation_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation_country_code(&mut self) -> &mut ::std::string::String {
        if self.reservation_country_code.is_none() {
            self.reservation_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reservation_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation_country_code(&mut self) -> ::std::string::String {
        self.reservation_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool expired = 6;

    pub fn expired(&self) -> bool {
        self.expired.unwrap_or(false)
    }

    pub fn clear_expired(&mut self) {
        self.expired = ::std::option::Option::None;
    }

    pub fn has_expired(&self) -> bool {
        self.expired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expired(&mut self, v: bool) {
        self.expired = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 7;

    pub fn time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }

    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint32 time_reserved = 8;

    pub fn time_reserved(&self) -> u32 {
        self.time_reserved.unwrap_or(0)
    }

    pub fn clear_time_reserved(&mut self) {
        self.time_reserved = ::std::option::Option::None;
    }

    pub fn has_time_reserved(&self) -> bool {
        self.time_reserved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_reserved(&mut self, v: u32) {
        self.time_reserved = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packageid",
            |m: &CPackageReservationStatus| { &m.packageid },
            |m: &mut CPackageReservationStatus| { &mut m.packageid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservation_state",
            |m: &CPackageReservationStatus| { &m.reservation_state },
            |m: &mut CPackageReservationStatus| { &mut m.reservation_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_position",
            |m: &CPackageReservationStatus| { &m.queue_position },
            |m: &mut CPackageReservationStatus| { &mut m.queue_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_queue_size",
            |m: &CPackageReservationStatus| { &m.total_queue_size },
            |m: &mut CPackageReservationStatus| { &mut m.total_queue_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservation_country_code",
            |m: &CPackageReservationStatus| { &m.reservation_country_code },
            |m: &mut CPackageReservationStatus| { &mut m.reservation_country_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expired",
            |m: &CPackageReservationStatus| { &m.expired },
            |m: &mut CPackageReservationStatus| { &mut m.expired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_expires",
            |m: &CPackageReservationStatus| { &m.time_expires },
            |m: &mut CPackageReservationStatus| { &mut m.time_expires },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_reserved",
            |m: &CPackageReservationStatus| { &m.time_reserved },
            |m: &mut CPackageReservationStatus| { &mut m.time_reserved },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CPackageReservationStatus>(
            "CPackageReservationStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CPackageReservationStatus {
    const NAME: &'static str = "CPackageReservationStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reservation_state = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.total_queue_size = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.reservation_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.expired = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.time_reserved = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reservation_state {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.queue_position {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.total_queue_size {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.reservation_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.expired {
            my_size += 1 + 1;
        }
        if let Some(v) = self.time_expires {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.time_reserved {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reservation_state {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.total_queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.reservation_country_code.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.expired {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.time_reserved {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPackageReservationStatus {
        CPackageReservationStatus::new()
    }

    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.reservation_state = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.total_queue_size = ::std::option::Option::None;
        self.reservation_country_code = ::std::option::Option::None;
        self.expired = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.time_reserved = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPackageReservationStatus {
        static instance: CPackageReservationStatus = CPackageReservationStatus {
            packageid: ::std::option::Option::None,
            reservation_state: ::std::option::Option::None,
            queue_position: ::std::option::Option::None,
            total_queue_size: ::std::option::Option::None,
            reservation_country_code: ::std::option::Option::None,
            expired: ::std::option::Option::None,
            time_expires: ::std::option::Option::None,
            time_reserved: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CPackageReservationStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CPackageReservationStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CPackageReservationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPackageReservationStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgKeyValuePair)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyValuePair {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyValuePair.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgKeyValuePair.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyValuePair.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyValuePair {
    fn default() -> &'a CMsgKeyValuePair {
        <CMsgKeyValuePair as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyValuePair {
    pub fn new() -> CMsgKeyValuePair {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgKeyValuePair| { &m.name },
            |m: &mut CMsgKeyValuePair| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CMsgKeyValuePair| { &m.value },
            |m: &mut CMsgKeyValuePair| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyValuePair>(
            "CMsgKeyValuePair",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgKeyValuePair {
    const NAME: &'static str = "CMsgKeyValuePair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyValuePair {
        CMsgKeyValuePair::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyValuePair {
        static instance: CMsgKeyValuePair = CMsgKeyValuePair {
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgKeyValuePair {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyValuePair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyValuePair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKeyValuePair {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgKeyValueSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKeyValueSet {
    // message fields
    // @@protoc_insertion_point(field:CMsgKeyValueSet.pairs)
    pub pairs: ::std::vec::Vec<CMsgKeyValuePair>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKeyValueSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKeyValueSet {
    fn default() -> &'a CMsgKeyValueSet {
        <CMsgKeyValueSet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgKeyValueSet {
    pub fn new() -> CMsgKeyValueSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pairs",
            |m: &CMsgKeyValueSet| { &m.pairs },
            |m: &mut CMsgKeyValueSet| { &mut m.pairs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgKeyValueSet>(
            "CMsgKeyValueSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgKeyValueSet {
    const NAME: &'static str = "CMsgKeyValueSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pairs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pairs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pairs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKeyValueSet {
        CMsgKeyValueSet::new()
    }

    fn clear(&mut self) {
        self.pairs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKeyValueSet {
        static instance: CMsgKeyValueSet = CMsgKeyValueSet {
            pairs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgKeyValueSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgKeyValueSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgKeyValueSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgKeyValueSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBanContentCheckResult)
pub enum EBanContentCheckResult {
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_NotScanned)
    k_EBanContentCheckResult_NotScanned = 0,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Reset)
    k_EBanContentCheckResult_Reset = 1,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_NeedsChecking)
    k_EBanContentCheckResult_NeedsChecking = 2,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_VeryUnlikely)
    k_EBanContentCheckResult_VeryUnlikely = 5,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Unlikely)
    k_EBanContentCheckResult_Unlikely = 30,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Possible)
    k_EBanContentCheckResult_Possible = 50,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_Likely)
    k_EBanContentCheckResult_Likely = 75,
    // @@protoc_insertion_point(enum_value:EBanContentCheckResult.k_EBanContentCheckResult_VeryLikely)
    k_EBanContentCheckResult_VeryLikely = 100,
}

impl ::protobuf::Enum for EBanContentCheckResult {
    const NAME: &'static str = "EBanContentCheckResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBanContentCheckResult> {
        match value {
            0 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NotScanned),
            1 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Reset),
            2 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking),
            5 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely),
            30 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Unlikely),
            50 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Possible),
            75 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Likely),
            100 => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBanContentCheckResult> {
        match str {
            "k_EBanContentCheckResult_NotScanned" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NotScanned),
            "k_EBanContentCheckResult_Reset" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Reset),
            "k_EBanContentCheckResult_NeedsChecking" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking),
            "k_EBanContentCheckResult_VeryUnlikely" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely),
            "k_EBanContentCheckResult_Unlikely" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Unlikely),
            "k_EBanContentCheckResult_Possible" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Possible),
            "k_EBanContentCheckResult_Likely" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_Likely),
            "k_EBanContentCheckResult_VeryLikely" => ::std::option::Option::Some(EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBanContentCheckResult] = &[
        EBanContentCheckResult::k_EBanContentCheckResult_NotScanned,
        EBanContentCheckResult::k_EBanContentCheckResult_Reset,
        EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking,
        EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely,
        EBanContentCheckResult::k_EBanContentCheckResult_Unlikely,
        EBanContentCheckResult::k_EBanContentCheckResult_Possible,
        EBanContentCheckResult::k_EBanContentCheckResult_Likely,
        EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely,
    ];
}

impl ::protobuf::EnumFull for EBanContentCheckResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBanContentCheckResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EBanContentCheckResult::k_EBanContentCheckResult_NotScanned => 0,
            EBanContentCheckResult::k_EBanContentCheckResult_Reset => 1,
            EBanContentCheckResult::k_EBanContentCheckResult_NeedsChecking => 2,
            EBanContentCheckResult::k_EBanContentCheckResult_VeryUnlikely => 3,
            EBanContentCheckResult::k_EBanContentCheckResult_Unlikely => 4,
            EBanContentCheckResult::k_EBanContentCheckResult_Possible => 5,
            EBanContentCheckResult::k_EBanContentCheckResult_Likely => 6,
            EBanContentCheckResult::k_EBanContentCheckResult_VeryLikely => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EBanContentCheckResult {
    fn default() -> Self {
        EBanContentCheckResult::k_EBanContentCheckResult_NotScanned
    }
}

impl EBanContentCheckResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EBanContentCheckResult>("EBanContentCheckResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProtoClanEventType)
pub enum EProtoClanEventType {
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanOtherEvent)
    k_EClanOtherEvent = 1,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameEvent)
    k_EClanGameEvent = 2,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanPartyEvent)
    k_EClanPartyEvent = 3,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanMeetingEvent)
    k_EClanMeetingEvent = 4,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSpecialCauseEvent)
    k_EClanSpecialCauseEvent = 5,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanMusicAndArtsEvent)
    k_EClanMusicAndArtsEvent = 6,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSportsEvent)
    k_EClanSportsEvent = 7,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanTripEvent)
    k_EClanTripEvent = 8,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanChatEvent)
    k_EClanChatEvent = 9,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameReleaseEvent)
    k_EClanGameReleaseEvent = 10,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanBroadcastEvent)
    k_EClanBroadcastEvent = 11,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSmallUpdateEvent)
    k_EClanSmallUpdateEvent = 12,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanPreAnnounceMajorUpdateEvent)
    k_EClanPreAnnounceMajorUpdateEvent = 13,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanMajorUpdateEvent)
    k_EClanMajorUpdateEvent = 14,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanDLCReleaseEvent)
    k_EClanDLCReleaseEvent = 15,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanFutureReleaseEvent)
    k_EClanFutureReleaseEvent = 16,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanESportTournamentStreamEvent)
    k_EClanESportTournamentStreamEvent = 17,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanDevStreamEvent)
    k_EClanDevStreamEvent = 18,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanFamousStreamEvent)
    k_EClanFamousStreamEvent = 19,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameSalesEvent)
    k_EClanGameSalesEvent = 20,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanGameItemSalesEvent)
    k_EClanGameItemSalesEvent = 21,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameBonusXPEvent)
    k_EClanInGameBonusXPEvent = 22,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameLootEvent)
    k_EClanInGameLootEvent = 23,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGamePerksEvent)
    k_EClanInGamePerksEvent = 24,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameChallengeEvent)
    k_EClanInGameChallengeEvent = 25,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameContestEvent)
    k_EClanInGameContestEvent = 26,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanIRLEvent)
    k_EClanIRLEvent = 27,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanNewsEvent)
    k_EClanNewsEvent = 28,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanBetaReleaseEvent)
    k_EClanBetaReleaseEvent = 29,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameContentReleaseEvent)
    k_EClanInGameContentReleaseEvent = 30,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanFreeTrial)
    k_EClanFreeTrial = 31,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSeasonRelease)
    k_EClanSeasonRelease = 32,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanSeasonUpdate)
    k_EClanSeasonUpdate = 33,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanCrosspostEvent)
    k_EClanCrosspostEvent = 34,
    // @@protoc_insertion_point(enum_value:EProtoClanEventType.k_EClanInGameEventGeneral)
    k_EClanInGameEventGeneral = 35,
}

impl ::protobuf::Enum for EProtoClanEventType {
    const NAME: &'static str = "EProtoClanEventType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProtoClanEventType> {
        match value {
            1 => ::std::option::Option::Some(EProtoClanEventType::k_EClanOtherEvent),
            2 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameEvent),
            3 => ::std::option::Option::Some(EProtoClanEventType::k_EClanPartyEvent),
            4 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMeetingEvent),
            5 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSpecialCauseEvent),
            6 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMusicAndArtsEvent),
            7 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSportsEvent),
            8 => ::std::option::Option::Some(EProtoClanEventType::k_EClanTripEvent),
            9 => ::std::option::Option::Some(EProtoClanEventType::k_EClanChatEvent),
            10 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameReleaseEvent),
            11 => ::std::option::Option::Some(EProtoClanEventType::k_EClanBroadcastEvent),
            12 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSmallUpdateEvent),
            13 => ::std::option::Option::Some(EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent),
            14 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMajorUpdateEvent),
            15 => ::std::option::Option::Some(EProtoClanEventType::k_EClanDLCReleaseEvent),
            16 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFutureReleaseEvent),
            17 => ::std::option::Option::Some(EProtoClanEventType::k_EClanESportTournamentStreamEvent),
            18 => ::std::option::Option::Some(EProtoClanEventType::k_EClanDevStreamEvent),
            19 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFamousStreamEvent),
            20 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameSalesEvent),
            21 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameItemSalesEvent),
            22 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameBonusXPEvent),
            23 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameLootEvent),
            24 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGamePerksEvent),
            25 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameChallengeEvent),
            26 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContestEvent),
            27 => ::std::option::Option::Some(EProtoClanEventType::k_EClanIRLEvent),
            28 => ::std::option::Option::Some(EProtoClanEventType::k_EClanNewsEvent),
            29 => ::std::option::Option::Some(EProtoClanEventType::k_EClanBetaReleaseEvent),
            30 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContentReleaseEvent),
            31 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFreeTrial),
            32 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonRelease),
            33 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonUpdate),
            34 => ::std::option::Option::Some(EProtoClanEventType::k_EClanCrosspostEvent),
            35 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameEventGeneral),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProtoClanEventType> {
        match str {
            "k_EClanOtherEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanOtherEvent),
            "k_EClanGameEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameEvent),
            "k_EClanPartyEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanPartyEvent),
            "k_EClanMeetingEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanMeetingEvent),
            "k_EClanSpecialCauseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSpecialCauseEvent),
            "k_EClanMusicAndArtsEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanMusicAndArtsEvent),
            "k_EClanSportsEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSportsEvent),
            "k_EClanTripEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanTripEvent),
            "k_EClanChatEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanChatEvent),
            "k_EClanGameReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameReleaseEvent),
            "k_EClanBroadcastEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanBroadcastEvent),
            "k_EClanSmallUpdateEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSmallUpdateEvent),
            "k_EClanPreAnnounceMajorUpdateEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent),
            "k_EClanMajorUpdateEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanMajorUpdateEvent),
            "k_EClanDLCReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanDLCReleaseEvent),
            "k_EClanFutureReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanFutureReleaseEvent),
            "k_EClanESportTournamentStreamEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanESportTournamentStreamEvent),
            "k_EClanDevStreamEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanDevStreamEvent),
            "k_EClanFamousStreamEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanFamousStreamEvent),
            "k_EClanGameSalesEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameSalesEvent),
            "k_EClanGameItemSalesEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameItemSalesEvent),
            "k_EClanInGameBonusXPEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameBonusXPEvent),
            "k_EClanInGameLootEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameLootEvent),
            "k_EClanInGamePerksEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGamePerksEvent),
            "k_EClanInGameChallengeEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameChallengeEvent),
            "k_EClanInGameContestEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContestEvent),
            "k_EClanIRLEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanIRLEvent),
            "k_EClanNewsEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanNewsEvent),
            "k_EClanBetaReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanBetaReleaseEvent),
            "k_EClanInGameContentReleaseEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContentReleaseEvent),
            "k_EClanFreeTrial" => ::std::option::Option::Some(EProtoClanEventType::k_EClanFreeTrial),
            "k_EClanSeasonRelease" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonRelease),
            "k_EClanSeasonUpdate" => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonUpdate),
            "k_EClanCrosspostEvent" => ::std::option::Option::Some(EProtoClanEventType::k_EClanCrosspostEvent),
            "k_EClanInGameEventGeneral" => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameEventGeneral),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProtoClanEventType] = &[
        EProtoClanEventType::k_EClanOtherEvent,
        EProtoClanEventType::k_EClanGameEvent,
        EProtoClanEventType::k_EClanPartyEvent,
        EProtoClanEventType::k_EClanMeetingEvent,
        EProtoClanEventType::k_EClanSpecialCauseEvent,
        EProtoClanEventType::k_EClanMusicAndArtsEvent,
        EProtoClanEventType::k_EClanSportsEvent,
        EProtoClanEventType::k_EClanTripEvent,
        EProtoClanEventType::k_EClanChatEvent,
        EProtoClanEventType::k_EClanGameReleaseEvent,
        EProtoClanEventType::k_EClanBroadcastEvent,
        EProtoClanEventType::k_EClanSmallUpdateEvent,
        EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent,
        EProtoClanEventType::k_EClanMajorUpdateEvent,
        EProtoClanEventType::k_EClanDLCReleaseEvent,
        EProtoClanEventType::k_EClanFutureReleaseEvent,
        EProtoClanEventType::k_EClanESportTournamentStreamEvent,
        EProtoClanEventType::k_EClanDevStreamEvent,
        EProtoClanEventType::k_EClanFamousStreamEvent,
        EProtoClanEventType::k_EClanGameSalesEvent,
        EProtoClanEventType::k_EClanGameItemSalesEvent,
        EProtoClanEventType::k_EClanInGameBonusXPEvent,
        EProtoClanEventType::k_EClanInGameLootEvent,
        EProtoClanEventType::k_EClanInGamePerksEvent,
        EProtoClanEventType::k_EClanInGameChallengeEvent,
        EProtoClanEventType::k_EClanInGameContestEvent,
        EProtoClanEventType::k_EClanIRLEvent,
        EProtoClanEventType::k_EClanNewsEvent,
        EProtoClanEventType::k_EClanBetaReleaseEvent,
        EProtoClanEventType::k_EClanInGameContentReleaseEvent,
        EProtoClanEventType::k_EClanFreeTrial,
        EProtoClanEventType::k_EClanSeasonRelease,
        EProtoClanEventType::k_EClanSeasonUpdate,
        EProtoClanEventType::k_EClanCrosspostEvent,
        EProtoClanEventType::k_EClanInGameEventGeneral,
    ];
}

impl ::protobuf::EnumFull for EProtoClanEventType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EProtoClanEventType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EProtoClanEventType::k_EClanOtherEvent => 0,
            EProtoClanEventType::k_EClanGameEvent => 1,
            EProtoClanEventType::k_EClanPartyEvent => 2,
            EProtoClanEventType::k_EClanMeetingEvent => 3,
            EProtoClanEventType::k_EClanSpecialCauseEvent => 4,
            EProtoClanEventType::k_EClanMusicAndArtsEvent => 5,
            EProtoClanEventType::k_EClanSportsEvent => 6,
            EProtoClanEventType::k_EClanTripEvent => 7,
            EProtoClanEventType::k_EClanChatEvent => 8,
            EProtoClanEventType::k_EClanGameReleaseEvent => 9,
            EProtoClanEventType::k_EClanBroadcastEvent => 10,
            EProtoClanEventType::k_EClanSmallUpdateEvent => 11,
            EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent => 12,
            EProtoClanEventType::k_EClanMajorUpdateEvent => 13,
            EProtoClanEventType::k_EClanDLCReleaseEvent => 14,
            EProtoClanEventType::k_EClanFutureReleaseEvent => 15,
            EProtoClanEventType::k_EClanESportTournamentStreamEvent => 16,
            EProtoClanEventType::k_EClanDevStreamEvent => 17,
            EProtoClanEventType::k_EClanFamousStreamEvent => 18,
            EProtoClanEventType::k_EClanGameSalesEvent => 19,
            EProtoClanEventType::k_EClanGameItemSalesEvent => 20,
            EProtoClanEventType::k_EClanInGameBonusXPEvent => 21,
            EProtoClanEventType::k_EClanInGameLootEvent => 22,
            EProtoClanEventType::k_EClanInGamePerksEvent => 23,
            EProtoClanEventType::k_EClanInGameChallengeEvent => 24,
            EProtoClanEventType::k_EClanInGameContestEvent => 25,
            EProtoClanEventType::k_EClanIRLEvent => 26,
            EProtoClanEventType::k_EClanNewsEvent => 27,
            EProtoClanEventType::k_EClanBetaReleaseEvent => 28,
            EProtoClanEventType::k_EClanInGameContentReleaseEvent => 29,
            EProtoClanEventType::k_EClanFreeTrial => 30,
            EProtoClanEventType::k_EClanSeasonRelease => 31,
            EProtoClanEventType::k_EClanSeasonUpdate => 32,
            EProtoClanEventType::k_EClanCrosspostEvent => 33,
            EProtoClanEventType::k_EClanInGameEventGeneral => 34,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EProtoClanEventType {
    fn default() -> Self {
        EProtoClanEventType::k_EClanOtherEvent
    }
}

impl EProtoClanEventType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EProtoClanEventType>("EProtoClanEventType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PartnerEventNotificationType)
pub enum PartnerEventNotificationType {
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventStart)
    k_EEventStart = 0,
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventBroadcastStart)
    k_EEventBroadcastStart = 1,
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventMatchStart)
    k_EEventMatchStart = 2,
    // @@protoc_insertion_point(enum_value:PartnerEventNotificationType.k_EEventPartnerMaxType)
    k_EEventPartnerMaxType = 3,
}

impl ::protobuf::Enum for PartnerEventNotificationType {
    const NAME: &'static str = "PartnerEventNotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartnerEventNotificationType> {
        match value {
            0 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventStart),
            1 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventBroadcastStart),
            2 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventMatchStart),
            3 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventPartnerMaxType),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PartnerEventNotificationType> {
        match str {
            "k_EEventStart" => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventStart),
            "k_EEventBroadcastStart" => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventBroadcastStart),
            "k_EEventMatchStart" => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventMatchStart),
            "k_EEventPartnerMaxType" => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventPartnerMaxType),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PartnerEventNotificationType] = &[
        PartnerEventNotificationType::k_EEventStart,
        PartnerEventNotificationType::k_EEventBroadcastStart,
        PartnerEventNotificationType::k_EEventMatchStart,
        PartnerEventNotificationType::k_EEventPartnerMaxType,
    ];
}

impl ::protobuf::EnumFull for PartnerEventNotificationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PartnerEventNotificationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PartnerEventNotificationType {
    fn default() -> Self {
        PartnerEventNotificationType::k_EEventStart
    }
}

impl PartnerEventNotificationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PartnerEventNotificationType>("PartnerEventNotificationType")
    }
}

/// Extension fields
pub mod exts {

    pub const msgpool_soft_limit: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::MessageOptions, i32> = ::protobuf::ext::ExtFieldOptional::new(50000, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_INT32);

    pub const msgpool_hard_limit: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::MessageOptions, i32> = ::protobuf::ext::ExtFieldOptional::new(50001, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_INT32);

    pub const force_php_generation: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FileOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(50000, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const php_output_always_number: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(50020, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);

    pub const allow_field_named_steam_id: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::FieldOptions, bool> = ::protobuf::ext::ExtFieldOptional::new(50024, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_BOOL);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x18steammessages_base.proto\x1a\x20google/protobuf/descriptor.proto\"\
    9\n\rCMsgIPAddress\x12\x10\n\x02v4\x18\x01\x20\x01(\x07H\0R\x02v4\x12\
    \x10\n\x02v6\x18\x02\x20\x01(\x0cH\0R\x02v6B\x04\n\x02ip\"m\n\x13CMsgIPA\
    ddressBucket\x12>\n\x13original_ip_address\x18\x01\x20\x01(\x0b2\x0e.CMs\
    gIPAddressR\x11originalIpAddress\x12\x16\n\x06bucket\x18\x02\x20\x01(\
    \x06R\x06bucket\"l\n\x1bCMsgGCRoutingProtoBufHeader\x12$\n\x0edst_gcid_q\
    ueue\x18\x01\x20\x01(\x04R\x0cdstGcidQueue\x12'\n\x10dst_gc_dir_index\
    \x18\x02\x20\x01(\rR\rdstGcDirIndex\"\xa3\t\n\x12CMsgProtoBufHeader\x12\
    \x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12)\n\x10client_sess\
    ionid\x18\x02\x20\x01(\x05R\x0fclientSessionid\x12#\n\rrouting_appid\x18\
    \x03\x20\x01(\rR\x0croutingAppid\x127\n\x0cjobid_source\x18\n\x20\x01(\
    \x06:\x1418446744073709551615R\x0bjobidSource\x127\n\x0cjobid_target\x18\
    \x0b\x20\x01(\x06:\x1418446744073709551615R\x0bjobidTarget\x12&\n\x0ftar\
    get_job_name\x18\x0c\x20\x01(\tR\rtargetJobName\x12\x17\n\x07seq_num\x18\
    \x18\x20\x01(\x05R\x06seqNum\x12\x1b\n\x07eresult\x18\r\x20\x01(\x05:\
    \x012R\x07eresult\x12#\n\rerror_message\x18\x0e\x20\x01(\tR\x0cerrorMess\
    age\x12,\n\x12auth_account_flags\x18\x10\x20\x01(\rR\x10authAccountFlags\
    \x12!\n\x0ctoken_source\x18\x16\x20\x01(\rR\x0btokenSource\x12.\n\x13adm\
    in_spoofing_user\x18\x17\x20\x01(\x08R\x11adminSpoofingUser\x12*\n\x0ftr\
    ansport_error\x18\x11\x20\x01(\x05:\x011R\x0etransportError\x122\n\tmess\
    ageid\x18\x12\x20\x01(\x04:\x1418446744073709551615R\tmessageid\x12,\n\
    \x12publisher_group_id\x18\x13\x20\x01(\rR\x10publisherGroupId\x12\x14\n\
    \x05sysid\x18\x14\x20\x01(\rR\x05sysid\x12\x1b\n\ttrace_tag\x18\x15\x20\
    \x01(\x04R\x08traceTag\x12\"\n\rwebapi_key_id\x18\x19\x20\x01(\rR\x0bweb\
    apiKeyId\x125\n\x17is_from_external_source\x18\x1a\x20\x01(\x08R\x14isFr\
    omExternalSource\x12(\n\x10forward_to_sysid\x18\x1b\x20\x03(\rR\x0eforwa\
    rdToSysid\x12\x19\n\x08cm_sysid\x18\x1c\x20\x01(\rR\x07cmSysid\x12&\n\rl\
    auncher_type\x18\x1f\x20\x01(\r:\x010R\x0clauncherType\x12\x17\n\x05real\
    m\x18\x20\x20\x01(\r:\x010R\x05realm\x12!\n\ntimeout_ms\x18!\x20\x01(\
    \x05:\x02-1R\ttimeoutMs\x12!\n\x0cdebug_source\x18\"\x20\x01(\tR\x0bdebu\
    gSource\x129\n\x19debug_source_string_index\x18#\x20\x01(\rR\x16debugSou\
    rceStringIndex\x12\x19\n\x08token_id\x18$\x20\x01(\x04R\x07tokenId\x12;\
    \n\nrouting_gc\x18%\x20\x01(\x0b2\x1c.CMsgGCRoutingProtoBufHeaderR\trout\
    ingGc\x12\x10\n\x02ip\x18\x0f\x20\x01(\rH\0R\x02ip\x12\x15\n\x05ip_v6\
    \x18\x1d\x20\x01(\x0cH\0R\x04ipV6B\t\n\x07ip_addr\"S\n\tCMsgMulti\x12#\n\
    \rsize_unzipped\x18\x01\x20\x01(\rR\x0csizeUnzipped\x12!\n\x0cmessage_bo\
    dy\x18\x02\x20\x01(\x0cR\x0bmessageBody\"8\n\x13CMsgProtobufWrapped\x12!\
    \n\x0cmessage_body\x18\x01\x20\x01(\x0cR\x0bmessageBody\"\xf5\x01\n\x0eC\
    MsgAuthTicket\x12\x16\n\x06estate\x18\x01\x20\x01(\rR\x06estate\x12\x1b\
    \n\x07eresult\x18\x02\x20\x01(\r:\x012R\x07eresult\x12\x18\n\x07steamid\
    \x18\x03\x20\x01(\x06R\x07steamid\x12\x16\n\x06gameid\x18\x04\x20\x01(\
    \x06R\x06gameid\x12\x20\n\x0ch_steam_pipe\x18\x05\x20\x01(\rR\nhSteamPip\
    e\x12\x1d\n\nticket_crc\x18\x06\x20\x01(\rR\tticketCrc\x12\x16\n\x06tick\
    et\x18\x07\x20\x01(\x0cR\x06ticket\x12#\n\rserver_secret\x18\x08\x20\x01\
    (\x0cR\x0cserverSecret\"\xb7\x04\n\x14CCDDBAppDetailCommon\x12\x14\n\x05\
    appid\x18\x01\x20\x01(\rR\x05appid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x12\n\x04icon\x18\x03\x20\x01(\tR\x04icon\x12\x12\n\x04tool\
    \x18\x06\x20\x01(\x08R\x04tool\x12\x12\n\x04demo\x18\x07\x20\x01(\x08R\
    \x04demo\x12\x14\n\x05media\x18\x08\x20\x01(\x08R\x05media\x126\n\x17com\
    munity_visible_stats\x18\t\x20\x01(\x08R\x15communityVisibleStats\x12#\n\
    \rfriendly_name\x18\n\x20\x01(\tR\x0cfriendlyName\x12\x20\n\x0bpropagati\
    on\x18\x0b\x20\x01(\tR\x0bpropagation\x12*\n\x11has_adult_content\x18\
    \x0c\x20\x01(\x08R\x0fhasAdultContent\x128\n\x19is_visible_in_steam_chin\
    a\x18\r\x20\x01(\x08R\x15isVisibleInSteamChina\x12\x19\n\x08app_type\x18\
    \x0e\x20\x01(\rR\x07appType\x121\n\x15has_adult_content_sex\x18\x0f\x20\
    \x01(\x08R\x12hasAdultContentSex\x12;\n\x1ahas_adult_content_violence\
    \x18\x10\x20\x01(\x08R\x17hasAdultContentViolence\x123\n\x15content_desc\
    riptorids\x18\x11\x20\x03(\rR\x14contentDescriptorids\"\xbb\x05\n\rCMsgA\
    ppRights\x12\x1b\n\tedit_info\x18\x01\x20\x01(\x08R\x08editInfo\x12\x18\
    \n\x07publish\x18\x02\x20\x01(\x08R\x07publish\x12&\n\x0fview_error_data\
    \x18\x03\x20\x01(\x08R\rviewErrorData\x12\x1a\n\x08download\x18\x04\x20\
    \x01(\x08R\x08download\x12#\n\rupload_cdkeys\x18\x05\x20\x01(\x08R\x0cup\
    loadCdkeys\x12'\n\x0fgenerate_cdkeys\x18\x06\x20\x01(\x08R\x0egenerateCd\
    keys\x12'\n\x0fview_financials\x18\x07\x20\x01(\x08R\x0eviewFinancials\
    \x12\x1d\n\nmanage_ceg\x18\x08\x20\x01(\x08R\tmanageCeg\x12%\n\x0emanage\
    _signing\x18\t\x20\x01(\x08R\rmanageSigning\x12#\n\rmanage_cdkeys\x18\n\
    \x20\x01(\x08R\x0cmanageCdkeys\x12%\n\x0eedit_marketing\x18\x0b\x20\x01(\
    \x08R\reditMarketing\x12'\n\x0feconomy_support\x18\x0c\x20\x01(\x08R\x0e\
    economySupport\x12<\n\x1aeconomy_support_supervisor\x18\r\x20\x01(\x08R\
    \x18economySupportSupervisor\x12%\n\x0emanage_pricing\x18\x0e\x20\x01(\
    \x08R\rmanagePricing\x12%\n\x0ebroadcast_live\x18\x0f\x20\x01(\x08R\rbro\
    adcastLive\x124\n\x16view_marketing_traffic\x18\x10\x20\x01(\x08R\x14vie\
    wMarketingTraffic\x12;\n\x1aedit_store_display_content\x18\x11\x20\x01(\
    \x08R\x17editStoreDisplayContent\"\xcd\x04\n\x13CCuratorPreferences\x12/\
    \n\x13supported_languages\x18\x01\x20\x01(\rR\x12supportedLanguages\x12)\
    \n\x10platform_windows\x18\x02\x20\x01(\x08R\x0fplatformWindows\x12!\n\
    \x0cplatform_mac\x18\x03\x20\x01(\x08R\x0bplatformMac\x12%\n\x0eplatform\
    _linux\x18\x04\x20\x01(\x08R\rplatformLinux\x12\x1d\n\nvr_content\x18\
    \x05\x20\x01(\x08R\tvrContent\x124\n\x16adult_content_violence\x18\x06\
    \x20\x01(\x08R\x14adultContentViolence\x12*\n\x11adult_content_sex\x18\
    \x07\x20\x01(\x08R\x0fadultContentSex\x12+\n\x11timestamp_updated\x18\
    \x08\x20\x01(\rR\x10timestampUpdated\x12%\n\x0etagids_curated\x18\t\x20\
    \x03(\rR\rtagidsCurated\x12'\n\x0ftagids_filtered\x18\n\x20\x03(\rR\x0et\
    agidsFiltered\x12#\n\rwebsite_title\x18\x0b\x20\x01(\tR\x0cwebsiteTitle\
    \x12\x1f\n\x0bwebsite_url\x18\x0c\x20\x01(\tR\nwebsiteUrl\x12%\n\x0edisc\
    ussion_url\x18\r\x20\x01(\tR\rdiscussionUrl\x12%\n\x0eshow_broadcast\x18\
    \x0e\x20\x01(\x08R\rshowBroadcast\"[\n\x12CLocalizationToken\x12\x1a\n\
    \x08language\x18\x01\x20\x01(\rR\x08language\x12)\n\x10localized_string\
    \x18\x02\x20\x01(\tR\x0flocalizedString\"\xe6\x02\n\x17CClanEventUserNew\
    sTuple\x12\x16\n\x06clanid\x18\x01\x20\x01(\rR\x06clanid\x12\x1b\n\teven\
    t_gid\x18\x02\x20\x01(\x06R\x08eventGid\x12)\n\x10announcement_gid\x18\
    \x03\x20\x01(\x06R\x0fannouncementGid\x12\x1f\n\x0brtime_start\x18\x04\
    \x20\x01(\rR\nrtimeStart\x12\x1b\n\trtime_end\x18\x05\x20\x01(\rR\x08rti\
    meEnd\x12%\n\x0epriority_score\x18\x06\x20\x01(\rR\rpriorityScore\x12\
    \x12\n\x04type\x18\x07\x20\x01(\rR\x04type\x12(\n\x10clamp_range_slot\
    \x18\x08\x20\x01(\rR\x0eclampRangeSlot\x12\x14\n\x05appid\x18\t\x20\x01(\
    \rR\x05appid\x122\n\x15rtime32_last_modified\x18\n\x20\x01(\rR\x13rtime3\
    2LastModified\"\xac\x01\n\x16CClanMatchEventByRange\x12!\n\x0crtime_befo\
    re\x18\x01\x20\x01(\rR\x0brtimeBefore\x12\x1f\n\x0brtime_after\x18\x02\
    \x20\x01(\rR\nrtimeAfter\x12\x1c\n\tqualified\x18\x03\x20\x01(\rR\tquali\
    fied\x120\n\x06events\x18\x04\x20\x03(\x0b2\x18.CClanEventUserNewsTupleR\
    \x06events\"\xca\x04\n\x1fCCommunity_ClanAnnouncementInfo\x12\x10\n\x03g\
    id\x18\x01\x20\x01(\x04R\x03gid\x12\x16\n\x06clanid\x18\x02\x20\x01(\x04\
    R\x06clanid\x12\x1a\n\x08posterid\x18\x03\x20\x01(\x04R\x08posterid\x12\
    \x1a\n\x08headline\x18\x04\x20\x01(\tR\x08headline\x12\x1a\n\x08posttime\
    \x18\x05\x20\x01(\rR\x08posttime\x12\x1e\n\nupdatetime\x18\x06\x20\x01(\
    \rR\nupdatetime\x12\x12\n\x04body\x18\x07\x20\x01(\tR\x04body\x12\"\n\
    \x0ccommentcount\x18\x08\x20\x01(\x05R\x0ccommentcount\x12\x12\n\x04tags\
    \x18\t\x20\x03(\tR\x04tags\x12\x1a\n\x08language\x18\n\x20\x01(\x05R\x08\
    language\x12\x16\n\x06hidden\x18\x0b\x20\x01(\x08R\x06hidden\x12$\n\x0ef\
    orum_topic_id\x18\x0c\x20\x01(\x06R\x0cforumTopicId\x12\x1b\n\tevent_gid\
    \x18\r\x20\x01(\x06R\x08eventGid\x12\x20\n\x0bvoteupcount\x18\x0e\x20\
    \x01(\x05R\x0bvoteupcount\x12$\n\rvotedowncount\x18\x0f\x20\x01(\x05R\rv\
    otedowncount\x12f\n\x10ban_check_result\x18\x10\x20\x01(\x0e2\x17.EBanCo\
    ntentCheckResult:#k_EBanContentCheckResult_NotScannedR\x0ebanCheckResult\
    \x12\x16\n\x06banned\x18\x11\x20\x01(\x08R\x06banned\"\xde\t\n\x0eCClanE\
    ventData\x12\x10\n\x03gid\x18\x01\x20\x01(\x06R\x03gid\x12!\n\x0cclan_st\
    eamid\x18\x02\x20\x01(\x06R\x0bclanSteamid\x12\x1d\n\nevent_name\x18\x03\
    \x20\x01(\tR\teventName\x12F\n\nevent_type\x18\x04\x20\x01(\x0e2\x14.EPr\
    otoClanEventType:\x11k_EClanOtherEventR\teventType\x12\x14\n\x05appid\
    \x18\x05\x20\x01(\rR\x05appid\x12%\n\x0eserver_address\x18\x06\x20\x01(\
    \tR\rserverAddress\x12'\n\x0fserver_password\x18\x07\x20\x01(\tR\x0eserv\
    erPassword\x12,\n\x12rtime32_start_time\x18\x08\x20\x01(\rR\x10rtime32St\
    artTime\x12(\n\x10rtime32_end_time\x18\t\x20\x01(\rR\x0ertime32EndTime\
    \x12#\n\rcomment_count\x18\n\x20\x01(\x05R\x0ccommentCount\x12'\n\x0fcre\
    ator_steamid\x18\x0b\x20\x01(\x06R\x0ecreatorSteamid\x12.\n\x13last_upda\
    te_steamid\x18\x0c\x20\x01(\x06R\x11lastUpdateSteamid\x12\x1f\n\x0bevent\
    _notes\x18\r\x20\x01(\tR\neventNotes\x12\x1a\n\x08jsondata\x18\x0e\x20\
    \x01(\tR\x08jsondata\x12M\n\x11announcement_body\x18\x0f\x20\x01(\x0b2\
    \x20.CCommunity_ClanAnnouncementInfoR\x10announcementBody\x12\x1c\n\tpub\
    lished\x18\x10\x20\x01(\x08R\tpublished\x12\x16\n\x06hidden\x18\x11\x20\
    \x01(\x08R\x06hidden\x128\n\x18rtime32_visibility_start\x18\x12\x20\x01(\
    \rR\x16rtime32VisibilityStart\x124\n\x16rtime32_visibility_end\x18\x13\
    \x20\x01(\rR\x14rtime32VisibilityEnd\x123\n\x15broadcaster_accountid\x18\
    \x14\x20\x01(\rR\x14broadcasterAccountid\x12%\n\x0efollower_count\x18\
    \x15\x20\x01(\rR\rfollowerCount\x12!\n\x0cignore_count\x18\x16\x20\x01(\
    \rR\x0bignoreCount\x12$\n\x0eforum_topic_id\x18\x17\x20\x01(\x06R\x0cfor\
    umTopicId\x122\n\x15rtime32_last_modified\x18\x18\x20\x01(\rR\x13rtime32\
    LastModified\x12\"\n\rnews_post_gid\x18\x19\x20\x01(\x06R\x0bnewsPostGid\
    \x12,\n\x12rtime_mod_reviewed\x18\x1a\x20\x01(\rR\x10rtimeModReviewed\
    \x12,\n\x12featured_app_tagid\x18\x1b\x20\x01(\rR\x10featuredAppTagid\
    \x12+\n\x11referenced_appids\x18\x1c\x20\x03(\rR\x10referencedAppids\x12\
    \x19\n\x08build_id\x18\x1d\x20\x01(\rR\x07buildId\x12!\n\x0cbuild_branch\
    \x18\x1e\x20\x01(\tR\x0bbuildBranch\"\xa7\x02\n\x10CBilling_Address\x12\
    \x1d\n\nfirst_name\x18\x01\x20\x01(\tR\tfirstName\x12\x1b\n\tlast_name\
    \x18\x02\x20\x01(\tR\x08lastName\x12\x1a\n\x08address1\x18\x03\x20\x01(\
    \tR\x08address1\x12\x1a\n\x08address2\x18\x04\x20\x01(\tR\x08address2\
    \x12\x12\n\x04city\x18\x05\x20\x01(\tR\x04city\x12\x19\n\x08us_state\x18\
    \x06\x20\x01(\tR\x07usState\x12!\n\x0ccountry_code\x18\x07\x20\x01(\tR\
    \x0bcountryCode\x12\x1a\n\x08postcode\x18\x08\x20\x01(\tR\x08postcode\
    \x12\x1b\n\tzip_plus4\x18\t\x20\x01(\x05R\x08zipPlus4\x12\x14\n\x05phone\
    \x18\n\x20\x01(\tR\x05phone\"\xd3\x02\n\x19CPackageReservationStatus\x12\
    \x1c\n\tpackageid\x18\x01\x20\x01(\rR\tpackageid\x12+\n\x11reservation_s\
    tate\x18\x02\x20\x01(\x05R\x10reservationState\x12%\n\x0equeue_position\
    \x18\x03\x20\x01(\x05R\rqueuePosition\x12(\n\x10total_queue_size\x18\x04\
    \x20\x01(\x05R\x0etotalQueueSize\x128\n\x18reservation_country_code\x18\
    \x05\x20\x01(\tR\x16reservationCountryCode\x12\x18\n\x07expired\x18\x06\
    \x20\x01(\x08R\x07expired\x12!\n\x0ctime_expires\x18\x07\x20\x01(\rR\x0b\
    timeExpires\x12#\n\rtime_reserved\x18\x08\x20\x01(\rR\x0ctimeReserved\"<\
    \n\x10CMsgKeyValuePair\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value\":\n\x0fCMsgKeyValueSet\x12\
    '\n\x05pairs\x18\x01\x20\x03(\x0b2\x11.CMsgKeyValuePairR\x05pairs*\xd8\
    \x02\n\x16EBanContentCheckResult\x12'\n#k_EBanContentCheckResult_NotScan\
    ned\x10\0\x12\"\n\x1ek_EBanContentCheckResult_Reset\x10\x01\x12*\n&k_EBa\
    nContentCheckResult_NeedsChecking\x10\x02\x12)\n%k_EBanContentCheckResul\
    t_VeryUnlikely\x10\x05\x12%\n!k_EBanContentCheckResult_Unlikely\x10\x1e\
    \x12%\n!k_EBanContentCheckResult_Possible\x102\x12#\n\x1fk_EBanContentCh\
    eckResult_Likely\x10K\x12'\n#k_EBanContentCheckResult_VeryLikely\x10d*\
    \xeb\x07\n\x13EProtoClanEventType\x12\x15\n\x11k_EClanOtherEvent\x10\x01\
    \x12\x14\n\x10k_EClanGameEvent\x10\x02\x12\x15\n\x11k_EClanPartyEvent\
    \x10\x03\x12\x17\n\x13k_EClanMeetingEvent\x10\x04\x12\x1c\n\x18k_EClanSp\
    ecialCauseEvent\x10\x05\x12\x1c\n\x18k_EClanMusicAndArtsEvent\x10\x06\
    \x12\x16\n\x12k_EClanSportsEvent\x10\x07\x12\x14\n\x10k_EClanTripEvent\
    \x10\x08\x12\x14\n\x10k_EClanChatEvent\x10\t\x12\x1b\n\x17k_EClanGameRel\
    easeEvent\x10\n\x12\x19\n\x15k_EClanBroadcastEvent\x10\x0b\x12\x1b\n\x17\
    k_EClanSmallUpdateEvent\x10\x0c\x12&\n\"k_EClanPreAnnounceMajorUpdateEve\
    nt\x10\r\x12\x1b\n\x17k_EClanMajorUpdateEvent\x10\x0e\x12\x1a\n\x16k_ECl\
    anDLCReleaseEvent\x10\x0f\x12\x1d\n\x19k_EClanFutureReleaseEvent\x10\x10\
    \x12&\n\"k_EClanESportTournamentStreamEvent\x10\x11\x12\x19\n\x15k_EClan\
    DevStreamEvent\x10\x12\x12\x1c\n\x18k_EClanFamousStreamEvent\x10\x13\x12\
    \x19\n\x15k_EClanGameSalesEvent\x10\x14\x12\x1d\n\x19k_EClanGameItemSale\
    sEvent\x10\x15\x12\x1d\n\x19k_EClanInGameBonusXPEvent\x10\x16\x12\x1a\n\
    \x16k_EClanInGameLootEvent\x10\x17\x12\x1b\n\x17k_EClanInGamePerksEvent\
    \x10\x18\x12\x1f\n\x1bk_EClanInGameChallengeEvent\x10\x19\x12\x1d\n\x19k\
    _EClanInGameContestEvent\x10\x1a\x12\x13\n\x0fk_EClanIRLEvent\x10\x1b\
    \x12\x14\n\x10k_EClanNewsEvent\x10\x1c\x12\x1b\n\x17k_EClanBetaReleaseEv\
    ent\x10\x1d\x12$\n\x20k_EClanInGameContentReleaseEvent\x10\x1e\x12\x14\n\
    \x10k_EClanFreeTrial\x10\x1f\x12\x18\n\x14k_EClanSeasonRelease\x10\x20\
    \x12\x17\n\x13k_EClanSeasonUpdate\x10!\x12\x19\n\x15k_EClanCrosspostEven\
    t\x10\"\x12\x1d\n\x19k_EClanInGameEventGeneral\x10#*\x81\x01\n\x1cPartne\
    rEventNotificationType\x12\x11\n\rk_EEventStart\x10\0\x12\x1a\n\x16k_EEv\
    entBroadcastStart\x10\x01\x12\x16\n\x12k_EEventMatchStart\x10\x02\x12\
    \x1a\n\x16k_EEventPartnerMaxType\x10\x03:S\n\x12msgpool_soft_limit\x18\
    \xd0\x86\x03\x20\x01(\x05\x12\x1f.google.protobuf.MessageOptions:\x0232R\
    \x10msgpoolSoftLimit:T\n\x12msgpool_hard_limit\x18\xd1\x86\x03\x20\x01(\
    \x05\x12\x1f.google.protobuf.MessageOptions:\x03384R\x10msgpoolHardLimit\
    :W\n\x14force_php_generation\x18\xd0\x86\x03\x20\x01(\x08\x12\x1c.google\
    .protobuf.FileOptions:\x05falseR\x12forcePhpGeneration:_\n\x18php_output\
    _always_number\x18\xe4\x86\x03\x20\x01(\x08\x12\x1d.google.protobuf.Fiel\
    dOptions:\x05falseR\x15phpOutputAlwaysNumber:b\n\x1aallow_field_named_st\
    eam_id\x18\xe8\x86\x03\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions\
    :\x05falseR\x16allowFieldNamedSteamIdB\tH\x01\x80\x01\x01\x80\xb5\x18\
    \x01J\xc5\x7f\n\x07\x12\x05\0\0\xb9\x02\x01\n\t\n\x02\x03\0\x12\x03\0\0*\
    \n\x08\n\x01\x08\x12\x03\x02\0\x1c\n\t\n\x02\x08\t\x12\x03\x02\0\x1c\n\
    \x08\n\x01\x08\x12\x03\x03\0\"\n\t\n\x02\x08\x10\x12\x03\x03\0\"\n\x08\n\
    \x01\x08\x12\x03\x04\0%\n\x0b\n\x04\x08\xd0\x86\x03\x12\x03\x04\0%\n\t\n\
    \x01\x07\x12\x04\x06\0\t\x01\n\t\n\x02\x07\0\x12\x03\x07\x08A\n\n\n\x03\
    \x07\0\x02\x12\x03\x06\x07&\n\n\n\x03\x07\0\x04\x12\x03\x07\x08\x10\n\n\
    \n\x03\x07\0\x05\x12\x03\x07\x11\x16\n\n\n\x03\x07\0\x01\x12\x03\x07\x17\
    )\n\n\n\x03\x07\0\x03\x12\x03\x07,1\n\n\n\x03\x07\0\x08\x12\x03\x072@\n\
    \n\n\x03\x07\0\x07\x12\x03\x07=?\n\t\n\x02\x07\x01\x12\x03\x08\x08B\n\n\
    \n\x03\x07\x01\x02\x12\x03\x06\x07&\n\n\n\x03\x07\x01\x04\x12\x03\x08\
    \x08\x10\n\n\n\x03\x07\x01\x05\x12\x03\x08\x11\x16\n\n\n\x03\x07\x01\x01\
    \x12\x03\x08\x17)\n\n\n\x03\x07\x01\x03\x12\x03\x08,1\n\n\n\x03\x07\x01\
    \x08\x12\x03\x082A\n\n\n\x03\x07\x01\x07\x12\x03\x08=@\n\t\n\x01\x07\x12\
    \x04\x0b\0\r\x01\n\t\n\x02\x07\x02\x12\x03\x0c\x08E\n\n\n\x03\x07\x02\
    \x02\x12\x03\x0b\x07#\n\n\n\x03\x07\x02\x04\x12\x03\x0c\x08\x10\n\n\n\
    \x03\x07\x02\x05\x12\x03\x0c\x11\x15\n\n\n\x03\x07\x02\x01\x12\x03\x0c\
    \x16*\n\n\n\x03\x07\x02\x03\x12\x03\x0c-2\n\n\n\x03\x07\x02\x08\x12\x03\
    \x0c3D\n\n\n\x03\x07\x02\x07\x12\x03\x0c>C\n\t\n\x01\x07\x12\x04\x0f\0\
    \x12\x01\n\t\n\x02\x07\x03\x12\x03\x10\x08I\n\n\n\x03\x07\x03\x02\x12\
    \x03\x0f\x07$\n\n\n\x03\x07\x03\x04\x12\x03\x10\x08\x10\n\n\n\x03\x07\
    \x03\x05\x12\x03\x10\x11\x15\n\n\n\x03\x07\x03\x01\x12\x03\x10\x16.\n\n\
    \n\x03\x07\x03\x03\x12\x03\x1016\n\n\n\x03\x07\x03\x08\x12\x03\x107H\n\n\
    \n\x03\x07\x03\x07\x12\x03\x10BG\n\t\n\x02\x07\x04\x12\x03\x11\x08K\n\n\
    \n\x03\x07\x04\x02\x12\x03\x0f\x07$\n\n\n\x03\x07\x04\x04\x12\x03\x11\
    \x08\x10\n\n\n\x03\x07\x04\x05\x12\x03\x11\x11\x15\n\n\n\x03\x07\x04\x01\
    \x12\x03\x11\x160\n\n\n\x03\x07\x04\x03\x12\x03\x1138\n\n\n\x03\x07\x04\
    \x08\x12\x03\x119J\n\n\n\x03\x07\x04\x07\x12\x03\x11DI\n\n\n\x02\x05\0\
    \x12\x04\x14\0\x1d\x01\n\n\n\x03\x05\0\x01\x12\x03\x14\x05\x1b\n\x0b\n\
    \x04\x05\0\x02\0\x12\x03\x15\x080\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\
    \x15\x08+\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x15./\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\x16\x08+\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\x16\x08&\
    \n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x16)*\n\x0b\n\x04\x05\0\x02\x02\
    \x12\x03\x17\x083\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x17\x08.\n\x0c\n\
    \x05\x05\0\x02\x02\x02\x12\x03\x1712\n\x0b\n\x04\x05\0\x02\x03\x12\x03\
    \x18\x082\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\x18\x08-\n\x0c\n\x05\x05\
    \0\x02\x03\x02\x12\x03\x1801\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x19\x08/\
    \n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\x19\x08)\n\x0c\n\x05\x05\0\x02\
    \x04\x02\x12\x03\x19,.\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x1a\x08/\n\x0c\
    \n\x05\x05\0\x02\x05\x01\x12\x03\x1a\x08)\n\x0c\n\x05\x05\0\x02\x05\x02\
    \x12\x03\x1a,.\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x1b\x08-\n\x0c\n\x05\
    \x05\0\x02\x06\x01\x12\x03\x1b\x08'\n\x0c\n\x05\x05\0\x02\x06\x02\x12\
    \x03\x1b*,\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x1c\x082\n\x0c\n\x05\x05\0\
    \x02\x07\x01\x12\x03\x1c\x08+\n\x0c\n\x05\x05\0\x02\x07\x02\x12\x03\x1c.\
    1\n\n\n\x02\x05\x01\x12\x04\x1f\0C\x01\n\n\n\x03\x05\x01\x01\x12\x03\x1f\
    \x05\x18\n\x0b\n\x04\x05\x01\x02\0\x12\x03\x20\x08\x1e\n\x0c\n\x05\x05\
    \x01\x02\0\x01\x12\x03\x20\x08\x19\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\
    \x20\x1c\x1d\n\x0b\n\x04\x05\x01\x02\x01\x12\x03!\x08\x1d\n\x0c\n\x05\
    \x05\x01\x02\x01\x01\x12\x03!\x08\x18\n\x0c\n\x05\x05\x01\x02\x01\x02\
    \x12\x03!\x1b\x1c\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\"\x08\x1e\n\x0c\n\
    \x05\x05\x01\x02\x02\x01\x12\x03\"\x08\x19\n\x0c\n\x05\x05\x01\x02\x02\
    \x02\x12\x03\"\x1c\x1d\n\x0b\n\x04\x05\x01\x02\x03\x12\x03#\x08\x20\n\
    \x0c\n\x05\x05\x01\x02\x03\x01\x12\x03#\x08\x1b\n\x0c\n\x05\x05\x01\x02\
    \x03\x02\x12\x03#\x1e\x1f\n\x0b\n\x04\x05\x01\x02\x04\x12\x03$\x08%\n\
    \x0c\n\x05\x05\x01\x02\x04\x01\x12\x03$\x08\x20\n\x0c\n\x05\x05\x01\x02\
    \x04\x02\x12\x03$#$\n\x0b\n\x04\x05\x01\x02\x05\x12\x03%\x08%\n\x0c\n\
    \x05\x05\x01\x02\x05\x01\x12\x03%\x08\x20\n\x0c\n\x05\x05\x01\x02\x05\
    \x02\x12\x03%#$\n\x0b\n\x04\x05\x01\x02\x06\x12\x03&\x08\x1f\n\x0c\n\x05\
    \x05\x01\x02\x06\x01\x12\x03&\x08\x1a\n\x0c\n\x05\x05\x01\x02\x06\x02\
    \x12\x03&\x1d\x1e\n\x0b\n\x04\x05\x01\x02\x07\x12\x03'\x08\x1d\n\x0c\n\
    \x05\x05\x01\x02\x07\x01\x12\x03'\x08\x18\n\x0c\n\x05\x05\x01\x02\x07\
    \x02\x12\x03'\x1b\x1c\n\x0b\n\x04\x05\x01\x02\x08\x12\x03(\x08\x1d\n\x0c\
    \n\x05\x05\x01\x02\x08\x01\x12\x03(\x08\x18\n\x0c\n\x05\x05\x01\x02\x08\
    \x02\x12\x03(\x1b\x1c\n\x0b\n\x04\x05\x01\x02\t\x12\x03)\x08%\n\x0c\n\
    \x05\x05\x01\x02\t\x01\x12\x03)\x08\x1f\n\x0c\n\x05\x05\x01\x02\t\x02\
    \x12\x03)\"$\n\x0b\n\x04\x05\x01\x02\n\x12\x03*\x08#\n\x0c\n\x05\x05\x01\
    \x02\n\x01\x12\x03*\x08\x1d\n\x0c\n\x05\x05\x01\x02\n\x02\x12\x03*\x20\"\
    \n\x0b\n\x04\x05\x01\x02\x0b\x12\x03+\x08%\n\x0c\n\x05\x05\x01\x02\x0b\
    \x01\x12\x03+\x08\x1f\n\x0c\n\x05\x05\x01\x02\x0b\x02\x12\x03+\"$\n\x0b\
    \n\x04\x05\x01\x02\x0c\x12\x03,\x080\n\x0c\n\x05\x05\x01\x02\x0c\x01\x12\
    \x03,\x08*\n\x0c\n\x05\x05\x01\x02\x0c\x02\x12\x03,-/\n\x0b\n\x04\x05\
    \x01\x02\r\x12\x03-\x08%\n\x0c\n\x05\x05\x01\x02\r\x01\x12\x03-\x08\x1f\
    \n\x0c\n\x05\x05\x01\x02\r\x02\x12\x03-\"$\n\x0b\n\x04\x05\x01\x02\x0e\
    \x12\x03.\x08$\n\x0c\n\x05\x05\x01\x02\x0e\x01\x12\x03.\x08\x1e\n\x0c\n\
    \x05\x05\x01\x02\x0e\x02\x12\x03.!#\n\x0b\n\x04\x05\x01\x02\x0f\x12\x03/\
    \x08'\n\x0c\n\x05\x05\x01\x02\x0f\x01\x12\x03/\x08!\n\x0c\n\x05\x05\x01\
    \x02\x0f\x02\x12\x03/$&\n\x0b\n\x04\x05\x01\x02\x10\x12\x030\x080\n\x0c\
    \n\x05\x05\x01\x02\x10\x01\x12\x030\x08*\n\x0c\n\x05\x05\x01\x02\x10\x02\
    \x12\x030-/\n\x0b\n\x04\x05\x01\x02\x11\x12\x031\x08#\n\x0c\n\x05\x05\
    \x01\x02\x11\x01\x12\x031\x08\x1d\n\x0c\n\x05\x05\x01\x02\x11\x02\x12\
    \x031\x20\"\n\x0b\n\x04\x05\x01\x02\x12\x12\x032\x08&\n\x0c\n\x05\x05\
    \x01\x02\x12\x01\x12\x032\x08\x20\n\x0c\n\x05\x05\x01\x02\x12\x02\x12\
    \x032#%\n\x0b\n\x04\x05\x01\x02\x13\x12\x033\x08#\n\x0c\n\x05\x05\x01\
    \x02\x13\x01\x12\x033\x08\x1d\n\x0c\n\x05\x05\x01\x02\x13\x02\x12\x033\
    \x20\"\n\x0b\n\x04\x05\x01\x02\x14\x12\x034\x08'\n\x0c\n\x05\x05\x01\x02\
    \x14\x01\x12\x034\x08!\n\x0c\n\x05\x05\x01\x02\x14\x02\x12\x034$&\n\x0b\
    \n\x04\x05\x01\x02\x15\x12\x035\x08'\n\x0c\n\x05\x05\x01\x02\x15\x01\x12\
    \x035\x08!\n\x0c\n\x05\x05\x01\x02\x15\x02\x12\x035$&\n\x0b\n\x04\x05\
    \x01\x02\x16\x12\x036\x08$\n\x0c\n\x05\x05\x01\x02\x16\x01\x12\x036\x08\
    \x1e\n\x0c\n\x05\x05\x01\x02\x16\x02\x12\x036!#\n\x0b\n\x04\x05\x01\x02\
    \x17\x12\x037\x08%\n\x0c\n\x05\x05\x01\x02\x17\x01\x12\x037\x08\x1f\n\
    \x0c\n\x05\x05\x01\x02\x17\x02\x12\x037\"$\n\x0b\n\x04\x05\x01\x02\x18\
    \x12\x038\x08)\n\x0c\n\x05\x05\x01\x02\x18\x01\x12\x038\x08#\n\x0c\n\x05\
    \x05\x01\x02\x18\x02\x12\x038&(\n\x0b\n\x04\x05\x01\x02\x19\x12\x039\x08\
    '\n\x0c\n\x05\x05\x01\x02\x19\x01\x12\x039\x08!\n\x0c\n\x05\x05\x01\x02\
    \x19\x02\x12\x039$&\n\x0b\n\x04\x05\x01\x02\x1a\x12\x03:\x08\x1d\n\x0c\n\
    \x05\x05\x01\x02\x1a\x01\x12\x03:\x08\x17\n\x0c\n\x05\x05\x01\x02\x1a\
    \x02\x12\x03:\x1a\x1c\n\x0b\n\x04\x05\x01\x02\x1b\x12\x03;\x08\x1e\n\x0c\
    \n\x05\x05\x01\x02\x1b\x01\x12\x03;\x08\x18\n\x0c\n\x05\x05\x01\x02\x1b\
    \x02\x12\x03;\x1b\x1d\n\x0b\n\x04\x05\x01\x02\x1c\x12\x03<\x08%\n\x0c\n\
    \x05\x05\x01\x02\x1c\x01\x12\x03<\x08\x1f\n\x0c\n\x05\x05\x01\x02\x1c\
    \x02\x12\x03<\"$\n\x0b\n\x04\x05\x01\x02\x1d\x12\x03=\x08.\n\x0c\n\x05\
    \x05\x01\x02\x1d\x01\x12\x03=\x08(\n\x0c\n\x05\x05\x01\x02\x1d\x02\x12\
    \x03=+-\n\x0b\n\x04\x05\x01\x02\x1e\x12\x03>\x08\x1e\n\x0c\n\x05\x05\x01\
    \x02\x1e\x01\x12\x03>\x08\x18\n\x0c\n\x05\x05\x01\x02\x1e\x02\x12\x03>\
    \x1b\x1d\n\x0b\n\x04\x05\x01\x02\x1f\x12\x03?\x08\"\n\x0c\n\x05\x05\x01\
    \x02\x1f\x01\x12\x03?\x08\x1c\n\x0c\n\x05\x05\x01\x02\x1f\x02\x12\x03?\
    \x1f!\n\x0b\n\x04\x05\x01\x02\x20\x12\x03@\x08!\n\x0c\n\x05\x05\x01\x02\
    \x20\x01\x12\x03@\x08\x1b\n\x0c\n\x05\x05\x01\x02\x20\x02\x12\x03@\x1e\
    \x20\n\x0b\n\x04\x05\x01\x02!\x12\x03A\x08#\n\x0c\n\x05\x05\x01\x02!\x01\
    \x12\x03A\x08\x1d\n\x0c\n\x05\x05\x01\x02!\x02\x12\x03A\x20\"\n\x0b\n\
    \x04\x05\x01\x02\"\x12\x03B\x08'\n\x0c\n\x05\x05\x01\x02\"\x01\x12\x03B\
    \x08!\n\x0c\n\x05\x05\x01\x02\"\x02\x12\x03B$&\n\n\n\x02\x05\x02\x12\x04\
    E\0J\x01\n\n\n\x03\x05\x02\x01\x12\x03E\x05!\n\x0b\n\x04\x05\x02\x02\0\
    \x12\x03F\x08\x1a\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03F\x08\x15\n\x0c\n\
    \x05\x05\x02\x02\0\x02\x12\x03F\x18\x19\n\x0b\n\x04\x05\x02\x02\x01\x12\
    \x03G\x08#\n\x0c\n\x05\x05\x02\x02\x01\x01\x12\x03G\x08\x1e\n\x0c\n\x05\
    \x05\x02\x02\x01\x02\x12\x03G!\"\n\x0b\n\x04\x05\x02\x02\x02\x12\x03H\
    \x08\x1f\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03H\x08\x1a\n\x0c\n\x05\
    \x05\x02\x02\x02\x02\x12\x03H\x1d\x1e\n\x0b\n\x04\x05\x02\x02\x03\x12\
    \x03I\x08#\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03I\x08\x1e\n\x0c\n\x05\
    \x05\x02\x02\x03\x02\x12\x03I!\"\n\n\n\x02\x04\0\x12\x04L\0Q\x01\n\n\n\
    \x03\x04\0\x01\x12\x03L\x08\x15\n\x0c\n\x04\x04\0\x08\0\x12\x04M\x08P\t\
    \n\x0c\n\x05\x04\0\x08\0\x01\x12\x03M\x0e\x10\n\x0b\n\x04\x04\0\x02\0\
    \x12\x03N\x10\x1f\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03N\x10\x17\n\x0c\n\
    \x05\x04\0\x02\0\x01\x12\x03N\x18\x1a\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03N\x1d\x1e\n\x0b\n\x04\x04\0\x02\x01\x12\x03O\x10\x1d\n\x0c\n\x05\x04\
    \0\x02\x01\x05\x12\x03O\x10\x15\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03O\
    \x16\x18\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03O\x1b\x1c\n\n\n\x02\x04\
    \x01\x12\x04S\0V\x01\n\n\n\x03\x04\x01\x01\x12\x03S\x08\x1b\n\x0b\n\x04\
    \x04\x01\x02\0\x12\x03T\x088\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03T\x08\
    \x10\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03T\x11\x1f\n\x0c\n\x05\x04\x01\
    \x02\0\x01\x12\x03T\x203\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03T67\n\x0b\
    \n\x04\x04\x01\x02\x01\x12\x03U\x08$\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03U\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03U\x11\x18\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03U\x19\x1f\n\x0c\n\x05\x04\x01\x02\x01\
    \x03\x12\x03U\"#\n\n\n\x02\x04\x02\x12\x04X\0[\x01\n\n\n\x03\x04\x02\x01\
    \x12\x03X\x08#\n\x0b\n\x04\x04\x02\x02\0\x12\x03Y\x08+\n\x0c\n\x05\x04\
    \x02\x02\0\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03Y\
    \x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03Y\x18&\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03Y)*\n\x0b\n\x04\x04\x02\x02\x01\x12\x03Z\x08-\n\x0c\n\
    \x05\x04\x02\x02\x01\x04\x12\x03Z\x08\x10\n\x0c\n\x05\x04\x02\x02\x01\
    \x05\x12\x03Z\x11\x17\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03Z\x18(\n\
    \x0c\n\x05\x04\x02\x02\x01\x03\x12\x03Z+,\n\n\n\x02\x04\x03\x12\x04]\0\
    \x7f\x01\n\n\n\x03\x04\x03\x01\x12\x03]\x08\x1a\n\x0b\n\x04\x04\x03\x02\
    \0\x12\x03^\x08%\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03^\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\0\x05\x12\x03^\x11\x18\n\x0c\n\x05\x04\x03\x02\0\x01\
    \x12\x03^\x19\x20\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03^#$\n\x0b\n\x04\
    \x04\x03\x02\x01\x12\x03_\x08,\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03_\
    \x08\x10\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03_\x11\x16\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x03_\x17'\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\
    \x03_*+\n\x0b\n\x04\x04\x03\x02\x02\x12\x03`\x08*\n\x0c\n\x05\x04\x03\
    \x02\x02\x04\x12\x03`\x08\x10\n\x0c\n\x05\x04\x03\x02\x02\x05\x12\x03`\
    \x11\x17\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03`\x18%\n\x0c\n\x05\x04\
    \x03\x02\x02\x03\x12\x03`()\n\x0b\n\x04\x04\x03\x02\x03\x12\x03a\x08L\n\
    \x0c\n\x05\x04\x03\x02\x03\x04\x12\x03a\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \x03\x05\x12\x03a\x11\x18\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03a\x19%\
    \n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03a(*\n\x0c\n\x05\x04\x03\x02\x03\
    \x08\x12\x03a+K\n\x0c\n\x05\x04\x03\x02\x03\x07\x12\x03a6J\n\x0b\n\x04\
    \x04\x03\x02\x04\x12\x03b\x08L\n\x0c\n\x05\x04\x03\x02\x04\x04\x12\x03b\
    \x08\x10\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03b\x11\x18\n\x0c\n\x05\
    \x04\x03\x02\x04\x01\x12\x03b\x19%\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\
    \x03b(*\n\x0c\n\x05\x04\x03\x02\x04\x08\x12\x03b+K\n\x0c\n\x05\x04\x03\
    \x02\x04\x07\x12\x03b6J\n\x0b\n\x04\x04\x03\x02\x05\x12\x03c\x08-\n\x0c\
    \n\x05\x04\x03\x02\x05\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x03\x02\x05\
    \x05\x12\x03c\x11\x17\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03c\x18'\n\
    \x0c\n\x05\x04\x03\x02\x05\x03\x12\x03c*,\n\x0b\n\x04\x04\x03\x02\x06\
    \x12\x03d\x08$\n\x0c\n\x05\x04\x03\x02\x06\x04\x12\x03d\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\x06\x05\x12\x03d\x11\x16\n\x0c\n\x05\x04\x03\x02\x06\
    \x01\x12\x03d\x17\x1e\n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03d!#\n\x0b\n\
    \x04\x04\x03\x02\x07\x12\x03e\x082\n\x0c\n\x05\x04\x03\x02\x07\x04\x12\
    \x03e\x08\x10\n\x0c\n\x05\x04\x03\x02\x07\x05\x12\x03e\x11\x16\n\x0c\n\
    \x05\x04\x03\x02\x07\x01\x12\x03e\x17\x1e\n\x0c\n\x05\x04\x03\x02\x07\
    \x03\x12\x03e!#\n\x0c\n\x05\x04\x03\x02\x07\x08\x12\x03e$1\n\x0c\n\x05\
    \x04\x03\x02\x07\x07\x12\x03e/0\n\x0b\n\x04\x04\x03\x02\x08\x12\x03f\x08\
    +\n\x0c\n\x05\x04\x03\x02\x08\x04\x12\x03f\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\x08\x05\x12\x03f\x11\x17\n\x0c\n\x05\x04\x03\x02\x08\x01\x12\x03f\
    \x18%\n\x0c\n\x05\x04\x03\x02\x08\x03\x12\x03f(*\n\x0b\n\x04\x04\x03\x02\
    \t\x12\x03g\x080\n\x0c\n\x05\x04\x03\x02\t\x04\x12\x03g\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\t\x05\x12\x03g\x11\x17\n\x0c\n\x05\x04\x03\x02\t\x01\
    \x12\x03g\x18*\n\x0c\n\x05\x04\x03\x02\t\x03\x12\x03g-/\n\x0b\n\x04\x04\
    \x03\x02\n\x12\x03h\x08*\n\x0c\n\x05\x04\x03\x02\n\x04\x12\x03h\x08\x10\
    \n\x0c\n\x05\x04\x03\x02\n\x05\x12\x03h\x11\x17\n\x0c\n\x05\x04\x03\x02\
    \n\x01\x12\x03h\x18$\n\x0c\n\x05\x04\x03\x02\n\x03\x12\x03h')\n\x0b\n\
    \x04\x04\x03\x02\x0b\x12\x03i\x08/\n\x0c\n\x05\x04\x03\x02\x0b\x04\x12\
    \x03i\x08\x10\n\x0c\n\x05\x04\x03\x02\x0b\x05\x12\x03i\x11\x15\n\x0c\n\
    \x05\x04\x03\x02\x0b\x01\x12\x03i\x16)\n\x0c\n\x05\x04\x03\x02\x0b\x03\
    \x12\x03i,.\n\x0b\n\x04\x04\x03\x02\x0c\x12\x03j\x08:\n\x0c\n\x05\x04\
    \x03\x02\x0c\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x03\x02\x0c\x05\x12\
    \x03j\x11\x16\n\x0c\n\x05\x04\x03\x02\x0c\x01\x12\x03j\x17&\n\x0c\n\x05\
    \x04\x03\x02\x0c\x03\x12\x03j)+\n\x0c\n\x05\x04\x03\x02\x0c\x08\x12\x03j\
    ,9\n\x0c\n\x05\x04\x03\x02\x0c\x07\x12\x03j78\n\x0b\n\x04\x04\x03\x02\r\
    \x12\x03k\x08H\n\x0c\n\x05\x04\x03\x02\r\x04\x12\x03k\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\r\x05\x12\x03k\x11\x17\n\x0c\n\x05\x04\x03\x02\r\x01\
    \x12\x03k\x18!\n\x0c\n\x05\x04\x03\x02\r\x03\x12\x03k$&\n\x0c\n\x05\x04\
    \x03\x02\r\x08\x12\x03k'G\n\x0c\n\x05\x04\x03\x02\r\x07\x12\x03k2F\n\x0b\
    \n\x04\x04\x03\x02\x0e\x12\x03l\x080\n\x0c\n\x05\x04\x03\x02\x0e\x04\x12\
    \x03l\x08\x10\n\x0c\n\x05\x04\x03\x02\x0e\x05\x12\x03l\x11\x17\n\x0c\n\
    \x05\x04\x03\x02\x0e\x01\x12\x03l\x18*\n\x0c\n\x05\x04\x03\x02\x0e\x03\
    \x12\x03l-/\n\x0b\n\x04\x04\x03\x02\x0f\x12\x03m\x08#\n\x0c\n\x05\x04\
    \x03\x02\x0f\x04\x12\x03m\x08\x10\n\x0c\n\x05\x04\x03\x02\x0f\x05\x12\
    \x03m\x11\x17\n\x0c\n\x05\x04\x03\x02\x0f\x01\x12\x03m\x18\x1d\n\x0c\n\
    \x05\x04\x03\x02\x0f\x03\x12\x03m\x20\"\n\x0b\n\x04\x04\x03\x02\x10\x12\
    \x03n\x08'\n\x0c\n\x05\x04\x03\x02\x10\x04\x12\x03n\x08\x10\n\x0c\n\x05\
    \x04\x03\x02\x10\x05\x12\x03n\x11\x17\n\x0c\n\x05\x04\x03\x02\x10\x01\
    \x12\x03n\x18!\n\x0c\n\x05\x04\x03\x02\x10\x03\x12\x03n$&\n\x0b\n\x04\
    \x04\x03\x02\x11\x12\x03o\x08+\n\x0c\n\x05\x04\x03\x02\x11\x04\x12\x03o\
    \x08\x10\n\x0c\n\x05\x04\x03\x02\x11\x05\x12\x03o\x11\x17\n\x0c\n\x05\
    \x04\x03\x02\x11\x01\x12\x03o\x18%\n\x0c\n\x05\x04\x03\x02\x11\x03\x12\
    \x03o(*\n\x0b\n\x04\x04\x03\x02\x12\x12\x03p\x083\n\x0c\n\x05\x04\x03\
    \x02\x12\x04\x12\x03p\x08\x10\n\x0c\n\x05\x04\x03\x02\x12\x05\x12\x03p\
    \x11\x15\n\x0c\n\x05\x04\x03\x02\x12\x01\x12\x03p\x16-\n\x0c\n\x05\x04\
    \x03\x02\x12\x03\x12\x03p02\n\x0b\n\x04\x04\x03\x02\x13\x12\x03q\x08.\n\
    \x0c\n\x05\x04\x03\x02\x13\x04\x12\x03q\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \x13\x05\x12\x03q\x11\x17\n\x0c\n\x05\x04\x03\x02\x13\x01\x12\x03q\x18(\
    \n\x0c\n\x05\x04\x03\x02\x13\x03\x12\x03q+-\n\x0b\n\x04\x04\x03\x02\x14\
    \x12\x03r\x08&\n\x0c\n\x05\x04\x03\x02\x14\x04\x12\x03r\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\x14\x05\x12\x03r\x11\x17\n\x0c\n\x05\x04\x03\x02\x14\
    \x01\x12\x03r\x18\x20\n\x0c\n\x05\x04\x03\x02\x14\x03\x12\x03r#%\n\x0b\n\
    \x04\x04\x03\x02\x15\x12\x03s\x089\n\x0c\n\x05\x04\x03\x02\x15\x04\x12\
    \x03s\x08\x10\n\x0c\n\x05\x04\x03\x02\x15\x05\x12\x03s\x11\x17\n\x0c\n\
    \x05\x04\x03\x02\x15\x01\x12\x03s\x18%\n\x0c\n\x05\x04\x03\x02\x15\x03\
    \x12\x03s(*\n\x0c\n\x05\x04\x03\x02\x15\x08\x12\x03s+8\n\x0c\n\x05\x04\
    \x03\x02\x15\x07\x12\x03s67\n\x0b\n\x04\x04\x03\x02\x16\x12\x03t\x081\n\
    \x0c\n\x05\x04\x03\x02\x16\x04\x12\x03t\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \x16\x05\x12\x03t\x11\x17\n\x0c\n\x05\x04\x03\x02\x16\x01\x12\x03t\x18\
    \x1d\n\x0c\n\x05\x04\x03\x02\x16\x03\x12\x03t\x20\"\n\x0c\n\x05\x04\x03\
    \x02\x16\x08\x12\x03t#0\n\x0c\n\x05\x04\x03\x02\x16\x07\x12\x03t./\n\x0b\
    \n\x04\x04\x03\x02\x17\x12\x03u\x086\n\x0c\n\x05\x04\x03\x02\x17\x04\x12\
    \x03u\x08\x10\n\x0c\n\x05\x04\x03\x02\x17\x05\x12\x03u\x11\x16\n\x0c\n\
    \x05\x04\x03\x02\x17\x01\x12\x03u\x17!\n\x0c\n\x05\x04\x03\x02\x17\x03\
    \x12\x03u$&\n\x0c\n\x05\x04\x03\x02\x17\x08\x12\x03u'5\n\x0c\n\x05\x04\
    \x03\x02\x17\x07\x12\x03u24\n\x0b\n\x04\x04\x03\x02\x18\x12\x03v\x08*\n\
    \x0c\n\x05\x04\x03\x02\x18\x04\x12\x03v\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \x18\x05\x12\x03v\x11\x17\n\x0c\n\x05\x04\x03\x02\x18\x01\x12\x03v\x18$\
    \n\x0c\n\x05\x04\x03\x02\x18\x03\x12\x03v')\n\x0b\n\x04\x04\x03\x02\x19\
    \x12\x03w\x087\n\x0c\n\x05\x04\x03\x02\x19\x04\x12\x03w\x08\x10\n\x0c\n\
    \x05\x04\x03\x02\x19\x05\x12\x03w\x11\x17\n\x0c\n\x05\x04\x03\x02\x19\
    \x01\x12\x03w\x181\n\x0c\n\x05\x04\x03\x02\x19\x03\x12\x03w46\n\x0b\n\
    \x04\x04\x03\x02\x1a\x12\x03x\x08&\n\x0c\n\x05\x04\x03\x02\x1a\x04\x12\
    \x03x\x08\x10\n\x0c\n\x05\x04\x03\x02\x1a\x05\x12\x03x\x11\x17\n\x0c\n\
    \x05\x04\x03\x02\x1a\x01\x12\x03x\x18\x20\n\x0c\n\x05\x04\x03\x02\x1a\
    \x03\x12\x03x#%\n\x0b\n\x04\x04\x03\x02\x1b\x12\x03y\x08>\n\x0c\n\x05\
    \x04\x03\x02\x1b\x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\x03\x02\x1b\x06\
    \x12\x03y\x11-\n\x0c\n\x05\x04\x03\x02\x1b\x01\x12\x03y.8\n\x0c\n\x05\
    \x04\x03\x02\x1b\x03\x12\x03y;=\n\x0c\n\x04\x04\x03\x08\0\x12\x04{\x08~\
    \t\n\x0c\n\x05\x04\x03\x08\0\x01\x12\x03{\x0e\x15\n\x0b\n\x04\x04\x03\
    \x02\x1c\x12\x03|\x10\x1f\n\x0c\n\x05\x04\x03\x02\x1c\x05\x12\x03|\x10\
    \x16\n\x0c\n\x05\x04\x03\x02\x1c\x01\x12\x03|\x17\x19\n\x0c\n\x05\x04\
    \x03\x02\x1c\x03\x12\x03|\x1c\x1e\n\x0b\n\x04\x04\x03\x02\x1d\x12\x03}\
    \x10!\n\x0c\n\x05\x04\x03\x02\x1d\x05\x12\x03}\x10\x15\n\x0c\n\x05\x04\
    \x03\x02\x1d\x01\x12\x03}\x16\x1b\n\x0c\n\x05\x04\x03\x02\x1d\x03\x12\
    \x03}\x1e\x20\n\x0c\n\x02\x04\x04\x12\x06\x81\x01\0\x84\x01\x01\n\x0b\n\
    \x03\x04\x04\x01\x12\x04\x81\x01\x08\x11\n\x0c\n\x04\x04\x04\x02\0\x12\
    \x04\x82\x01\x08*\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\x82\x01\x08\x10\n\
    \r\n\x05\x04\x04\x02\0\x05\x12\x04\x82\x01\x11\x17\n\r\n\x05\x04\x04\x02\
    \0\x01\x12\x04\x82\x01\x18%\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\x82\x01(\
    )\n\x0c\n\x04\x04\x04\x02\x01\x12\x04\x83\x01\x08(\n\r\n\x05\x04\x04\x02\
    \x01\x04\x12\x04\x83\x01\x08\x10\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\
    \x83\x01\x11\x16\n\r\n\x05\x04\x04\x02\x01\x01\x12\x04\x83\x01\x17#\n\r\
    \n\x05\x04\x04\x02\x01\x03\x12\x04\x83\x01&'\n\x0c\n\x02\x04\x05\x12\x06\
    \x86\x01\0\x88\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x86\x01\x08\x1b\n\
    \x0c\n\x04\x04\x05\x02\0\x12\x04\x87\x01\x08(\n\r\n\x05\x04\x05\x02\0\
    \x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\x87\x01\
    \x11\x16\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x87\x01\x17#\n\r\n\x05\x04\
    \x05\x02\0\x03\x12\x04\x87\x01&'\n\x0c\n\x02\x04\x06\x12\x06\x8a\x01\0\
    \x93\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x8a\x01\x08\x16\n\x0c\n\x04\
    \x04\x06\x02\0\x12\x04\x8b\x01\x08#\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\
    \x8b\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x8b\x01\x11\x17\n\r\
    \n\x05\x04\x06\x02\0\x01\x12\x04\x8b\x01\x18\x1e\n\r\n\x05\x04\x06\x02\0\
    \x03\x12\x04\x8b\x01!\"\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\x8c\x01\x082\
    \n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\x06\
    \x02\x01\x05\x12\x04\x8c\x01\x11\x17\n\r\n\x05\x04\x06\x02\x01\x01\x12\
    \x04\x8c\x01\x18\x1f\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\x8c\x01\"#\n\
    \r\n\x05\x04\x06\x02\x01\x08\x12\x04\x8c\x01$1\n\r\n\x05\x04\x06\x02\x01\
    \x07\x12\x04\x8c\x01/0\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\x8d\x01\x08%\
    \n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\x8d\x01\x08\x10\n\r\n\x05\x04\x06\
    \x02\x02\x05\x12\x04\x8d\x01\x11\x18\n\r\n\x05\x04\x06\x02\x02\x01\x12\
    \x04\x8d\x01\x19\x20\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x8d\x01#$\n\
    \x0c\n\x04\x04\x06\x02\x03\x12\x04\x8e\x01\x08$\n\r\n\x05\x04\x06\x02\
    \x03\x04\x12\x04\x8e\x01\x08\x10\n\r\n\x05\x04\x06\x02\x03\x05\x12\x04\
    \x8e\x01\x11\x18\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\x8e\x01\x19\x1f\n\
    \r\n\x05\x04\x06\x02\x03\x03\x12\x04\x8e\x01\"#\n\x0c\n\x04\x04\x06\x02\
    \x04\x12\x04\x8f\x01\x08)\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04\x8f\x01\
    \x08\x10\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\x8f\x01\x11\x17\n\r\n\x05\
    \x04\x06\x02\x04\x01\x12\x04\x8f\x01\x18$\n\r\n\x05\x04\x06\x02\x04\x03\
    \x12\x04\x8f\x01'(\n\x0c\n\x04\x04\x06\x02\x05\x12\x04\x90\x01\x08'\n\r\
    \n\x05\x04\x06\x02\x05\x04\x12\x04\x90\x01\x08\x10\n\r\n\x05\x04\x06\x02\
    \x05\x05\x12\x04\x90\x01\x11\x17\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\
    \x90\x01\x18\"\n\r\n\x05\x04\x06\x02\x05\x03\x12\x04\x90\x01%&\n\x0c\n\
    \x04\x04\x06\x02\x06\x12\x04\x91\x01\x08\"\n\r\n\x05\x04\x06\x02\x06\x04\
    \x12\x04\x91\x01\x08\x10\n\r\n\x05\x04\x06\x02\x06\x05\x12\x04\x91\x01\
    \x11\x16\n\r\n\x05\x04\x06\x02\x06\x01\x12\x04\x91\x01\x17\x1d\n\r\n\x05\
    \x04\x06\x02\x06\x03\x12\x04\x91\x01\x20!\n\x0c\n\x04\x04\x06\x02\x07\
    \x12\x04\x92\x01\x08)\n\r\n\x05\x04\x06\x02\x07\x04\x12\x04\x92\x01\x08\
    \x10\n\r\n\x05\x04\x06\x02\x07\x05\x12\x04\x92\x01\x11\x16\n\r\n\x05\x04\
    \x06\x02\x07\x01\x12\x04\x92\x01\x17$\n\r\n\x05\x04\x06\x02\x07\x03\x12\
    \x04\x92\x01'(\n\x0c\n\x02\x04\x07\x12\x06\x95\x01\0\xa5\x01\x01\n\x0b\n\
    \x03\x04\x07\x01\x12\x04\x95\x01\x08\x1c\n\x0c\n\x04\x04\x07\x02\0\x12\
    \x04\x96\x01\x08\"\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\x96\x01\x08\x10\n\
    \r\n\x05\x04\x07\x02\0\x05\x12\x04\x96\x01\x11\x17\n\r\n\x05\x04\x07\x02\
    \0\x01\x12\x04\x96\x01\x18\x1d\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x96\
    \x01\x20!\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\x97\x01\x08!\n\r\n\x05\x04\
    \x07\x02\x01\x04\x12\x04\x97\x01\x08\x10\n\r\n\x05\x04\x07\x02\x01\x05\
    \x12\x04\x97\x01\x11\x17\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x97\x01\
    \x18\x1c\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x97\x01\x1f\x20\n\x0c\n\
    \x04\x04\x07\x02\x02\x12\x04\x98\x01\x08!\n\r\n\x05\x04\x07\x02\x02\x04\
    \x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\x98\x01\
    \x11\x17\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\x98\x01\x18\x1c\n\r\n\x05\
    \x04\x07\x02\x02\x03\x12\x04\x98\x01\x1f\x20\n\x0c\n\x04\x04\x07\x02\x03\
    \x12\x04\x99\x01\x08\x1f\n\r\n\x05\x04\x07\x02\x03\x04\x12\x04\x99\x01\
    \x08\x10\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\x99\x01\x11\x15\n\r\n\x05\
    \x04\x07\x02\x03\x01\x12\x04\x99\x01\x16\x1a\n\r\n\x05\x04\x07\x02\x03\
    \x03\x12\x04\x99\x01\x1d\x1e\n\x0c\n\x04\x04\x07\x02\x04\x12\x04\x9a\x01\
    \x08\x1f\n\r\n\x05\x04\x07\x02\x04\x04\x12\x04\x9a\x01\x08\x10\n\r\n\x05\
    \x04\x07\x02\x04\x05\x12\x04\x9a\x01\x11\x15\n\r\n\x05\x04\x07\x02\x04\
    \x01\x12\x04\x9a\x01\x16\x1a\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\x9a\
    \x01\x1d\x1e\n\x0c\n\x04\x04\x07\x02\x05\x12\x04\x9b\x01\x08\x20\n\r\n\
    \x05\x04\x07\x02\x05\x04\x12\x04\x9b\x01\x08\x10\n\r\n\x05\x04\x07\x02\
    \x05\x05\x12\x04\x9b\x01\x11\x15\n\r\n\x05\x04\x07\x02\x05\x01\x12\x04\
    \x9b\x01\x16\x1b\n\r\n\x05\x04\x07\x02\x05\x03\x12\x04\x9b\x01\x1e\x1f\n\
    \x0c\n\x04\x04\x07\x02\x06\x12\x04\x9c\x01\x082\n\r\n\x05\x04\x07\x02\
    \x06\x04\x12\x04\x9c\x01\x08\x10\n\r\n\x05\x04\x07\x02\x06\x05\x12\x04\
    \x9c\x01\x11\x15\n\r\n\x05\x04\x07\x02\x06\x01\x12\x04\x9c\x01\x16-\n\r\
    \n\x05\x04\x07\x02\x06\x03\x12\x04\x9c\x0101\n\x0c\n\x04\x04\x07\x02\x07\
    \x12\x04\x9d\x01\x08+\n\r\n\x05\x04\x07\x02\x07\x04\x12\x04\x9d\x01\x08\
    \x10\n\r\n\x05\x04\x07\x02\x07\x05\x12\x04\x9d\x01\x11\x17\n\r\n\x05\x04\
    \x07\x02\x07\x01\x12\x04\x9d\x01\x18%\n\r\n\x05\x04\x07\x02\x07\x03\x12\
    \x04\x9d\x01(*\n\x0c\n\x04\x04\x07\x02\x08\x12\x04\x9e\x01\x08)\n\r\n\
    \x05\x04\x07\x02\x08\x04\x12\x04\x9e\x01\x08\x10\n\r\n\x05\x04\x07\x02\
    \x08\x05\x12\x04\x9e\x01\x11\x17\n\r\n\x05\x04\x07\x02\x08\x01\x12\x04\
    \x9e\x01\x18#\n\r\n\x05\x04\x07\x02\x08\x03\x12\x04\x9e\x01&(\n\x0c\n\
    \x04\x04\x07\x02\t\x12\x04\x9f\x01\x08-\n\r\n\x05\x04\x07\x02\t\x04\x12\
    \x04\x9f\x01\x08\x10\n\r\n\x05\x04\x07\x02\t\x05\x12\x04\x9f\x01\x11\x15\
    \n\r\n\x05\x04\x07\x02\t\x01\x12\x04\x9f\x01\x16'\n\r\n\x05\x04\x07\x02\
    \t\x03\x12\x04\x9f\x01*,\n\x0c\n\x04\x04\x07\x02\n\x12\x04\xa0\x01\x085\
    \n\r\n\x05\x04\x07\x02\n\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x07\
    \x02\n\x05\x12\x04\xa0\x01\x11\x15\n\r\n\x05\x04\x07\x02\n\x01\x12\x04\
    \xa0\x01\x16/\n\r\n\x05\x04\x07\x02\n\x03\x12\x04\xa0\x0124\n\x0c\n\x04\
    \x04\x07\x02\x0b\x12\x04\xa1\x01\x08&\n\r\n\x05\x04\x07\x02\x0b\x04\x12\
    \x04\xa1\x01\x08\x10\n\r\n\x05\x04\x07\x02\x0b\x05\x12\x04\xa1\x01\x11\
    \x17\n\r\n\x05\x04\x07\x02\x0b\x01\x12\x04\xa1\x01\x18\x20\n\r\n\x05\x04\
    \x07\x02\x0b\x03\x12\x04\xa1\x01#%\n\x0c\n\x04\x04\x07\x02\x0c\x12\x04\
    \xa2\x01\x081\n\r\n\x05\x04\x07\x02\x0c\x04\x12\x04\xa2\x01\x08\x10\n\r\
    \n\x05\x04\x07\x02\x0c\x05\x12\x04\xa2\x01\x11\x15\n\r\n\x05\x04\x07\x02\
    \x0c\x01\x12\x04\xa2\x01\x16+\n\r\n\x05\x04\x07\x02\x0c\x03\x12\x04\xa2\
    \x01.0\n\x0c\n\x04\x04\x07\x02\r\x12\x04\xa3\x01\x086\n\r\n\x05\x04\x07\
    \x02\r\x04\x12\x04\xa3\x01\x08\x10\n\r\n\x05\x04\x07\x02\r\x05\x12\x04\
    \xa3\x01\x11\x15\n\r\n\x05\x04\x07\x02\r\x01\x12\x04\xa3\x01\x160\n\r\n\
    \x05\x04\x07\x02\r\x03\x12\x04\xa3\x0135\n\x0c\n\x04\x04\x07\x02\x0e\x12\
    \x04\xa4\x01\x083\n\r\n\x05\x04\x07\x02\x0e\x04\x12\x04\xa4\x01\x08\x10\
    \n\r\n\x05\x04\x07\x02\x0e\x05\x12\x04\xa4\x01\x11\x17\n\r\n\x05\x04\x07\
    \x02\x0e\x01\x12\x04\xa4\x01\x18-\n\r\n\x05\x04\x07\x02\x0e\x03\x12\x04\
    \xa4\x0102\n\x0c\n\x02\x04\x08\x12\x06\xa7\x01\0\xb9\x01\x01\n\x0b\n\x03\
    \x04\x08\x01\x12\x04\xa7\x01\x08\x15\n\x0c\n\x04\x04\x08\x02\0\x12\x04\
    \xa8\x01\x08$\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xa8\x01\x08\x10\n\r\n\
    \x05\x04\x08\x02\0\x05\x12\x04\xa8\x01\x11\x15\n\r\n\x05\x04\x08\x02\0\
    \x01\x12\x04\xa8\x01\x16\x1f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xa8\x01\
    \"#\n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xa9\x01\x08\"\n\r\n\x05\x04\x08\
    \x02\x01\x04\x12\x04\xa9\x01\x08\x10\n\r\n\x05\x04\x08\x02\x01\x05\x12\
    \x04\xa9\x01\x11\x15\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xa9\x01\x16\
    \x1d\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xa9\x01\x20!\n\x0c\n\x04\x04\
    \x08\x02\x02\x12\x04\xaa\x01\x08*\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\
    \xaa\x01\x08\x10\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xaa\x01\x11\x15\n\
    \r\n\x05\x04\x08\x02\x02\x01\x12\x04\xaa\x01\x16%\n\r\n\x05\x04\x08\x02\
    \x02\x03\x12\x04\xaa\x01()\n\x0c\n\x04\x04\x08\x02\x03\x12\x04\xab\x01\
    \x08#\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04\xab\x01\x08\x10\n\r\n\x05\
    \x04\x08\x02\x03\x05\x12\x04\xab\x01\x11\x15\n\r\n\x05\x04\x08\x02\x03\
    \x01\x12\x04\xab\x01\x16\x1e\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\xab\
    \x01!\"\n\x0c\n\x04\x04\x08\x02\x04\x12\x04\xac\x01\x08(\n\r\n\x05\x04\
    \x08\x02\x04\x04\x12\x04\xac\x01\x08\x10\n\r\n\x05\x04\x08\x02\x04\x05\
    \x12\x04\xac\x01\x11\x15\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\xac\x01\
    \x16#\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xac\x01&'\n\x0c\n\x04\x04\
    \x08\x02\x05\x12\x04\xad\x01\x08*\n\r\n\x05\x04\x08\x02\x05\x04\x12\x04\
    \xad\x01\x08\x10\n\r\n\x05\x04\x08\x02\x05\x05\x12\x04\xad\x01\x11\x15\n\
    \r\n\x05\x04\x08\x02\x05\x01\x12\x04\xad\x01\x16%\n\r\n\x05\x04\x08\x02\
    \x05\x03\x12\x04\xad\x01()\n\x0c\n\x04\x04\x08\x02\x06\x12\x04\xae\x01\
    \x08*\n\r\n\x05\x04\x08\x02\x06\x04\x12\x04\xae\x01\x08\x10\n\r\n\x05\
    \x04\x08\x02\x06\x05\x12\x04\xae\x01\x11\x15\n\r\n\x05\x04\x08\x02\x06\
    \x01\x12\x04\xae\x01\x16%\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\xae\x01(\
    )\n\x0c\n\x04\x04\x08\x02\x07\x12\x04\xaf\x01\x08%\n\r\n\x05\x04\x08\x02\
    \x07\x04\x12\x04\xaf\x01\x08\x10\n\r\n\x05\x04\x08\x02\x07\x05\x12\x04\
    \xaf\x01\x11\x15\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\xaf\x01\x16\x20\n\
    \r\n\x05\x04\x08\x02\x07\x03\x12\x04\xaf\x01#$\n\x0c\n\x04\x04\x08\x02\
    \x08\x12\x04\xb0\x01\x08)\n\r\n\x05\x04\x08\x02\x08\x04\x12\x04\xb0\x01\
    \x08\x10\n\r\n\x05\x04\x08\x02\x08\x05\x12\x04\xb0\x01\x11\x15\n\r\n\x05\
    \x04\x08\x02\x08\x01\x12\x04\xb0\x01\x16$\n\r\n\x05\x04\x08\x02\x08\x03\
    \x12\x04\xb0\x01'(\n\x0c\n\x04\x04\x08\x02\t\x12\x04\xb1\x01\x08)\n\r\n\
    \x05\x04\x08\x02\t\x04\x12\x04\xb1\x01\x08\x10\n\r\n\x05\x04\x08\x02\t\
    \x05\x12\x04\xb1\x01\x11\x15\n\r\n\x05\x04\x08\x02\t\x01\x12\x04\xb1\x01\
    \x16#\n\r\n\x05\x04\x08\x02\t\x03\x12\x04\xb1\x01&(\n\x0c\n\x04\x04\x08\
    \x02\n\x12\x04\xb2\x01\x08*\n\r\n\x05\x04\x08\x02\n\x04\x12\x04\xb2\x01\
    \x08\x10\n\r\n\x05\x04\x08\x02\n\x05\x12\x04\xb2\x01\x11\x15\n\r\n\x05\
    \x04\x08\x02\n\x01\x12\x04\xb2\x01\x16$\n\r\n\x05\x04\x08\x02\n\x03\x12\
    \x04\xb2\x01')\n\x0c\n\x04\x04\x08\x02\x0b\x12\x04\xb3\x01\x08+\n\r\n\
    \x05\x04\x08\x02\x0b\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x0b\x05\x12\x04\xb3\x01\x11\x15\n\r\n\x05\x04\x08\x02\x0b\x01\x12\x04\
    \xb3\x01\x16%\n\r\n\x05\x04\x08\x02\x0b\x03\x12\x04\xb3\x01(*\n\x0c\n\
    \x04\x04\x08\x02\x0c\x12\x04\xb4\x01\x086\n\r\n\x05\x04\x08\x02\x0c\x04\
    \x12\x04\xb4\x01\x08\x10\n\r\n\x05\x04\x08\x02\x0c\x05\x12\x04\xb4\x01\
    \x11\x15\n\r\n\x05\x04\x08\x02\x0c\x01\x12\x04\xb4\x01\x160\n\r\n\x05\
    \x04\x08\x02\x0c\x03\x12\x04\xb4\x0135\n\x0c\n\x04\x04\x08\x02\r\x12\x04\
    \xb5\x01\x08*\n\r\n\x05\x04\x08\x02\r\x04\x12\x04\xb5\x01\x08\x10\n\r\n\
    \x05\x04\x08\x02\r\x05\x12\x04\xb5\x01\x11\x15\n\r\n\x05\x04\x08\x02\r\
    \x01\x12\x04\xb5\x01\x16$\n\r\n\x05\x04\x08\x02\r\x03\x12\x04\xb5\x01')\
    \n\x0c\n\x04\x04\x08\x02\x0e\x12\x04\xb6\x01\x08*\n\r\n\x05\x04\x08\x02\
    \x0e\x04\x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\x08\x02\x0e\x05\x12\x04\
    \xb6\x01\x11\x15\n\r\n\x05\x04\x08\x02\x0e\x01\x12\x04\xb6\x01\x16$\n\r\
    \n\x05\x04\x08\x02\x0e\x03\x12\x04\xb6\x01')\n\x0c\n\x04\x04\x08\x02\x0f\
    \x12\x04\xb7\x01\x082\n\r\n\x05\x04\x08\x02\x0f\x04\x12\x04\xb7\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\x0f\x05\x12\x04\xb7\x01\x11\x15\n\r\n\x05\x04\
    \x08\x02\x0f\x01\x12\x04\xb7\x01\x16,\n\r\n\x05\x04\x08\x02\x0f\x03\x12\
    \x04\xb7\x01/1\n\x0c\n\x04\x04\x08\x02\x10\x12\x04\xb8\x01\x086\n\r\n\
    \x05\x04\x08\x02\x10\x04\x12\x04\xb8\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x10\x05\x12\x04\xb8\x01\x11\x15\n\r\n\x05\x04\x08\x02\x10\x01\x12\x04\
    \xb8\x01\x160\n\r\n\x05\x04\x08\x02\x10\x03\x12\x04\xb8\x0135\n\x0c\n\
    \x02\x04\t\x12\x06\xbb\x01\0\xca\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xbb\x01\x08\x1b\n\x0c\n\x04\x04\t\x02\0\x12\x04\xbc\x01\x080\n\r\n\x05\
    \x04\t\x02\0\x04\x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\t\x02\0\x05\x12\
    \x04\xbc\x01\x11\x17\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xbc\x01\x18+\n\r\
    \n\x05\x04\t\x02\0\x03\x12\x04\xbc\x01./\n\x0c\n\x04\x04\t\x02\x01\x12\
    \x04\xbd\x01\x08+\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xbd\x01\x08\x10\n\
    \r\n\x05\x04\t\x02\x01\x05\x12\x04\xbd\x01\x11\x15\n\r\n\x05\x04\t\x02\
    \x01\x01\x12\x04\xbd\x01\x16&\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xbd\
    \x01)*\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xbe\x01\x08'\n\r\n\x05\x04\t\
    \x02\x02\x04\x12\x04\xbe\x01\x08\x10\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\
    \xbe\x01\x11\x15\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xbe\x01\x16\"\n\r\n\
    \x05\x04\t\x02\x02\x03\x12\x04\xbe\x01%&\n\x0c\n\x04\x04\t\x02\x03\x12\
    \x04\xbf\x01\x08)\n\r\n\x05\x04\t\x02\x03\x04\x12\x04\xbf\x01\x08\x10\n\
    \r\n\x05\x04\t\x02\x03\x05\x12\x04\xbf\x01\x11\x15\n\r\n\x05\x04\t\x02\
    \x03\x01\x12\x04\xbf\x01\x16$\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xbf\
    \x01'(\n\x0c\n\x04\x04\t\x02\x04\x12\x04\xc0\x01\x08%\n\r\n\x05\x04\t\
    \x02\x04\x04\x12\x04\xc0\x01\x08\x10\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\
    \xc0\x01\x11\x15\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\xc0\x01\x16\x20\n\r\
    \n\x05\x04\t\x02\x04\x03\x12\x04\xc0\x01#$\n\x0c\n\x04\x04\t\x02\x05\x12\
    \x04\xc1\x01\x081\n\r\n\x05\x04\t\x02\x05\x04\x12\x04\xc1\x01\x08\x10\n\
    \r\n\x05\x04\t\x02\x05\x05\x12\x04\xc1\x01\x11\x15\n\r\n\x05\x04\t\x02\
    \x05\x01\x12\x04\xc1\x01\x16,\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xc1\
    \x01/0\n\x0c\n\x04\x04\t\x02\x06\x12\x04\xc2\x01\x08,\n\r\n\x05\x04\t\
    \x02\x06\x04\x12\x04\xc2\x01\x08\x10\n\r\n\x05\x04\t\x02\x06\x05\x12\x04\
    \xc2\x01\x11\x15\n\r\n\x05\x04\t\x02\x06\x01\x12\x04\xc2\x01\x16'\n\r\n\
    \x05\x04\t\x02\x06\x03\x12\x04\xc2\x01*+\n\x0c\n\x04\x04\t\x02\x07\x12\
    \x04\xc3\x01\x08.\n\r\n\x05\x04\t\x02\x07\x04\x12\x04\xc3\x01\x08\x10\n\
    \r\n\x05\x04\t\x02\x07\x05\x12\x04\xc3\x01\x11\x17\n\r\n\x05\x04\t\x02\
    \x07\x01\x12\x04\xc3\x01\x18)\n\r\n\x05\x04\t\x02\x07\x03\x12\x04\xc3\
    \x01,-\n\x0c\n\x04\x04\t\x02\x08\x12\x04\xc4\x01\x08+\n\r\n\x05\x04\t\
    \x02\x08\x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\x04\t\x02\x08\x05\x12\x04\
    \xc4\x01\x11\x17\n\r\n\x05\x04\t\x02\x08\x01\x12\x04\xc4\x01\x18&\n\r\n\
    \x05\x04\t\x02\x08\x03\x12\x04\xc4\x01)*\n\x0c\n\x04\x04\t\x02\t\x12\x04\
    \xc5\x01\x08-\n\r\n\x05\x04\t\x02\t\x04\x12\x04\xc5\x01\x08\x10\n\r\n\
    \x05\x04\t\x02\t\x05\x12\x04\xc5\x01\x11\x17\n\r\n\x05\x04\t\x02\t\x01\
    \x12\x04\xc5\x01\x18'\n\r\n\x05\x04\t\x02\t\x03\x12\x04\xc5\x01*,\n\x0c\
    \n\x04\x04\t\x02\n\x12\x04\xc6\x01\x08+\n\r\n\x05\x04\t\x02\n\x04\x12\
    \x04\xc6\x01\x08\x10\n\r\n\x05\x04\t\x02\n\x05\x12\x04\xc6\x01\x11\x17\n\
    \r\n\x05\x04\t\x02\n\x01\x12\x04\xc6\x01\x18%\n\r\n\x05\x04\t\x02\n\x03\
    \x12\x04\xc6\x01(*\n\x0c\n\x04\x04\t\x02\x0b\x12\x04\xc7\x01\x08)\n\r\n\
    \x05\x04\t\x02\x0b\x04\x12\x04\xc7\x01\x08\x10\n\r\n\x05\x04\t\x02\x0b\
    \x05\x12\x04\xc7\x01\x11\x17\n\r\n\x05\x04\t\x02\x0b\x01\x12\x04\xc7\x01\
    \x18#\n\r\n\x05\x04\t\x02\x0b\x03\x12\x04\xc7\x01&(\n\x0c\n\x04\x04\t\
    \x02\x0c\x12\x04\xc8\x01\x08,\n\r\n\x05\x04\t\x02\x0c\x04\x12\x04\xc8\
    \x01\x08\x10\n\r\n\x05\x04\t\x02\x0c\x05\x12\x04\xc8\x01\x11\x17\n\r\n\
    \x05\x04\t\x02\x0c\x01\x12\x04\xc8\x01\x18&\n\r\n\x05\x04\t\x02\x0c\x03\
    \x12\x04\xc8\x01)+\n\x0c\n\x04\x04\t\x02\r\x12\x04\xc9\x01\x08*\n\r\n\
    \x05\x04\t\x02\r\x04\x12\x04\xc9\x01\x08\x10\n\r\n\x05\x04\t\x02\r\x05\
    \x12\x04\xc9\x01\x11\x15\n\r\n\x05\x04\t\x02\r\x01\x12\x04\xc9\x01\x16$\
    \n\r\n\x05\x04\t\x02\r\x03\x12\x04\xc9\x01')\n\x0c\n\x02\x04\n\x12\x06\
    \xcc\x01\0\xcf\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xcc\x01\x08\x1a\n\
    \x0c\n\x04\x04\n\x02\0\x12\x04\xcd\x01\x08%\n\r\n\x05\x04\n\x02\0\x04\
    \x12\x04\xcd\x01\x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xcd\x01\x11\
    \x17\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xcd\x01\x18\x20\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\xcd\x01#$\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xce\x01\
    \x08-\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xce\x01\x08\x10\n\r\n\x05\x04\
    \n\x02\x01\x05\x12\x04\xce\x01\x11\x17\n\r\n\x05\x04\n\x02\x01\x01\x12\
    \x04\xce\x01\x18(\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xce\x01+,\n\x0c\n\
    \x02\x04\x0b\x12\x06\xd1\x01\0\xdc\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\xd1\x01\x08\x1f\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xd2\x01\x08#\n\r\
    \n\x05\x04\x0b\x02\0\x04\x12\x04\xd2\x01\x08\x10\n\r\n\x05\x04\x0b\x02\0\
    \x05\x12\x04\xd2\x01\x11\x17\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xd2\x01\
    \x18\x1e\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xd2\x01!\"\n\x0c\n\x04\x04\
    \x0b\x02\x01\x12\x04\xd3\x01\x08'\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\
    \xd3\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xd3\x01\x11\x18\n\
    \r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xd3\x01\x19\"\n\r\n\x05\x04\x0b\x02\
    \x01\x03\x12\x04\xd3\x01%&\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\xd4\x01\
    \x08.\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xd4\x01\x08\x10\n\r\n\x05\
    \x04\x0b\x02\x02\x05\x12\x04\xd4\x01\x11\x18\n\r\n\x05\x04\x0b\x02\x02\
    \x01\x12\x04\xd4\x01\x19)\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\xd4\x01,\
    -\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\xd5\x01\x08(\n\r\n\x05\x04\x0b\x02\
    \x03\x04\x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x03\x05\x12\x04\
    \xd5\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\xd5\x01\x18#\n\r\
    \n\x05\x04\x0b\x02\x03\x03\x12\x04\xd5\x01&'\n\x0c\n\x04\x04\x0b\x02\x04\
    \x12\x04\xd6\x01\x08&\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\xd6\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\xd6\x01\x11\x17\n\r\n\x05\x04\
    \x0b\x02\x04\x01\x12\x04\xd6\x01\x18!\n\r\n\x05\x04\x0b\x02\x04\x03\x12\
    \x04\xd6\x01$%\n\x0c\n\x04\x04\x0b\x02\x05\x12\x04\xd7\x01\x08+\n\r\n\
    \x05\x04\x0b\x02\x05\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x05\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\
    \xd7\x01\x18&\n\r\n\x05\x04\x0b\x02\x05\x03\x12\x04\xd7\x01)*\n\x0c\n\
    \x04\x04\x0b\x02\x06\x12\x04\xd8\x01\x08!\n\r\n\x05\x04\x0b\x02\x06\x04\
    \x12\x04\xd8\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x06\x05\x12\x04\xd8\x01\
    \x11\x17\n\r\n\x05\x04\x0b\x02\x06\x01\x12\x04\xd8\x01\x18\x1c\n\r\n\x05\
    \x04\x0b\x02\x06\x03\x12\x04\xd8\x01\x1f\x20\n\x0c\n\x04\x04\x0b\x02\x07\
    \x12\x04\xd9\x01\x08-\n\r\n\x05\x04\x0b\x02\x07\x04\x12\x04\xd9\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x07\x05\x12\x04\xd9\x01\x11\x17\n\r\n\x05\x04\
    \x0b\x02\x07\x01\x12\x04\xd9\x01\x18(\n\r\n\x05\x04\x0b\x02\x07\x03\x12\
    \x04\xd9\x01+,\n\x0c\n\x04\x04\x0b\x02\x08\x12\x04\xda\x01\x08\"\n\r\n\
    \x05\x04\x0b\x02\x08\x04\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x08\x05\x12\x04\xda\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x08\x01\x12\x04\
    \xda\x01\x18\x1d\n\r\n\x05\x04\x0b\x02\x08\x03\x12\x04\xda\x01\x20!\n\
    \x0c\n\x04\x04\x0b\x02\t\x12\x04\xdb\x01\x083\n\r\n\x05\x04\x0b\x02\t\
    \x04\x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x0b\x02\t\x05\x12\x04\xdb\x01\
    \x11\x17\n\r\n\x05\x04\x0b\x02\t\x01\x12\x04\xdb\x01\x18-\n\r\n\x05\x04\
    \x0b\x02\t\x03\x12\x04\xdb\x0102\n\x0c\n\x02\x04\x0c\x12\x06\xde\x01\0\
    \xe3\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xde\x01\x08\x1e\n\x0c\n\x04\
    \x04\x0c\x02\0\x12\x04\xdf\x01\x08)\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\
    \xdf\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xdf\x01\x11\x17\n\r\
    \n\x05\x04\x0c\x02\0\x01\x12\x04\xdf\x01\x18$\n\r\n\x05\x04\x0c\x02\0\
    \x03\x12\x04\xdf\x01'(\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xe0\x01\x08(\
    \n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xe0\x01\x08\x10\n\r\n\x05\x04\x0c\
    \x02\x01\x05\x12\x04\xe0\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xe0\x01\x18#\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xe0\x01&'\n\x0c\
    \n\x04\x04\x0c\x02\x02\x12\x04\xe1\x01\x08&\n\r\n\x05\x04\x0c\x02\x02\
    \x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xe1\
    \x01\x11\x17\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xe1\x01\x18!\n\r\n\
    \x05\x04\x0c\x02\x02\x03\x12\x04\xe1\x01$%\n\x0c\n\x04\x04\x0c\x02\x03\
    \x12\x04\xe2\x01\x085\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04\xe2\x01\x08\
    \x10\n\r\n\x05\x04\x0c\x02\x03\x06\x12\x04\xe2\x01\x11)\n\r\n\x05\x04\
    \x0c\x02\x03\x01\x12\x04\xe2\x01*0\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\
    \xe2\x0134\n\x0c\n\x02\x04\r\x12\x06\xe5\x01\0\xf7\x01\x01\n\x0b\n\x03\
    \x04\r\x01\x12\x04\xe5\x01\x08'\n\x0c\n\x04\x04\r\x02\0\x12\x04\xe6\x01\
    \x08\x20\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xe6\x01\x08\x10\n\r\n\x05\x04\
    \r\x02\0\x05\x12\x04\xe6\x01\x11\x17\n\r\n\x05\x04\r\x02\0\x01\x12\x04\
    \xe6\x01\x18\x1b\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xe6\x01\x1e\x1f\n\x0c\
    \n\x04\x04\r\x02\x01\x12\x04\xe7\x01\x08#\n\r\n\x05\x04\r\x02\x01\x04\
    \x12\x04\xe7\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xe7\x01\x11\
    \x17\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xe7\x01\x18\x1e\n\r\n\x05\x04\r\
    \x02\x01\x03\x12\x04\xe7\x01!\"\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xe8\
    \x01\x08%\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xe8\x01\x08\x10\n\r\n\x05\
    \x04\r\x02\x02\x05\x12\x04\xe8\x01\x11\x17\n\r\n\x05\x04\r\x02\x02\x01\
    \x12\x04\xe8\x01\x18\x20\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xe8\x01#$\n\
    \x0c\n\x04\x04\r\x02\x03\x12\x04\xe9\x01\x08%\n\r\n\x05\x04\r\x02\x03\
    \x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xe9\x01\
    \x11\x17\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xe9\x01\x18\x20\n\r\n\x05\
    \x04\r\x02\x03\x03\x12\x04\xe9\x01#$\n\x0c\n\x04\x04\r\x02\x04\x12\x04\
    \xea\x01\x08%\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\xea\x01\x08\x10\n\r\n\
    \x05\x04\r\x02\x04\x05\x12\x04\xea\x01\x11\x17\n\r\n\x05\x04\r\x02\x04\
    \x01\x12\x04\xea\x01\x18\x20\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\xea\x01\
    #$\n\x0c\n\x04\x04\r\x02\x05\x12\x04\xeb\x01\x08'\n\r\n\x05\x04\r\x02\
    \x05\x04\x12\x04\xeb\x01\x08\x10\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\xeb\
    \x01\x11\x17\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\xeb\x01\x18\"\n\r\n\x05\
    \x04\r\x02\x05\x03\x12\x04\xeb\x01%&\n\x0c\n\x04\x04\r\x02\x06\x12\x04\
    \xec\x01\x08!\n\r\n\x05\x04\r\x02\x06\x04\x12\x04\xec\x01\x08\x10\n\r\n\
    \x05\x04\r\x02\x06\x05\x12\x04\xec\x01\x11\x17\n\r\n\x05\x04\r\x02\x06\
    \x01\x12\x04\xec\x01\x18\x1c\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\xec\x01\
    \x1f\x20\n\x0c\n\x04\x04\r\x02\x07\x12\x04\xed\x01\x08(\n\r\n\x05\x04\r\
    \x02\x07\x04\x12\x04\xed\x01\x08\x10\n\r\n\x05\x04\r\x02\x07\x05\x12\x04\
    \xed\x01\x11\x16\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\xed\x01\x17#\n\r\n\
    \x05\x04\r\x02\x07\x03\x12\x04\xed\x01&'\n\x0c\n\x04\x04\r\x02\x08\x12\
    \x04\xee\x01\x08!\n\r\n\x05\x04\r\x02\x08\x04\x12\x04\xee\x01\x08\x10\n\
    \r\n\x05\x04\r\x02\x08\x05\x12\x04\xee\x01\x11\x17\n\r\n\x05\x04\r\x02\
    \x08\x01\x12\x04\xee\x01\x18\x1c\n\r\n\x05\x04\r\x02\x08\x03\x12\x04\xee\
    \x01\x1f\x20\n\x0c\n\x04\x04\r\x02\t\x12\x04\xef\x01\x08%\n\r\n\x05\x04\
    \r\x02\t\x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\x04\r\x02\t\x05\x12\x04\
    \xef\x01\x11\x16\n\r\n\x05\x04\r\x02\t\x01\x12\x04\xef\x01\x17\x1f\n\r\n\
    \x05\x04\r\x02\t\x03\x12\x04\xef\x01\"$\n\x0c\n\x04\x04\r\x02\n\x12\x04\
    \xf0\x01\x08\"\n\r\n\x05\x04\r\x02\n\x04\x12\x04\xf0\x01\x08\x10\n\r\n\
    \x05\x04\r\x02\n\x05\x12\x04\xf0\x01\x11\x15\n\r\n\x05\x04\r\x02\n\x01\
    \x12\x04\xf0\x01\x16\x1c\n\r\n\x05\x04\r\x02\n\x03\x12\x04\xf0\x01\x1f!\
    \n\x0c\n\x04\x04\r\x02\x0b\x12\x04\xf1\x01\x08-\n\r\n\x05\x04\r\x02\x0b\
    \x04\x12\x04\xf1\x01\x08\x10\n\r\n\x05\x04\r\x02\x0b\x05\x12\x04\xf1\x01\
    \x11\x18\n\r\n\x05\x04\r\x02\x0b\x01\x12\x04\xf1\x01\x19'\n\r\n\x05\x04\
    \r\x02\x0b\x03\x12\x04\xf1\x01*,\n\x0c\n\x04\x04\r\x02\x0c\x12\x04\xf2\
    \x01\x08(\n\r\n\x05\x04\r\x02\x0c\x04\x12\x04\xf2\x01\x08\x10\n\r\n\x05\
    \x04\r\x02\x0c\x05\x12\x04\xf2\x01\x11\x18\n\r\n\x05\x04\r\x02\x0c\x01\
    \x12\x04\xf2\x01\x19\"\n\r\n\x05\x04\r\x02\x0c\x03\x12\x04\xf2\x01%'\n\
    \x0c\n\x04\x04\r\x02\r\x12\x04\xf3\x01\x08(\n\r\n\x05\x04\r\x02\r\x04\
    \x12\x04\xf3\x01\x08\x10\n\r\n\x05\x04\r\x02\r\x05\x12\x04\xf3\x01\x11\
    \x16\n\r\n\x05\x04\r\x02\r\x01\x12\x04\xf3\x01\x17\"\n\r\n\x05\x04\r\x02\
    \r\x03\x12\x04\xf3\x01%'\n\x0c\n\x04\x04\r\x02\x0e\x12\x04\xf4\x01\x08*\
    \n\r\n\x05\x04\r\x02\x0e\x04\x12\x04\xf4\x01\x08\x10\n\r\n\x05\x04\r\x02\
    \x0e\x05\x12\x04\xf4\x01\x11\x16\n\r\n\x05\x04\r\x02\x0e\x01\x12\x04\xf4\
    \x01\x17$\n\r\n\x05\x04\r\x02\x0e\x03\x12\x04\xf4\x01')\n\x0c\n\x04\x04\
    \r\x02\x0f\x12\x04\xf5\x01\x08o\n\r\n\x05\x04\r\x02\x0f\x04\x12\x04\xf5\
    \x01\x08\x10\n\r\n\x05\x04\r\x02\x0f\x06\x12\x04\xf5\x01\x11(\n\r\n\x05\
    \x04\r\x02\x0f\x01\x12\x04\xf5\x01)9\n\r\n\x05\x04\r\x02\x0f\x03\x12\x04\
    \xf5\x01<>\n\r\n\x05\x04\r\x02\x0f\x08\x12\x04\xf5\x01?n\n\r\n\x05\x04\r\
    \x02\x0f\x07\x12\x04\xf5\x01Jm\n\x0c\n\x04\x04\r\x02\x10\x12\x04\xf6\x01\
    \x08\"\n\r\n\x05\x04\r\x02\x10\x04\x12\x04\xf6\x01\x08\x10\n\r\n\x05\x04\
    \r\x02\x10\x05\x12\x04\xf6\x01\x11\x15\n\r\n\x05\x04\r\x02\x10\x01\x12\
    \x04\xf6\x01\x16\x1c\n\r\n\x05\x04\r\x02\x10\x03\x12\x04\xf6\x01\x1f!\n\
    \x0c\n\x02\x04\x0e\x12\x06\xf9\x01\0\x98\x02\x01\n\x0b\n\x03\x04\x0e\x01\
    \x12\x04\xf9\x01\x08\x16\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\xfa\x01\x08!\
    \n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xfa\x01\x08\x10\n\r\n\x05\x04\x0e\
    \x02\0\x05\x12\x04\xfa\x01\x11\x18\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\
    \xfa\x01\x19\x1c\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xfa\x01\x1f\x20\n\
    \x0c\n\x04\x04\x0e\x02\x01\x12\x04\xfb\x01\x08*\n\r\n\x05\x04\x0e\x02\
    \x01\x04\x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\
    \xfb\x01\x11\x18\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xfb\x01\x19%\n\r\
    \n\x05\x04\x0e\x02\x01\x03\x12\x04\xfb\x01()\n\x0c\n\x04\x04\x0e\x02\x02\
    \x12\x04\xfc\x01\x08'\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\xfc\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xfc\x01\x11\x17\n\r\n\x05\x04\
    \x0e\x02\x02\x01\x12\x04\xfc\x01\x18\"\n\r\n\x05\x04\x0e\x02\x02\x03\x12\
    \x04\xfc\x01%&\n\x0c\n\x04\x04\x0e\x02\x03\x12\x04\xfd\x01\x08S\n\r\n\
    \x05\x04\x0e\x02\x03\x04\x12\x04\xfd\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x03\x06\x12\x04\xfd\x01\x11%\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xfd\
    \x01&0\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xfd\x0134\n\r\n\x05\x04\x0e\
    \x02\x03\x08\x12\x04\xfd\x015R\n\r\n\x05\x04\x0e\x02\x03\x07\x12\x04\xfd\
    \x01@Q\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\xfe\x01\x08\"\n\r\n\x05\x04\
    \x0e\x02\x04\x04\x12\x04\xfe\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x04\x05\
    \x12\x04\xfe\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xfe\x01\
    \x18\x1d\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xfe\x01\x20!\n\x0c\n\x04\
    \x04\x0e\x02\x05\x12\x04\xff\x01\x08+\n\r\n\x05\x04\x0e\x02\x05\x04\x12\
    \x04\xff\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xff\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xff\x01\x18&\n\r\n\x05\x04\
    \x0e\x02\x05\x03\x12\x04\xff\x01)*\n\x0c\n\x04\x04\x0e\x02\x06\x12\x04\
    \x80\x02\x08,\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\x80\x02\x08\x10\n\r\
    \n\x05\x04\x0e\x02\x06\x05\x12\x04\x80\x02\x11\x17\n\r\n\x05\x04\x0e\x02\
    \x06\x01\x12\x04\x80\x02\x18'\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\x80\
    \x02*+\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\x81\x02\x08/\n\r\n\x05\x04\
    \x0e\x02\x07\x04\x12\x04\x81\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x07\x05\
    \x12\x04\x81\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\x81\x02\
    \x18*\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\x81\x02-.\n\x0c\n\x04\x04\
    \x0e\x02\x08\x12\x04\x82\x02\x08-\n\r\n\x05\x04\x0e\x02\x08\x04\x12\x04\
    \x82\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\x82\x02\x11\x17\n\
    \r\n\x05\x04\x0e\x02\x08\x01\x12\x04\x82\x02\x18(\n\r\n\x05\x04\x0e\x02\
    \x08\x03\x12\x04\x82\x02+,\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\x83\x02\x08\
    *\n\r\n\x05\x04\x0e\x02\t\x04\x12\x04\x83\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02\t\x05\x12\x04\x83\x02\x11\x16\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\
    \x83\x02\x17$\n\r\n\x05\x04\x0e\x02\t\x03\x12\x04\x83\x02')\n\x0c\n\x04\
    \x04\x0e\x02\n\x12\x04\x84\x02\x08.\n\r\n\x05\x04\x0e\x02\n\x04\x12\x04\
    \x84\x02\x08\x10\n\r\n\x05\x04\x0e\x02\n\x05\x12\x04\x84\x02\x11\x18\n\r\
    \n\x05\x04\x0e\x02\n\x01\x12\x04\x84\x02\x19(\n\r\n\x05\x04\x0e\x02\n\
    \x03\x12\x04\x84\x02+-\n\x0c\n\x04\x04\x0e\x02\x0b\x12\x04\x85\x02\x082\
    \n\r\n\x05\x04\x0e\x02\x0b\x04\x12\x04\x85\x02\x08\x10\n\r\n\x05\x04\x0e\
    \x02\x0b\x05\x12\x04\x85\x02\x11\x18\n\r\n\x05\x04\x0e\x02\x0b\x01\x12\
    \x04\x85\x02\x19,\n\r\n\x05\x04\x0e\x02\x0b\x03\x12\x04\x85\x02/1\n\x0c\
    \n\x04\x04\x0e\x02\x0c\x12\x04\x86\x02\x08)\n\r\n\x05\x04\x0e\x02\x0c\
    \x04\x12\x04\x86\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x0c\x05\x12\x04\x86\
    \x02\x11\x17\n\r\n\x05\x04\x0e\x02\x0c\x01\x12\x04\x86\x02\x18#\n\r\n\
    \x05\x04\x0e\x02\x0c\x03\x12\x04\x86\x02&(\n\x0c\n\x04\x04\x0e\x02\r\x12\
    \x04\x87\x02\x08&\n\r\n\x05\x04\x0e\x02\r\x04\x12\x04\x87\x02\x08\x10\n\
    \r\n\x05\x04\x0e\x02\r\x05\x12\x04\x87\x02\x11\x17\n\r\n\x05\x04\x0e\x02\
    \r\x01\x12\x04\x87\x02\x18\x20\n\r\n\x05\x04\x0e\x02\r\x03\x12\x04\x87\
    \x02#%\n\x0c\n\x04\x04\x0e\x02\x0e\x12\x04\x88\x02\x08I\n\r\n\x05\x04\
    \x0e\x02\x0e\x04\x12\x04\x88\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x0e\x06\
    \x12\x04\x88\x02\x111\n\r\n\x05\x04\x0e\x02\x0e\x01\x12\x04\x88\x022C\n\
    \r\n\x05\x04\x0e\x02\x0e\x03\x12\x04\x88\x02FH\n\x0c\n\x04\x04\x0e\x02\
    \x0f\x12\x04\x89\x02\x08%\n\r\n\x05\x04\x0e\x02\x0f\x04\x12\x04\x89\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x02\x0f\x05\x12\x04\x89\x02\x11\x15\n\r\n\x05\
    \x04\x0e\x02\x0f\x01\x12\x04\x89\x02\x16\x1f\n\r\n\x05\x04\x0e\x02\x0f\
    \x03\x12\x04\x89\x02\"$\n\x0c\n\x04\x04\x0e\x02\x10\x12\x04\x8a\x02\x08\
    \"\n\r\n\x05\x04\x0e\x02\x10\x04\x12\x04\x8a\x02\x08\x10\n\r\n\x05\x04\
    \x0e\x02\x10\x05\x12\x04\x8a\x02\x11\x15\n\r\n\x05\x04\x0e\x02\x10\x01\
    \x12\x04\x8a\x02\x16\x1c\n\r\n\x05\x04\x0e\x02\x10\x03\x12\x04\x8a\x02\
    \x1f!\n\x0c\n\x04\x04\x0e\x02\x11\x12\x04\x8b\x02\x086\n\r\n\x05\x04\x0e\
    \x02\x11\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x11\x05\x12\
    \x04\x8b\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x11\x01\x12\x04\x8b\x02\x180\
    \n\r\n\x05\x04\x0e\x02\x11\x03\x12\x04\x8b\x0235\n\x0c\n\x04\x04\x0e\x02\
    \x12\x12\x04\x8c\x02\x084\n\r\n\x05\x04\x0e\x02\x12\x04\x12\x04\x8c\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x02\x12\x05\x12\x04\x8c\x02\x11\x17\n\r\n\x05\
    \x04\x0e\x02\x12\x01\x12\x04\x8c\x02\x18.\n\r\n\x05\x04\x0e\x02\x12\x03\
    \x12\x04\x8c\x0213\n\x0c\n\x04\x04\x0e\x02\x13\x12\x04\x8d\x02\x083\n\r\
    \n\x05\x04\x0e\x02\x13\x04\x12\x04\x8d\x02\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x13\x05\x12\x04\x8d\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x13\x01\x12\x04\
    \x8d\x02\x18-\n\r\n\x05\x04\x0e\x02\x13\x03\x12\x04\x8d\x0202\n\x0c\n\
    \x04\x04\x0e\x02\x14\x12\x04\x8e\x02\x08,\n\r\n\x05\x04\x0e\x02\x14\x04\
    \x12\x04\x8e\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x14\x05\x12\x04\x8e\x02\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x14\x01\x12\x04\x8e\x02\x18&\n\r\n\x05\
    \x04\x0e\x02\x14\x03\x12\x04\x8e\x02)+\n\x0c\n\x04\x04\x0e\x02\x15\x12\
    \x04\x8f\x02\x08*\n\r\n\x05\x04\x0e\x02\x15\x04\x12\x04\x8f\x02\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x15\x05\x12\x04\x8f\x02\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x15\x01\x12\x04\x8f\x02\x18$\n\r\n\x05\x04\x0e\x02\x15\x03\x12\x04\
    \x8f\x02')\n\x0c\n\x04\x04\x0e\x02\x16\x12\x04\x90\x02\x08-\n\r\n\x05\
    \x04\x0e\x02\x16\x04\x12\x04\x90\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x16\
    \x05\x12\x04\x90\x02\x11\x18\n\r\n\x05\x04\x0e\x02\x16\x01\x12\x04\x90\
    \x02\x19'\n\r\n\x05\x04\x0e\x02\x16\x03\x12\x04\x90\x02*,\n\x0c\n\x04\
    \x04\x0e\x02\x17\x12\x04\x91\x02\x083\n\r\n\x05\x04\x0e\x02\x17\x04\x12\
    \x04\x91\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x17\x05\x12\x04\x91\x02\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x17\x01\x12\x04\x91\x02\x18-\n\r\n\x05\x04\
    \x0e\x02\x17\x03\x12\x04\x91\x0202\n\x0c\n\x04\x04\x0e\x02\x18\x12\x04\
    \x92\x02\x08,\n\r\n\x05\x04\x0e\x02\x18\x04\x12\x04\x92\x02\x08\x10\n\r\
    \n\x05\x04\x0e\x02\x18\x05\x12\x04\x92\x02\x11\x18\n\r\n\x05\x04\x0e\x02\
    \x18\x01\x12\x04\x92\x02\x19&\n\r\n\x05\x04\x0e\x02\x18\x03\x12\x04\x92\
    \x02)+\n\x0c\n\x04\x04\x0e\x02\x19\x12\x04\x93\x02\x080\n\r\n\x05\x04\
    \x0e\x02\x19\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x19\x05\
    \x12\x04\x93\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x19\x01\x12\x04\x93\x02\
    \x18*\n\r\n\x05\x04\x0e\x02\x19\x03\x12\x04\x93\x02-/\n\x0c\n\x04\x04\
    \x0e\x02\x1a\x12\x04\x94\x02\x080\n\r\n\x05\x04\x0e\x02\x1a\x04\x12\x04\
    \x94\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x1a\x05\x12\x04\x94\x02\x11\x17\n\
    \r\n\x05\x04\x0e\x02\x1a\x01\x12\x04\x94\x02\x18*\n\r\n\x05\x04\x0e\x02\
    \x1a\x03\x12\x04\x94\x02-/\n\x0c\n\x04\x04\x0e\x02\x1b\x12\x04\x95\x02\
    \x08/\n\r\n\x05\x04\x0e\x02\x1b\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\
    \x04\x0e\x02\x1b\x05\x12\x04\x95\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x1b\
    \x01\x12\x04\x95\x02\x18)\n\r\n\x05\x04\x0e\x02\x1b\x03\x12\x04\x95\x02,\
    .\n\x0c\n\x04\x04\x0e\x02\x1c\x12\x04\x96\x02\x08&\n\r\n\x05\x04\x0e\x02\
    \x1c\x04\x12\x04\x96\x02\x08\x10\n\r\n\x05\x04\x0e\x02\x1c\x05\x12\x04\
    \x96\x02\x11\x17\n\r\n\x05\x04\x0e\x02\x1c\x01\x12\x04\x96\x02\x18\x20\n\
    \r\n\x05\x04\x0e\x02\x1c\x03\x12\x04\x96\x02#%\n\x0c\n\x04\x04\x0e\x02\
    \x1d\x12\x04\x97\x02\x08*\n\r\n\x05\x04\x0e\x02\x1d\x04\x12\x04\x97\x02\
    \x08\x10\n\r\n\x05\x04\x0e\x02\x1d\x05\x12\x04\x97\x02\x11\x17\n\r\n\x05\
    \x04\x0e\x02\x1d\x01\x12\x04\x97\x02\x18$\n\r\n\x05\x04\x0e\x02\x1d\x03\
    \x12\x04\x97\x02')\n\x0c\n\x02\x04\x0f\x12\x06\x9a\x02\0\xa5\x02\x01\n\
    \x0b\n\x03\x04\x0f\x01\x12\x04\x9a\x02\x08\x18\n\x0c\n\x04\x04\x0f\x02\0\
    \x12\x04\x9b\x02\x08'\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\x9b\x02\x08\
    \x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x9b\x02\x11\x17\n\r\n\x05\x04\
    \x0f\x02\0\x01\x12\x04\x9b\x02\x18\"\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\
    \x9b\x02%&\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\x9c\x02\x08&\n\r\n\x05\
    \x04\x0f\x02\x01\x04\x12\x04\x9c\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x01\
    \x05\x12\x04\x9c\x02\x11\x17\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x9c\
    \x02\x18!\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x9c\x02$%\n\x0c\n\x04\
    \x04\x0f\x02\x02\x12\x04\x9d\x02\x08%\n\r\n\x05\x04\x0f\x02\x02\x04\x12\
    \x04\x9d\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x02\x05\x12\x04\x9d\x02\x11\
    \x17\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x9d\x02\x18\x20\n\r\n\x05\x04\
    \x0f\x02\x02\x03\x12\x04\x9d\x02#$\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\
    \x9e\x02\x08%\n\r\n\x05\x04\x0f\x02\x03\x04\x12\x04\x9e\x02\x08\x10\n\r\
    \n\x05\x04\x0f\x02\x03\x05\x12\x04\x9e\x02\x11\x17\n\r\n\x05\x04\x0f\x02\
    \x03\x01\x12\x04\x9e\x02\x18\x20\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\
    \x9e\x02#$\n\x0c\n\x04\x04\x0f\x02\x04\x12\x04\x9f\x02\x08!\n\r\n\x05\
    \x04\x0f\x02\x04\x04\x12\x04\x9f\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x04\
    \x05\x12\x04\x9f\x02\x11\x17\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\x9f\
    \x02\x18\x1c\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\x9f\x02\x1f\x20\n\x0c\
    \n\x04\x04\x0f\x02\x05\x12\x04\xa0\x02\x08%\n\r\n\x05\x04\x0f\x02\x05\
    \x04\x12\x04\xa0\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x05\x05\x12\x04\xa0\
    \x02\x11\x17\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\xa0\x02\x18\x20\n\r\n\
    \x05\x04\x0f\x02\x05\x03\x12\x04\xa0\x02#$\n\x0c\n\x04\x04\x0f\x02\x06\
    \x12\x04\xa1\x02\x08)\n\r\n\x05\x04\x0f\x02\x06\x04\x12\x04\xa1\x02\x08\
    \x10\n\r\n\x05\x04\x0f\x02\x06\x05\x12\x04\xa1\x02\x11\x17\n\r\n\x05\x04\
    \x0f\x02\x06\x01\x12\x04\xa1\x02\x18$\n\r\n\x05\x04\x0f\x02\x06\x03\x12\
    \x04\xa1\x02'(\n\x0c\n\x04\x04\x0f\x02\x07\x12\x04\xa2\x02\x08%\n\r\n\
    \x05\x04\x0f\x02\x07\x04\x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04\x0f\x02\
    \x07\x05\x12\x04\xa2\x02\x11\x17\n\r\n\x05\x04\x0f\x02\x07\x01\x12\x04\
    \xa2\x02\x18\x20\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\xa2\x02#$\n\x0c\n\
    \x04\x04\x0f\x02\x08\x12\x04\xa3\x02\x08%\n\r\n\x05\x04\x0f\x02\x08\x04\
    \x12\x04\xa3\x02\x08\x10\n\r\n\x05\x04\x0f\x02\x08\x05\x12\x04\xa3\x02\
    \x11\x16\n\r\n\x05\x04\x0f\x02\x08\x01\x12\x04\xa3\x02\x17\x20\n\r\n\x05\
    \x04\x0f\x02\x08\x03\x12\x04\xa3\x02#$\n\x0c\n\x04\x04\x0f\x02\t\x12\x04\
    \xa4\x02\x08#\n\r\n\x05\x04\x0f\x02\t\x04\x12\x04\xa4\x02\x08\x10\n\r\n\
    \x05\x04\x0f\x02\t\x05\x12\x04\xa4\x02\x11\x17\n\r\n\x05\x04\x0f\x02\t\
    \x01\x12\x04\xa4\x02\x18\x1d\n\r\n\x05\x04\x0f\x02\t\x03\x12\x04\xa4\x02\
    \x20\"\n\x0c\n\x02\x04\x10\x12\x06\xa7\x02\0\xb0\x02\x01\n\x0b\n\x03\x04\
    \x10\x01\x12\x04\xa7\x02\x08!\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xa8\x02\
    \x08&\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xa8\x02\x08\x10\n\r\n\x05\x04\
    \x10\x02\0\x05\x12\x04\xa8\x02\x11\x17\n\r\n\x05\x04\x10\x02\0\x01\x12\
    \x04\xa8\x02\x18!\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa8\x02$%\n\x0c\n\
    \x04\x04\x10\x02\x01\x12\x04\xa9\x02\x08-\n\r\n\x05\x04\x10\x02\x01\x04\
    \x12\x04\xa9\x02\x08\x10\n\r\n\x05\x04\x10\x02\x01\x05\x12\x04\xa9\x02\
    \x11\x16\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xa9\x02\x17(\n\r\n\x05\
    \x04\x10\x02\x01\x03\x12\x04\xa9\x02+,\n\x0c\n\x04\x04\x10\x02\x02\x12\
    \x04\xaa\x02\x08*\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xaa\x02\x08\x10\
    \n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xaa\x02\x11\x16\n\r\n\x05\x04\x10\
    \x02\x02\x01\x12\x04\xaa\x02\x17%\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\
    \xaa\x02()\n\x0c\n\x04\x04\x10\x02\x03\x12\x04\xab\x02\x08,\n\r\n\x05\
    \x04\x10\x02\x03\x04\x12\x04\xab\x02\x08\x10\n\r\n\x05\x04\x10\x02\x03\
    \x05\x12\x04\xab\x02\x11\x16\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xab\
    \x02\x17'\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xab\x02*+\n\x0c\n\x04\
    \x04\x10\x02\x04\x12\x04\xac\x02\x085\n\r\n\x05\x04\x10\x02\x04\x04\x12\
    \x04\xac\x02\x08\x10\n\r\n\x05\x04\x10\x02\x04\x05\x12\x04\xac\x02\x11\
    \x17\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\xac\x02\x180\n\r\n\x05\x04\
    \x10\x02\x04\x03\x12\x04\xac\x0234\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\
    \xad\x02\x08\"\n\r\n\x05\x04\x10\x02\x05\x04\x12\x04\xad\x02\x08\x10\n\r\
    \n\x05\x04\x10\x02\x05\x05\x12\x04\xad\x02\x11\x15\n\r\n\x05\x04\x10\x02\
    \x05\x01\x12\x04\xad\x02\x16\x1d\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\
    \xad\x02\x20!\n\x0c\n\x04\x04\x10\x02\x06\x12\x04\xae\x02\x08)\n\r\n\x05\
    \x04\x10\x02\x06\x04\x12\x04\xae\x02\x08\x10\n\r\n\x05\x04\x10\x02\x06\
    \x05\x12\x04\xae\x02\x11\x17\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xae\
    \x02\x18$\n\r\n\x05\x04\x10\x02\x06\x03\x12\x04\xae\x02'(\n\x0c\n\x04\
    \x04\x10\x02\x07\x12\x04\xaf\x02\x08*\n\r\n\x05\x04\x10\x02\x07\x04\x12\
    \x04\xaf\x02\x08\x10\n\r\n\x05\x04\x10\x02\x07\x05\x12\x04\xaf\x02\x11\
    \x17\n\r\n\x05\x04\x10\x02\x07\x01\x12\x04\xaf\x02\x18%\n\r\n\x05\x04\
    \x10\x02\x07\x03\x12\x04\xaf\x02()\n\x0c\n\x02\x04\x11\x12\x06\xb2\x02\0\
    \xb5\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xb2\x02\x08\x18\n\x0c\n\x04\
    \x04\x11\x02\0\x12\x04\xb3\x02\x08!\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\
    \xb3\x02\x08\x10\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xb3\x02\x11\x17\n\r\
    \n\x05\x04\x11\x02\0\x01\x12\x04\xb3\x02\x18\x1c\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\xb3\x02\x1f\x20\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xb4\x02\
    \x08\"\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xb4\x02\x08\x10\n\r\n\x05\
    \x04\x11\x02\x01\x05\x12\x04\xb4\x02\x11\x17\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\xb4\x02\x18\x1d\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xb4\
    \x02\x20!\n\x0c\n\x02\x04\x12\x12\x06\xb7\x02\0\xb9\x02\x01\n\x0b\n\x03\
    \x04\x12\x01\x12\x04\xb7\x02\x08\x17\n\x0c\n\x04\x04\x12\x02\0\x12\x04\
    \xb8\x02\x08-\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xb8\x02\x08\x10\n\r\n\
    \x05\x04\x12\x02\0\x06\x12\x04\xb8\x02\x11\"\n\r\n\x05\x04\x12\x02\0\x01\
    \x12\x04\xb8\x02#(\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xb8\x02+,\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(19);
            messages.push(CMsgIPAddress::generated_message_descriptor_data());
            messages.push(CMsgIPAddressBucket::generated_message_descriptor_data());
            messages.push(CMsgGCRoutingProtoBufHeader::generated_message_descriptor_data());
            messages.push(CMsgProtoBufHeader::generated_message_descriptor_data());
            messages.push(CMsgMulti::generated_message_descriptor_data());
            messages.push(CMsgProtobufWrapped::generated_message_descriptor_data());
            messages.push(CMsgAuthTicket::generated_message_descriptor_data());
            messages.push(CCDDBAppDetailCommon::generated_message_descriptor_data());
            messages.push(CMsgAppRights::generated_message_descriptor_data());
            messages.push(CCuratorPreferences::generated_message_descriptor_data());
            messages.push(CLocalizationToken::generated_message_descriptor_data());
            messages.push(CClanEventUserNewsTuple::generated_message_descriptor_data());
            messages.push(CClanMatchEventByRange::generated_message_descriptor_data());
            messages.push(CCommunity_ClanAnnouncementInfo::generated_message_descriptor_data());
            messages.push(CClanEventData::generated_message_descriptor_data());
            messages.push(CBilling_Address::generated_message_descriptor_data());
            messages.push(CPackageReservationStatus::generated_message_descriptor_data());
            messages.push(CMsgKeyValuePair::generated_message_descriptor_data());
            messages.push(CMsgKeyValueSet::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(EBanContentCheckResult::generated_enum_descriptor_data());
            enums.push(EProtoClanEventType::generated_enum_descriptor_data());
            enums.push(PartnerEventNotificationType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
